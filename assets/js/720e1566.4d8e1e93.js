"use strict";(self.webpackChunkAditya_Vaidyam=self.webpackChunkAditya_Vaidyam||[]).push([[666],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),d=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=d(e.components);return a.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),u=d(n),h=i,m=u["".concat(s,".").concat(h)]||u[h]||c[h]||o;return n?a.createElement(m,r(r({ref:t},p),{},{components:n})):a.createElement(m,r({ref:t},p))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,r[1]=l;for(var d=2;d<o;d++)r[d]=n[d];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},4491:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>c,frontMatter:()=>o,metadata:()=>l,toc:()=>d});var a=n(7462),i=(n(7294),n(3905));const o={},r="An Exercise in Modern Cocoa Views",l={permalink:"/blog/2018/03/22/",source:"@site/blog/2018-03-22.md",title:"An Exercise in Modern Cocoa Views",description:'Like I said in the previous "episode", recently, I\'ve wanted to get around to adding "hot key" support for Parrot, and realized I didn\'t like any of the existing solutions:',date:"2018-03-22T00:00:00.000Z",formattedDate:"March 22, 2018",tags:[],readingTime:42.36,truncated:!0,authors:[],frontMatter:{},prevItem:{title:"DIY: Core Animation",permalink:"/blog/2019/02/19/"},nextItem:{title:"Building a Better RegisterEventHotKey",permalink:"/blog/2018/03/16/"}},s={authorsImageUrls:[]},d=[{value:"Principles of Modern Views",id:"principles-of-modern-views",level:2},{value:"Subclassing a <code>View</code> or a <code>ViewController</code>",id:"subclassing-a-view-or-a-viewcontroller",level:3},{value:"Layers",id:"layers",level:3},{value:"<code>NSControl</code>?",id:"nscontrol",level:3},{value:"Working With <code>CGSKeyboardShortcut</code>",id:"working-with-cgskeyboardshortcut",level:2},{value:"Human-Readable String Representation",id:"human-readable-string-representation",level:3},{value:"A Simpler Shortcut Representation",id:"a-simpler-shortcut-representation",level:3},{value:"Being A Good Citizen",id:"being-a-good-citizen",level:2},{value:"Accepting Key View",id:"accepting-key-view",level:3},{value:"Responding to User Input",id:"responding-to-user-input",level:3},{value:"<code>updateLayer</code>",id:"updatelayer",level:3},{value:"Drawing a Button Without Being One",id:"drawing-a-button-without-being-one",level:3},{value:"Focus Rings",id:"focus-rings",level:3},{value:"<code>layout</code>, <code>updateConstraints</code>, &amp; <code>intrinsicContentSize</code>",id:"layout-updateconstraints--intrinsiccontentsize",level:3},{value:"Hover &amp; Cursors",id:"hover--cursors",level:3},{value:"Haptic &amp; Audio Feedback",id:"haptic--audio-feedback",level:3},{value:"Window Keyedness",id:"window-keyedness",level:3},{value:"Global HotKey Interference",id:"global-hotkey-interference",level:3},{value:"String Localization",id:"string-localization",level:3},{value:"Accessibility",id:"accessibility",level:3},{value:"<code>NSCoding</code> &amp; State Restoration",id:"nscoding--state-restoration",level:3},{value:"Context <code>NSMenu</code> Popups",id:"context-nsmenu-popups",level:3},{value:"Undo Management",id:"undo-management",level:3},{value:"Conclusion",id:"conclusion",level:2}],p={toc:d};function c(e){let{components:t,...o}=e;return(0,i.kt)("wrapper",(0,a.Z)({},p,o,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,'Like I said in the previous "episode", recently, I\'ve wanted to get around to adding "hot key" support for Parrot, and realized I didn\'t like any of the existing solutions:'),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Use ",(0,i.kt)("inlineCode",{parentName:"li"},"MASShortcut")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"ShortcutRecorder")," which are tried and proven to work in ObjC-land."),(0,i.kt)("li",{parentName:"ol"},"Use a new but not proven Swift hotkey recorder (there's a few out there)."),(0,i.kt)("li",{parentName:"ol"},"Roll my own (probably somehow using dangerous private SPI) and not test it at all! ")),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Obviously I went with option #3.")," "),(0,i.kt)("p",null,"And here we are now, onto part two of the thrilling saga in which you witness me breaking AppKit and WindowServer and inviting the wrath and fury of the engineers that work on said components. I hope you brought your popcorn. "),(0,i.kt)("p",null,"I'd like to clarify that we'll only be building a single self-contained control that manages a single shortcut. I expect Parrot, like most apps, will not need a Command Editor like Final Cut Pro, which is purpose-built for video editors with more than two keyboards and more than two hands to match, clearly."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Final Cut Pro Command Editor",src:n(6824).Z,width:"1800",height:"1220"})),(0,i.kt)("p",null,"Our end result will look, sound, and feel something like this, instead:"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"KeyboardShortcutView",src:n(4306).Z,width:"398",height:"340"})),(0,i.kt)("p",null,"Before we get into the nitty gritty hand-holding pair-programming stuff, if you'd like to jump straight to the comment-annotated final source code, ",(0,i.kt)("a",{parentName:"p",href:"https://gist.github.com/avaidyam/32975976c23dd3b38336f22d971f5eaa"},"I've included a snapshot here."),' It\'s the whole final product, exactly 1500 LOC, including the code from the previous "episode" - the corresponding keyboard shortcut facility! If you think this should be a formal repository and whatnot, contact me on Twitter or Github @avaidyam!'),(0,i.kt)("h2",{id:"principles-of-modern-views"},"Principles of Modern Views"),(0,i.kt)("h3",{id:"subclassing-a-view-or-a-viewcontroller"},"Subclassing a ",(0,i.kt)("inlineCode",{parentName:"h3"},"View")," or a ",(0,i.kt)("inlineCode",{parentName:"h3"},"ViewController")),(0,i.kt)("p",null,"The first question we should answer is, what kind of component are we building? The answer to this question is what determines what kind of a subclass we are, as well as the interaction model we have with other components in our app. "),(0,i.kt)("p",null,"When you're building a discrete component that takes a program input and presents a display to the user, and in the case of a control, receives user input and presents a program output, you should be subclassing a ",(0,i.kt)("inlineCode",{parentName:"p"},"View"),". Anything beyond that should be a subclass of a ",(0,i.kt)("inlineCode",{parentName:"p"},"ViewController"),", a component that mediates interactions between other components, or a component that handles model/database objects, or really just anything else. A ",(0,i.kt)("inlineCode",{parentName:"p"},"View")," should be easily reusable in other contexts outside of the one you're building in immediately, but a ",(0,i.kt)("inlineCode",{parentName:"p"},"ViewController")," is not necessarily capable of fulfilling this contract. "),(0,i.kt)("p",null,"For example, a contact avatar would best be a ",(0,i.kt)("inlineCode",{parentName:"p"},"View")," subclass, but a contact avatar ",(0,i.kt)("strong",{parentName:"p"},"picker")," should be a ",(0,i.kt)("inlineCode",{parentName:"p"},"ViewController"),", as it not only displays an avatar image, but it also allows the user to select an image, and might handle the synchronization with the contact store (maybe it's a JSON file, maybe it's a remote API, or maybe it's a ",(0,i.kt)("inlineCode",{parentName:"p"},"CNContact"),"). "),(0,i.kt)("p",null,"On macOS, you should also consider subclassing an ",(0,i.kt)("inlineCode",{parentName:"p"},"WindowController")," if the component you're building both composes other components (like a ",(0,i.kt)("inlineCode",{parentName:"p"},"ViewController"),") and is self-contained in a ",(0,i.kt)("inlineCode",{parentName:"p"},"Window")," -- a contact avatar picker may not fit this criteria, but a contact ",(0,i.kt)("strong",{parentName:"p"},"editor panel")," would, where the contact avatar picker would be a ",(0,i.kt)("inlineCode",{parentName:"p"},"ViewController")," nested within, alongside name, phone, email, and other editable fields."),(0,i.kt)("h3",{id:"layers"},"Layers"),(0,i.kt)("p",null,"While ",(0,i.kt)("inlineCode",{parentName:"p"},"AppKit")," is often seen as a dinosaur compared to its younger sibling, ",(0,i.kt)("inlineCode",{parentName:"p"},"UIKit"),", it's important to know that nearly all the design patterns that ",(0,i.kt)("inlineCode",{parentName:"p"},"UIKit")," sports came from ",(0,i.kt)("inlineCode",{parentName:"p"},"AppKit"),", and if not, they eventually make their way back into ",(0,i.kt)("inlineCode",{parentName:"p"},"AppKit"),", with the exception of a very limited few. For example, the concept of a ",(0,i.kt)("inlineCode",{parentName:"p"},"UIView")," being backed by an underlying ",(0,i.kt)("inlineCode",{parentName:"p"},"CALayer")," type is very similar to how ",(0,i.kt)("inlineCode",{parentName:"p"},"NSControl")," is (rather, used to be?) backed by ",(0,i.kt)("inlineCode",{parentName:"p"},"NSCell"),". The differences being that the ",(0,i.kt)("inlineCode",{parentName:"p"},"CALayer")," is actually driving the rendering of display content instead of the ",(0,i.kt)("inlineCode",{parentName:"p"},"UIView"),", and that ",(0,i.kt)("inlineCode",{parentName:"p"},"NSCell"),' acts as a "rubber stamp" for specific event handling and drawing. '),(0,i.kt)("p",null,"When it comes to layer-backed views, ",(0,i.kt)("inlineCode",{parentName:"p"},"AppKit")," actually has several modes by which to achieve this: "),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Layer-hosting:")," ",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"self.layer = CALayer(); self.wantsLayer = true")),(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"NSView")," owns the ",(0,i.kt)("inlineCode",{parentName:"li"},"CALayer")," and is responsible for creating and managing it; ",(0,i.kt)("inlineCode",{parentName:"li"},"NSView")," does nothing except create its rendering surface."))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Implicit Layer-backed and drawn:")," ",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"superview.wantsLayer = true")),(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"NSView")," has an explicitly layer-backed parent and will grant itself a private ",(0,i.kt)("inlineCode",{parentName:"li"},"CALayer")," to draw into, using the rendering surface of the layer-backed parent's ",(0,i.kt)("inlineCode",{parentName:"li"},"CALayer"),"."))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Implicit Superview Layer-drawn:")," ",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"superview.wantsLayer = true; superview.canDrawSubviewsIntoLayer = true")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"If you expect to use animations or any layer-related properties, you must opt out of this!")),(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"NSView")," has an explicitly layer-backed parent whose ",(0,i.kt)("inlineCode",{parentName:"li"},"canDrawSubviewsIntoLayer")," is true, and thus, will not grant itself a ",(0,i.kt)("inlineCode",{parentName:"li"},"CALayer"),", and instead draw directly into the layer-backed parent's ",(0,i.kt)("inlineCode",{parentName:"li"},"CALayer"),". "))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Explicit Layer-backed and drawn:")," ",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"self.wantsLayer = true")),(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"NSView")," has explicitly declared itself as layer-backed and will set its layer's ",(0,i.kt)("inlineCode",{parentName:"li"},"contents")," with the result of its ",(0,i.kt)("inlineCode",{parentName:"li"},"drawRect:")," call (that is, drawing directly into the layer)."),(0,i.kt)("li",{parentName:"ul"},"If this view declares that it ",(0,i.kt)("inlineCode",{parentName:"li"},"canDrawSubviewsIntoLayer"),", its subviews are rendered into this view's ",(0,i.kt)("inlineCode",{parentName:"li"},"layer"),". "))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Explicit Layer-backed:")," ",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"self.wantsLayer = true; self.wantsUpdateLayer = true; self.layerContentsRedrawPolicy = .onSetNeedsDisplay")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("em",{parentName:"li"},"Note: you must actually override the ",(0,i.kt)("inlineCode",{parentName:"em"},"wantsUpdateLayer")," function in your custom ",(0,i.kt)("inlineCode",{parentName:"em"},"NSView")," subclass to achieve this, as there is no setter for the property. This property is queried at each view update cycle, if the view is marked dirty - don't attempt any complex computations here.")),(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"NSView")," has explicitly declared itself as layer-backed and that it will not ",(0,i.kt)("inlineCode",{parentName:"li"},"drawRect:")," into the layer. Instead, the layer is manually managed, ",(0,i.kt)("strong",{parentName:"li"},"but not owned by the subview"),", during the ",(0,i.kt)("inlineCode",{parentName:"li"},"updateLayer")," method."),(0,i.kt)("li",{parentName:"ul"},"It's important to set ",(0,i.kt)("inlineCode",{parentName:"li"},"layerContentsRedrawPolicy")," to ",(0,i.kt)("inlineCode",{parentName:"li"},".onSetNeedsDisplay")," here, since the ",(0,i.kt)("inlineCode",{parentName:"li"},"layer.contents")," are no longer dependent on your ",(0,i.kt)("inlineCode",{parentName:"li"},"drawRect:"),".")))),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},'Note: where I say "rendering surface", the underlying type is either a ',(0,i.kt)("inlineCode",{parentName:"em"},"CAContext"),", which is used by the WindowServer to render your layers out-of-process, ",(0,i.kt)("strong",{parentName:"em"},"or")," by ",(0,i.kt)("inlineCode",{parentName:"em"},"CAViewRef")," which can be thought of as a wrapper around `CA::Render::"),"`, which is rendered in-process but likely off the main thread.*"),(0,i.kt)("p",null,"Personally, I think the ",(0,i.kt)("inlineCode",{parentName:"p"},"NSView.layer")," property should never have been public; instead, if layer-hosting, it's the view's responsibility to keep a strong reference to its layer, and in explicit ",(0,i.kt)("inlineCode",{parentName:"p"},"updateLayer")," views, the ",(0,i.kt)("inlineCode",{parentName:"p"},"updateLayer")," method signature should have been ",(0,i.kt)("inlineCode",{parentName:"p"},"- (void)updateLayer:(CALayer *)layer"),", so as to pass in the ",(0,i.kt)("inlineCode",{parentName:"p"},"AppKit"),"-owned layer for the view to update. Too many iOS developers mistake ",(0,i.kt)("inlineCode",{parentName:"p"},"NSView")," for being identical to ",(0,i.kt)("inlineCode",{parentName:"p"},"UIView"),", where it's almost even orthogonal to it depending on the scenario. ",(0,i.kt)("inlineCode",{parentName:"p"},"UIView"),"'s layer ownership model is most closely represented by layer-hosting, but in AppKit, this means layer hierarchies and other view facilities are not managed for you, and so, the closest to it would be explicit layer-backed. This is the approach we'll be taking. It may appear that you won't be able to use ",(0,i.kt)("inlineCode",{parentName:"p"},"drawRect:"),", but there are ways to work around that, as we'll see soon."),(0,i.kt)("h3",{id:"nscontrol"},(0,i.kt)("inlineCode",{parentName:"h3"},"NSControl"),"?"),(0,i.kt)("p",null,"The next question we need to tackle is, should we design a subclass of ",(0,i.kt)("inlineCode",{parentName:"p"},"NSControl")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"NSView"),"? In this specific instance, the answer is pretty straight forward, as we're designing a control, it makes the most sense to take advantage of ",(0,i.kt)("inlineCode",{parentName:"p"},"NSControl"),"... it's in the name, after all. "),(0,i.kt)("p",null,"However, here's a few things you'll want to consider:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"strong"},"NSCell"),":")," Because this class has been soft-deprecated, it's pretty safe to assume ",(0,i.kt)("inlineCode",{parentName:"li"},"NSControl"),"s can be written without a corresponding cell (spoiler alert: yep)."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Polymorphic ",(0,i.kt)("inlineCode",{parentName:"strong"},"*Value")," Properties:")," ",(0,i.kt)("inlineCode",{parentName:"li"},"NSControl")," has several ",(0,i.kt)("inlineCode",{parentName:"li"},"*Value")," properties, like ",(0,i.kt)("inlineCode",{parentName:"li"},"objectValue"),", and ",(0,i.kt)("inlineCode",{parentName:"li"},"take*ValueFrom(_:)")," methods to go along with them, for use in Interface Builder and Cocoa Bindings. These aren't really that helpful, from my experience, and if they were, re-implementing them for ",(0,i.kt)("inlineCode",{parentName:"li"},"NSView")," classes isn't that hard."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Field Editors:")," This is another of those ",(0,i.kt)("inlineCode",{parentName:"li"},"NeXT"),"-era ideas, where instead of loading say, a hundred, heavyweight ",(0,i.kt)("inlineCode",{parentName:"li"},"NSTextView"),"s into a window, which would kill performance and memory, you would only load one, and share it across a hundred lightweight ",(0,i.kt)("inlineCode",{parentName:"li"},"NSTextFieldCell"),"s. It doesn't make much of a difference in 2018, especially since your memory and performance competition are Electron apps: ",(0,i.kt)("strong",{parentName:"li"},"as long as you don't use Electron (or develop in JS for Desktop apps), you're winning.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Target/Action Model:")," This is what we know and love ",(0,i.kt)("inlineCode",{parentName:"li"},"NSControl")," (and ",(0,i.kt)("inlineCode",{parentName:"li"},"UIControl"),") for! A control has a target, and an action that fires on that target, when the control has been activated somehow. ",(0,i.kt)("inlineCode",{parentName:"li"},"UIControl")," goes a step further, allowing you to register different targets for different event types, but ",(0,i.kt)("inlineCode",{parentName:"li"},"NSControl")," offers a single condition-setting ",(0,i.kt)("inlineCode",{parentName:"li"},"sendAction(on:)")," version. It's arguable which is more convenient.")),(0,i.kt)("p",null,"In summary, there's a few reasons to use or not use ",(0,i.kt)("inlineCode",{parentName:"p"},"NSControl"),', but after weighing out the options, a standard of conformity in being a "control," and just having the target/action model already implemented for you is pretty helpful, so we\'ll go with that.'),(0,i.kt)("h2",{id:"working-with-cgskeyboardshortcut"},"Working With ",(0,i.kt)("inlineCode",{parentName:"h2"},"CGSKeyboardShortcut")),(0,i.kt)("h3",{id:"human-readable-string-representation"},"Human-Readable String Representation"),(0,i.kt)("p",null,"Before we begin building a user-facing control, we need to make sure ",(0,i.kt)("inlineCode",{parentName:"p"},"CGSKeyboardShortcut")," and friends can be translated to a human-readable string representation. This is because modifiers and virtual key codes that compose a shortcut like ",(0,i.kt)("inlineCode",{parentName:"p"},"\u2318D")," are device-independent mechanism, and when registering a shortcut, we can't use a string containing the shortcut. It's important to note that virtual key codes are not ASCII-ordered (that is, sequential in the ASCII table), and may not always have a corresponding glyph to match the key. To determine what the virtual key code points to on the current keyboard, we unfortunately have to return to ",(0,i.kt)("inlineCode",{parentName:"p"},"Carbon.framework")," for ",(0,i.kt)("em",{parentName:"p"},"Text Input Services")," (",(0,i.kt)("inlineCode",{parentName:"p"},"TIS"),") and ",(0,i.kt)("em",{parentName:"p"},"Unicode Utilities")," (",(0,i.kt)("inlineCode",{parentName:"p"},"UC"),"). To translate the key code, we grab the current input source's keyboard layout, and use the ",(0,i.kt)("inlineCode",{parentName:"p"},"UCKeyTranslate")," facility to determine what the unicode character resulting from pressing this key in the current layout will be. There are a few special cases like Fn keys that print ",(0,i.kt)("inlineCode",{parentName:"p"},"F13"),", for example, or the spacebar, which we want to print ",(0,i.kt)("inlineCode",{parentName:"p"},"Space"),"."),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Cocoa key equivalents, used by ",(0,i.kt)("inlineCode",{parentName:"em"},"NSMenu")," and ",(0,i.kt)("inlineCode",{parentName:"em"},"NSButton"),", for example, internally translate a string containg ",(0,i.kt)("inlineCode",{parentName:"em"},'"x"')," into the right virtual key code; this is left as an exercise for the reader. Hint: just create a reverse mapping table and look it up!")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-swift"},'public extension CGKeyCode {\n    public var isFunctionKey: Bool {\n        switch Int(self) {\n        case kVK_F1, kVK_F2, kVK_F3, kVK_F4, kVK_F5, kVK_F6, kVK_F7, kVK_F8,\n             kVK_F9, kVK_F10, kVK_F11, kVK_F12, kVK_F13, kVK_F14, kVK_F15,\n             kVK_F16, kVK_F17, kVK_F18, kVK_F19, kVK_F20:\n            return true\n        default:\n            return false\n        }\n    }\n\n    public var characters: String {\n        if let special = CGKeyCode._special[Int(self)] { return special }\n        \n        let source = TISCopyCurrentASCIICapableKeyboardLayoutInputSource().takeUnretainedValue()\n        let layoutData = TISGetInputSourceProperty(source, kTISPropertyUnicodeKeyLayoutData)\n        let dataRef = unsafeBitCast(layoutData, to: CFData.self)\n        let keyLayout = unsafeBitCast(CFDataGetBytePtr(dataRef), to: UnsafePointer<CoreServices.UCKeyboardLayout>.self)\n        \n        let keyTranslateOptions = OptionBits(CoreServices.kUCKeyTranslateNoDeadKeysBit)\n        var deadKeyState: UInt32 = 0\n        let maxChars = 256\n        var chars = [UniChar](repeating: 0, count: maxChars)\n        var length = 0\n        \n        let error = CoreServices.UCKeyTranslate(keyLayout, self,\n                                                UInt16(CoreServices.kUCKeyActionDisplay),\n                                                0, UInt32(LMGetKbdType()),\n                                                keyTranslateOptions, &deadKeyState,\n                                                maxChars, &length, &chars)\n        \n        if error != noErr { return "" }\n        return NSString(characters: &chars, length: length).uppercased\n    }\n    private static var _special: [Int: String] = [...]\n}\n\npublic extension CGEventFlags {\n    public var characters: String {\n        var string = ""\n        if self.contains(.maskAlphaShift) { string.append("\u21ea") }\n        if self.contains(.maskHelp) { string.append("?\u20dd") }\n        if self.contains(.maskControl) { string.append("\u2303") }\n        if self.contains(.maskAlternate) { string.append("\u2325") }\n        if self.contains(.maskShift) { string.append("\u21e7") }\n        if self.contains(.maskCommand) { string.append("\u2318") }\n        return string\n    }\n}\n\npublic extension NSEvent.ModifierFlags {\n    public var characters: String {\n        return CGEventFlags(self).characters\n    }\n}\n')),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Portions of this code are copyright \xa9 2016 Shunsuke Furubayashi, author of the ",(0,i.kt)("inlineCode",{parentName:"em"},"Magnet")," library.")),(0,i.kt)("h3",{id:"a-simpler-shortcut-representation"},"A Simpler Shortcut Representation"),(0,i.kt)("p",null,"Because we don't want to lock ourselves into ",(0,i.kt)("inlineCode",{parentName:"p"},"CGSKeyboardShortcut"),", and we don't exactly manage state like ",(0,i.kt)("inlineCode",{parentName:"p"},"identifier")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"acquisitionPolicy"),", which are more within-app intrinsics, we'll define a new, simpler type: ",(0,i.kt)("inlineCode",{parentName:"p"},"KeyboardShortcutView.Pair = (CGKeyCode, CGEventFlags)"),", and create two wrapper functions to transform it to and from an ",(0,i.kt)("inlineCode",{parentName:"p"},"NSDictionary"),". This is important because we'll need to be able to encode and decode it for state restoration and ",(0,i.kt)("inlineCode",{parentName:"p"},"NSCoding"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-swift"},'open class KeyboardShortcutView: NSControl, ... {\n    public typealias Pair = (keyCode: CGKeyCode, modifierFlags: CGEventFlags)\n}\n\npublic func representation(of pair: KeyboardShortcutView.Pair?) -> NSDictionary? {\n    guard let pair = pair else { return nil }\n    return [\n        "keyCode": pair.keyCode,\n        "modifierFlags": pair.modifierFlags.rawValue\n    ] as NSDictionary\n}\npublic func representation(of dict: NSDictionary?) -> KeyboardShortcutView.Pair? {\n    guard let dict = dict as? [String: Any],\n        let kc = dict["keyCode"] as? CGKeyCode,\n        let mf = dict["modifierFlags"] as? CGEventFlags.RawValue\n        else { return nil }\n    return (kc, CGEventFlags(rawValue: mf))\n}\n')),(0,i.kt)("p",null,"With that, we have a facility to converse with other keyboard shortcut libraries or non-Swift objects, like ",(0,i.kt)("inlineCode",{parentName:"p"},"UserDefaults"),". ",(0,i.kt)("em",{parentName:"p"},"(Recall that tuples cannot conform to ",(0,i.kt)("inlineCode",{parentName:"em"},"Codable"),"!)")),(0,i.kt)("h2",{id:"being-a-good-citizen"},"Being A Good Citizen"),(0,i.kt)("p",null,"We'll have our recorder control compose a label (",(0,i.kt)("inlineCode",{parentName:"p"},"NSTextField"),") and a record/stop button (",(0,i.kt)("inlineCode",{parentName:"p"},"NSButton"),"):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-swift"},'open class KeyboardShortcutView: NSControl, ... {\n\n    /*@objc*/ open weak var delegate: KeyboardShortcutViewDelegate? {\n        willSet { self.willChangeValue(forKey: #function) }\n        didSet { self.didChangeValue(forKey: #function) }\n    }\n    \n    @objc open override var alignment: NSTextAlignment {\n        get { return self.textLabel.alignment }\n        set { self.textLabel.alignment = newValue }\n    }\n    \n    @objc open var tintColor: NSColor = .keyboardFocusIndicatorColor {\n        didSet { /* ... */ }\n    }\n    @objc open var placeholderString: String? {\n        get { return self.textLabel.placeholderAttributedString?.string }\n        set {\n            let style = NSMutableParagraphStyle()\n            style.alignment = self.alignment\n            let attr = NSAttributedString(string: newValue ?? "", attributes: [\n                .foregroundColor: NSColor.secondaryLabelColor,\n                .paragraphStyle: style\n            ])\n            self.textLabel.placeholderAttributedString = attr\n        }\n    }\n    \n    @objc open override var isEnabled: Bool {\n        didSet { /* .. */ }\n    }\n    \n    open override var isHighlighted: Bool {\n        // ...\n    }\n    \n    private lazy var clearButton: NSButton = {\n        let button = NSButton()\n        button.wantsLayer = true\n        button.translatesAutoresizingMaskIntoConstraints = false\n        button.image = NSImage(named: .stopProgressTemplate)\n        button.bezelStyle = .texturedRounded // for template image rendering\n        button.setButtonType(.momentaryChange)\n        button.isBordered = false\n        button.title = ""\n        button.target = self\n        button.action = #selector(self.buttonAction(_:))\n        return button\n    }()\n    \n    private lazy var textLabel: NSTextField = {\n        let label = NSTextField()\n        label.wantsLayer = true\n        label.translatesAutoresizingMaskIntoConstraints = false\n        label.isEditable = false\n        label.isSelectable = false\n        label.isContinuous = false\n        label.isEnabled = true\n        label.textColor = self.tintColor\n        label.backgroundColor = .clear\n        label.refusesFirstResponder = true\n        label.drawsBackground = false\n        label.isBezeled = false\n        label.lineBreakMode = .byClipping\n        label.setValue(true, forKey: "ignoreHitTest")\n        return label\n    }()\n\n    public override init(frame frameRect: NSRect) {\n        super.init(frame: frameRect)\n        self.commonInit()\n    }\n\n    public required init?(coder: NSCoder) {\n        super.init(coder: coder)\n        self.commonInit()\n    }\n    \n    private func commonInit() {\n        self.wantsLayer = true\n        self.layerContentsRedrawPolicy = .onSetNeedsDisplay\n        self.translatesAutoresizingMaskIntoConstraints = false\n        self.addSubview(self.clearButton)\n        self.addSubview(self.textLabel)\n        self.isEnabled = true // NSControl.isEnabled is false by default.\n        self.alignment = .center\n    }\n}\n')),(0,i.kt)("p",null,"This bit of code is pretty basic subview setup, and we're using lazy initialization for our views, but it's not necessary to do so. In addition, we've added or overridden some properties that forward into our ",(0,i.kt)("inlineCode",{parentName:"p"},"subviews")," or to our ",(0,i.kt)("inlineCode",{parentName:"p"},"superclass"),". Remember to always set ",(0,i.kt)("inlineCode",{parentName:"p"},"wantsLayer"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"layerContentsRedrawPolicy")," ",(0,i.kt)("strong",{parentName:"p"},"and definitely never forget ",(0,i.kt)("inlineCode",{parentName:"strong"},"translatesAutoresizingMaskIntoConstraints")," or you will cry.")," Notice that we didn't touch constraints in our ",(0,i.kt)("inlineCode",{parentName:"p"},"commonInit()"),", and I'll explain why soon."),(0,i.kt)("p",null,"Speaking of that, there's a particular side effect of invoking setters in ",(0,i.kt)("inlineCode",{parentName:"p"},"commonInit()")," versus in the initializer itself: it allows us to call the ",(0,i.kt)("inlineCode",{parentName:"p"},"didSet")," on the property! Just be aware of that, and double check that there are no unintended side effects in your ",(0,i.kt)("inlineCode",{parentName:"p"},"didSet"),"s. Note the ",(0,i.kt)("inlineCode",{parentName:"p"},"will/didChangeValue")," in our properties, though - we used ",(0,i.kt)("inlineCode",{parentName:"p"},"#function")," as the key path, but these aren't the magical Swift ",(0,i.kt)("inlineCode",{parentName:"p"},"KeyPath"),"s (like ",(0,i.kt)("inlineCode",{parentName:"p"},"\\.isRecording"),") we got in Swift 4.1! What gives? It actually is because we aren't able to mark our properties as ",(0,i.kt)("inlineCode",{parentName:"p"},"@objc")," because they aren't able to be represented in ObjC. As a workaround, we're able to get the ObjC ",(0,i.kt)("inlineCode",{parentName:"p"},"KeyPath")," stuff working, but it's by no means a good solution. If you have a better solution, let me know!"),(0,i.kt)("p",null,"Take note that we have to wrap the ",(0,i.kt)("inlineCode",{parentName:"p"},"placeholderString")," in an ",(0,i.kt)("inlineCode",{parentName:"p"},"NSAttributedString")," because the default label color is way too dim/translucent and therefore hard to read. This causes an unintended non-updating effect: ",(0,i.kt)("inlineCode",{parentName:"p"},"alignment")," should be set before setting ",(0,i.kt)("inlineCode",{parentName:"p"},"placeholderString"),", because we're not updating the ",(0,i.kt)("inlineCode",{parentName:"p"},"placeholderString"),"'s ",(0,i.kt)("inlineCode",{parentName:"p"},"paragraphStyle"),"'s ",(0,i.kt)("inlineCode",{parentName:"p"},"alignment")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"updateLayer"),", and so ",(0,i.kt)("inlineCode",{parentName:"p"},"placeholderString"),", if set only once, uses the exact value given to it at that time."),(0,i.kt)("p",null,"A few more notes about the subviews:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ignoreHitTest")," is a ",(0,i.kt)("strong",{parentName:"li"},"Private SPI"),"! We need it though, because without this flag, the label steals our firstMouse/responder status. If you would rather ",(0,i.kt)("em",{parentName:"li"},"not")," do this, subclass ",(0,i.kt)("inlineCode",{parentName:"li"},"NSTextField")," and override ",(0,i.kt)("inlineCode",{parentName:"li"},"hitTest:")," to return ",(0,i.kt)("inlineCode",{parentName:"li"},"nil"),". It has the same effect."),(0,i.kt)("li",{parentName:"ul"},"To render template images (that is, ",(0,i.kt)("inlineCode",{parentName:"li"},"NSImage"),"s whose ",(0,i.kt)("inlineCode",{parentName:"li"},"isTemplate")," is ",(0,i.kt)("inlineCode",{parentName:"li"},"true"),", or their name ends with ",(0,i.kt)("inlineCode",{parentName:"li"},"Template"),") in the current ",(0,i.kt)("inlineCode",{parentName:"li"},"NSAppearance"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"NSButton")," has to be a textured style. This adds a little bit of padding around the button, so we'll take that into account when working with constraints.")),(0,i.kt)("p",null,"Since we'll also be using the ",(0,i.kt)("inlineCode",{parentName:"p"},"NSControl")," target/action model, our ",(0,i.kt)("inlineCode",{parentName:"p"},"delegate")," should primarily be for decision-making. If we wanted to focus on notification of control state, it's better to use ",(0,i.kt)("inlineCode",{parentName:"p"},"NSNotificationCenter"),", which some Cocoa text classes do."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-swift"},"public protocol KeyboardShortcutViewDelegate: class {\n    func keyboardShortcutViewShouldBeginRecording(_ keyboardShortcutView: KeyboardShortcutView) -> Bool\n    func keyboardShortcutView(_ keyboardShortcutView: KeyboardShortcutView,\n                              canRecordShortcut shortcut: KeyboardShortcutView.Pair) -> Bool\n    func keyboardShortcutViewDidEndRecording(_ keyboardShortcutView: KeyboardShortcutView)\n}\n")),(0,i.kt)("p",null,"There - now we have a pretty effective API client interface to determine what the control should do in a given situation, along with a visual foundation."),(0,i.kt)("h3",{id:"accepting-key-view"},"Accepting Key View"),(0,i.kt)("p",null,"The important part of a control is to allow the user to activate and deactivate it, which we'll do by just clicking within or outside of the control bounds. It's very easy to allow becoming the key view or first responder:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-swift"},"open override var acceptsFirstResponder: Bool {\n    return self.isEnabled\n}\n\nopen override var canBecomeKeyView: Bool {\n    return super.canBecomeKeyView && NSApp.isFullKeyboardAccessEnabled\n}\n\nopen override var needsPanelToBecomeKey: Bool {\n    return true\n}\n\nopen override func acceptsFirstMouse(for event: NSEvent?) -> Bool {\n    return true\n}\n\nopen override func performClick(_ sender: Any?) {\n    self.window?.makeFirstResponder(self)\n}\n")),(0,i.kt)("p",null,"That's all you need to do! Now, clicking inside the control will give us key input, which we'll focus on in the next section. "),(0,i.kt)("h3",{id:"responding-to-user-input"},"Responding to User Input"),(0,i.kt)("p",null,"This is the meat of the control: actually recording the shortcut. The first thing we should do is get our ",(0,i.kt)("inlineCode",{parentName:"p"},"isEnabled"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"isHighlighted"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"isRecording")," properties correctly wired together. We shouldn't be able to set our highlight state because that's for the user to do; instead, wire its getter through to ",(0,i.kt)("inlineCode",{parentName:"p"},"isRecording"),". The two main properties are ",(0,i.kt)("inlineCode",{parentName:"p"},"shortcut")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"inputModifiers"),", the latter of which we'll use to track which modifier flags are set when the user is entering the shortcut. When setting the ",(0,i.kt)("inlineCode",{parentName:"p"},"shortcut"),", we'll use the ",(0,i.kt)("inlineCode",{parentName:"p"},"NSControl")," target/action mechanism to send our ",(0,i.kt)("inlineCode",{parentName:"p"},"action")," to our ",(0,i.kt)("inlineCode",{parentName:"p"},"target"),". If we don't have a defined ",(0,i.kt)("inlineCode",{parentName:"p"},"target")," (that is, it's ",(0,i.kt)("inlineCode",{parentName:"p"},"nil"),"), the message travels up the responder chain automatically! If the client (instead of the user) sets the ",(0,i.kt)("inlineCode",{parentName:"p"},"shortcut")," directly, it'll still trigger the action, so keep that in mind - the solution to this is to wrap it in an ",(0,i.kt)("inlineCode",{parentName:"p"},"if self.isRecording"),", but in this case, it's the behavior we might want."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-swift"},"@objc open override var isEnabled: Bool {\n    didSet {\n        if !self.isEnabled { self.endRecording() }\n    }\n}\n\nopen override var isHighlighted: Bool {\n    get { return self.isRecording }\n    set { }\n}\n\n@objc open private(set) var isRecording = false {\n    willSet { self.willChangeValue(forKey: #function) }\n    didSet { self.didChangeValue(forKey: #function) }\n}\n/*@objc*/ open var shortcut: KeyboardShortcutView.Pair? {\n    willSet {\n        guard self.shortcut?.keyCode != newValue?.keyCode &&\n            self.shortcut?.modifierFlags != newValue?.modifierFlags else { return }\n        self.willChangeValue(forKey: #function)\n    }\n    didSet {\n        guard self.shortcut?.keyCode != oldValue?.keyCode &&\n            self.shortcut?.modifierFlags != oldValue?.modifierFlags else { return }\n        \n        _ = self.sendAction(self.action, to: self.target)\n        \n        // ...\n        self.didChangeValue(forKey: #function)\n    }\n}\n\nprivate var inputModifiers: NSEvent.ModifierFlags = [] {\n    didSet {\n        // ...\n    }\n}\n")),(0,i.kt)("p",null,"Now we'll have to actually handle mouse activation and keyboard events:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-swift"},"open override func mouseDown(with event: NSEvent) {\n    guard self.isEnabled else {\n        super.mouseDown(with: event); return\n    }\n\n    let locationInView = self.convert(event.locationInWindow, from: nil)\n    if self.mouse(locationInView, in: self.bounds) && !self.isRecording {\n        self.inputModifiers = []\n        _ = self.beginRecording()\n    } else {\n        super.mouseDown(with: event)\n    }\n}\n")),(0,i.kt)("p",null,"If we're enabled, and the mouse press was within our bounds, reset our recording state and begin recording. Next, if our ",(0,i.kt)("inlineCode",{parentName:"p"},"flagsChanged(with:)")," is called, change our input modifiers state (and we'll cover soon how that reflects in the UI). The easy thing about writing a shortcut recorder is that we can use ",(0,i.kt)("inlineCode",{parentName:"p"},"performKeyEquivalent(with:)"),'! It\'s called when a "key equivalent" ',(0,i.kt)("em",{parentName:"p"},'(read: "keyboard shortcut")')," is pressed and we're first responder. This basically has already taken care of all the work for us, and we just need to validate the new shortcut with the delegate and end recording."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-swift"},"open override func performKeyEquivalent(with event: NSEvent) -> Bool {\n    if !self.isEnabled || !self.isRecording { return false }\n    if self.window?.firstResponder != self { return false }\n    let shortcut = (keyCode: CGKeyCode(event.keyCode),\n                    modifierFlags: CGEventFlags(event.modifierFlags))\n    \n    // inline validation func if we have no delegate response:\n    func validate() -> Bool {\n        guard !shortcut.keyCode.isFunctionKey else { return true }\n        return !shortcut.modifierFlags.intersection(.maskUserFlags).isEmpty\n    }\n    \n    let del = (self.delegate ?? self.target as? KeyboardShortcutViewDelegate)\n    if del?.keyboardShortcutView(self, canRecordShortcut: shortcut) ?? validate() {\n        self.shortcut = shortcut\n        self.endRecording()\n        return true\n    }\n    return false\n}\n\nopen override func flagsChanged(with event: NSEvent) {\n    self.inputModifiers = self.isRecording ? event.modifierFlags : []\n    super.flagsChanged(with: event)\n}\n")),(0,i.kt)("p",null,"If we don't have a ",(0,i.kt)("inlineCode",{parentName:"p"},"delegate"),", we'll check if our ",(0,i.kt)("inlineCode",{parentName:"p"},"target")," is ",(0,i.kt)("em",{parentName:"p"},"also")," capable of being our ",(0,i.kt)("inlineCode",{parentName:"p"},"delegate")," -- this is mostly convenience, kinda like how you have a ",(0,i.kt)("inlineCode",{parentName:"p"},"delegate")," and a ",(0,i.kt)("inlineCode",{parentName:"p"},"dataSource")," for a collection or table view, but usually it's one view controller implementing both. If neither the ",(0,i.kt)("inlineCode",{parentName:"p"},"delegate")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"target")," can help us validate the input, we'll just allow it to go through as long as it's not a single non-Fn key (that is, you shouldn't allow just ",(0,i.kt)("inlineCode",{parentName:"p"},"Q")," as a hot key: that would lead to a lot of problems!)."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-swift"},"open override func keyDown(with event: NSEvent) {\n    guard !self.performKeyEquivalent(with: event) else { return }\n    super.keyDown(with: event)\n}\n\nopen override func resignFirstResponder() -> Bool {\n    self.endRecording()\n    return true\n}\n")),(0,i.kt)("p",null,"And with that, we've completed handling our event handling: if we get a stray ",(0,i.kt)("inlineCode",{parentName:"p"},"keyDown(with:)")," message, just invoke ",(0,i.kt)("inlineCode",{parentName:"p"},"performKeyEquivalent(with:)"),", as this can occur in the case described before, where a single non-Fn key is pressed. Again, ",(0,i.kt)("strong",{parentName:"p"},"allowing this is bad practice and interferes with system keyboard input!")," But who are we to judge, right? "),(0,i.kt)("p",null,"The recording actions take place primarily in ",(0,i.kt)("inlineCode",{parentName:"p"},"beginRecording()")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"endRecording()"),"; we could have just placed the body of these methods in ",(0,i.kt)("inlineCode",{parentName:"p"},"isRecording.didSet")," but that would be very very bloated and inappropriate code style. Be sure to handle state correctly and guard against out-of-place calls to these methods, as that can lead to unexpected user-visible state leakage. "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-swift"},"public func beginRecording() -> Bool {\n    if !self.isEnabled { return false }\n    if self.isRecording { return true }\n    \n    let del = (self.delegate ?? self.target as? KeyboardShortcutViewDelegate)\n    guard del?.keyboardShortcutViewShouldBeginRecording(self) ?? true else {\n        NSSound.beep(); return false\n    }\n    self.isRecording = true\n    return true\n}\n\npublic func endRecording() {\n    if !self.isRecording { return }\n    self.inputModifiers = []\n    self.isRecording = false\n    \n    if self.window?.firstResponder == self && !self.canBecomeKeyView {\n        self.window?.makeFirstResponder(nil)\n    }\n    let del = (self.delegate ?? self.target as? KeyboardShortcutViewDelegate)\n    del?.keyboardShortcutViewDidEndRecording(self)\n}\n")),(0,i.kt)("p",null,"It's pretty self-explanatory, as all we do is consult (or notify) the ",(0,i.kt)("inlineCode",{parentName:"p"},"delegate"),"/",(0,i.kt)("inlineCode",{parentName:"p"},"target"),", and fallback to the assumption that we are allowed to record, if none are available. When we ",(0,i.kt)("inlineCode",{parentName:"p"},"resignFirstResponder()")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"endRecording()"),", we end up calling the opposite method, but these calls aren't re-entrant as ",(0,i.kt)("inlineCode",{parentName:"p"},"NSWindow.makeFirstResponder(_:)")," does the verification for us. Finally, we just need to wire up the ",(0,i.kt)("inlineCode",{parentName:"p"},"clearButton")," action to perform the context-specific thing: if we're not recording but we don't have a set ",(0,i.kt)("inlineCode",{parentName:"p"},"shortcut"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"beginRecording()"),"; if we ",(0,i.kt)("strong",{parentName:"p"},"do")," have a set ",(0,i.kt)("inlineCode",{parentName:"p"},"shortcut"),", clear it and end recording. Otherwise, we're already recording - ",(0,i.kt)("inlineCode",{parentName:"p"},"endRecording()")," without losing the previously set ",(0,i.kt)("inlineCode",{parentName:"p"},"shortcut"),", if any."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-swift"},"@objc private func buttonAction(_ button: NSButton) {\n    if !self.isRecording && self.shortcut == nil { // cleared state\n        self.window?.makeFirstResponder(self)\n        _ = self.beginRecording()\n    } else if self.isRecording && self.shortcut != nil { // cleared state\n        self.endRecording()\n    } else {\n        if self.shortcut != nil { self.shortcut = nil }\n        self.endRecording()\n    }\n}\n")),(0,i.kt)("h3",{id:"updatelayer"},(0,i.kt)("inlineCode",{parentName:"h3"},"updateLayer")),(0,i.kt)("p",null,"Let's take a brief moment to provide a convenience function for visually representing the whole shortcut to the user: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-swift"},'private var stringRepresentation: String {\n    var modifiers: NSEvent.ModifierFlags = self.inputModifiers\n    if self.isRecording {\n        return modifiers.characters\n    } else {\n        if let shortcut = self.shortcut {\n            modifiers.formUnion(NSEvent.ModifierFlags(shortcut.modifierFlags))\n        }\n        return modifiers.characters + (self.shortcut?.keyCode.characters ?? "")\n    }\n}\n')),(0,i.kt)("p",null,"It's not too much: if we're recording, return the input modifers as a string, but if we're not, use the ",(0,i.kt)("inlineCode",{parentName:"p"},"shortcut"),"'s ",(0,i.kt)("inlineCode",{parentName:"p"},"modifier.characters")," ",(0,i.kt)("strong",{parentName:"p"},"and")," the input modifier's, together, along with the ",(0,i.kt)("inlineCode",{parentName:"p"},"keyCode")," as a string at the very end. This will match the canonical string representation seen in ",(0,i.kt)("inlineCode",{parentName:"p"},"NSMenuItem"),"s. Since we're explicitly layer-backed and requesting ",(0,i.kt)("inlineCode",{parentName:"p"},"updateLayer"),", we should definitely control our visual appearance here:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-swift"},'open override var allowsVibrancy: Bool {\n    return false\n}\n\nopen override var wantsUpdateLayer: Bool {\n    return true\n}\n\nopen override func updateLayer() {\n    // ...\n\n    self.textLabel.textColor = self.isEnabled ? self.tintColor : .disabledControlTextColor\n    \n    let str = self.stringRepresentation\n    self.textLabel.stringValue = str\n    self.toolTip = Localized.tooltipPrefix + ": " + (str.isEmpty ? Localized.noShortcut : str)\n                    + "\\n\\n" + Localized.help\n    \n    self.clearButton.isEnabled = self.isEnabled\n    let canStop = self.isRecording || self.shortcut != nil\n    self.clearButton.image = NSImage(named: canStop ? .stopProgressFreestandingTemplate\n                                                    : .statusUnavailable)\n}\n')),(0,i.kt)("p",null,"You'll notice we set the ",(0,i.kt)("inlineCode",{parentName:"p"},"tooltip")," here as well. It's important to do so per-view, or if we're drawing specific regions with different tooltips, we can use ",(0,i.kt)("inlineCode",{parentName:"p"},"addToolTipRect...")," and friends; these are hover-based context clues as to what the view under the mouse provides, and there's no iOS equivalent. For now, ignore the ",(0,i.kt)("inlineCode",{parentName:"p"},"Localized...")," values, as we'll talk about that later."),(0,i.kt)("p",null,"Add a ",(0,i.kt)("inlineCode",{parentName:"p"},"self.needsDisplay = true")," call to the ",(0,i.kt)("inlineCode",{parentName:"p"},"didSet")," of the properties: ",(0,i.kt)("inlineCode",{parentName:"p"},"tintColor"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"shortcut"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"isEnabled"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"inputModifers"),". This will mark the view as needing ",(0,i.kt)("inlineCode",{parentName:"p"},"updateLayer()")," called, which we can then update visual appearances in."),(0,i.kt)("h3",{id:"drawing-a-button-without-being-one"},"Drawing a Button Without Being One"),(0,i.kt)("p",null,"An important thing to do in designing and implementing a new control is to ",(0,i.kt)("strong",{parentName:"p"},"always look and feel like a system control!")," It's very obvious to a user when an app doesn't do this and it provides the perception of a cheap or poorly designed app, leading to possible user dissatisfaction. For this control, let's act like a mix between a button and text input, because we act like a mix between the two. A good example of a control that already has this appearance is an ",(0,i.kt)("inlineCode",{parentName:"p"},"NSSearchField")," in an ",(0,i.kt)("inlineCode",{parentName:"p"},"NSToolbar")," (in a regular ",(0,i.kt)("inlineCode",{parentName:"p"},"NSView"),", it looks recessed, but in the toolbar it has a button-like appearance). Instead, however, we'll steal the appearance of an ",(0,i.kt)("inlineCode",{parentName:"p"},"NSButton")," directly using an ",(0,i.kt)("inlineCode",{parentName:"p"},"NSButtonCell"),". Like I said much earlier in the article, ",(0,i.kt)("inlineCode",{parentName:"p"},"NSCell"),"s encapsulate both event-handling ",(0,i.kt)("em",{parentName:"p"},"and")," visual appearance, without being an actual view! We can quite simply share a button cell between all instances of our control and draw it into a sublayer in ",(0,i.kt)("inlineCode",{parentName:"p"},"updateLayer()"),", using the ",(0,i.kt)("inlineCode",{parentName:"p"},"drawBezel(withFrame:in:)")," method. Be sure to add the sublayer to our hierarchy and set the correct ",(0,i.kt)("inlineCode",{parentName:"p"},"bezelStyle"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-swift"},"private static var stampCell: NSButtonCell = {\n    let c = NSButtonCell()\n    c.bezelStyle = .texturedRounded\n    return c\n}()\n\nprivate lazy var underlayer = CALayer()\n\nprivate func commonInit() {\n    // ...\n    self.layer?.addSublayer(self.underlayer)\n    // ...\n}\n\nopen override func updateLayer() {\n    var b = self.bounds.size; b.height = 22\n    let img = NSImage(size: b, flipped: false) { r in\n        KeyboardShortcutView.stampCell.drawBezel(withFrame: r, in: self)\n        return true\n    }\n    \n    CATransaction.begin()\n    CATransaction.setDisableActions(true)\n    self.underlayer.contents = img\n    self.underlayer.contentsScale = self.layer!.contentsScale // inherit\n    self.underlayer.contentsCenter = CGRect(x: 0.25, y: 0.25, width: 0.5, height: 0.5)\n    CATransaction.commit()\n\n    // ...\n}\n\nopen override func layout() {\n    super.layout()\n\n    CATransaction.begin()\n    CATransaction.setDisableActions(true)\n    self.underlayer.frame = self.layer!.bounds\n    CATransaction.commit()\n\n    // ...\n}\n")),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},(0,i.kt)("inlineCode",{parentName:"em"},"-[NSButtonCell updateLayerWithFrame:inView:]")," actually uses a private ",(0,i.kt)("inlineCode",{parentName:"em"},"NSLayerContentsFacet")," and CoreUI to optimize drawing ",(0,i.kt)("inlineCode",{parentName:"em"},"CALayer")," contents, but it's a non-issue for us.")),(0,i.kt)("p",null,"If we could use ",(0,i.kt)("inlineCode",{parentName:"p"},"drawRect:")," it might be more straight forward, but we lose the ability to set the ",(0,i.kt)("inlineCode",{parentName:"p"},"CALayer.contentsCenter")," which automatically does 9-part image slicing for us, if the ",(0,i.kt)("inlineCode",{parentName:"p"},"underlayer")," frame and the ",(0,i.kt)("inlineCode",{parentName:"p"},"content")," size don't match up. You might notice that if you just set ",(0,i.kt)("inlineCode",{parentName:"p"},"layer.frame"),", it'll animate and look weird as it snaps into a new frame, where we don't expect this to occur. To fix this, we just open an explicit sub-transaction, which disables ",(0,i.kt)("inlineCode",{parentName:"p"},"CALayer")," actions. Another possible approach to avoid ",(0,i.kt)("inlineCode",{parentName:"p"},"frame")," implicit animations is to modify the layer's ",(0,i.kt)("inlineCode",{parentName:"p"},"actions")," dictionary:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-swift"},'var implicits = layer.actions\nimplicits["position"] = NSNull()\nimplicits["bounds"] = NSNull()\nlayer.actions = implicits\n')),(0,i.kt)("p",null,"Another small visual issue is that the ",(0,i.kt)("inlineCode",{parentName:"p"},"NSCell")," we're drawing has no understanding of the control's ",(0,i.kt)("inlineCode",{parentName:"p"},"effectiveAppearance"),", unless we tell it using ",(0,i.kt)("inlineCode",{parentName:"p"},"NSAppearance.current"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-swift"},"open override func updateLayer() {\n    // ...\n    let img = NSImage(size: b, flipped: false) { r in\n        self.effectiveAppearance.using {\n            KeyboardShortcutView.stampCell.drawBezel(withFrame: r, in: self)\n        }\n        return true\n    }\n    // ...\n}\n\n// ...\n\npublic extension NSAppearance {\n    public func using(_ handler: () -> ()) {\n        let x = NSAppearance.current\n        NSAppearance.current = self\n        handler()\n        NSAppearance.current = x\n    }\n}\n")),(0,i.kt)("p",null,"Now, if you set the whole ",(0,i.kt)("inlineCode",{parentName:"p"},"window"),"'s ",(0,i.kt)("inlineCode",{parentName:"p"},"appearance")," to, say, ",(0,i.kt)("inlineCode",{parentName:"p"},"vibrantDark"),", the control will render perfectly no matter what size, in that appearance! (It's a little baffling to me that ",(0,i.kt)("inlineCode",{parentName:"p"},"NSButton"),"s don't stretch their drawing, but oh well.)"),(0,i.kt)("h3",{id:"focus-rings"},"Focus Rings"),(0,i.kt)("p",null,"Now, as a control that can become key and first responder in its ",(0,i.kt)("inlineCode",{parentName:"p"},"window"),", we should inform the user that we have done so using a focus ring. After macOS Lion, we no longer need to draw them ourselves, but instead provide their bounds and a mask to match our view's shape. Let's just ask our layer to render itself ",(0,i.kt)("em",{parentName:"p"},"as")," a mask, since only the alpha channel is used for masking!"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-swift"},"open override var focusRingMaskBounds: NSRect {\n    return (self.isEnabled && self.window?.firstResponder == self) ? self.bounds : .zero\n}\n\nopen override func drawFocusRingMask() {\n    guard self.isEnabled && window?.firstResponder == self else { return }\n    self.underlayer.render(in: NSGraphicsContext.current!.cgContext)\n}\n")),(0,i.kt)("p",null,"Now we just need to add a ",(0,i.kt)("inlineCode",{parentName:"p"},"self.noteFocusRingMaskChanged()")," call to ",(0,i.kt)("inlineCode",{parentName:"p"},"isEnabled.didSet"),", so we can show and hide the focus ring automatically. ",(0,i.kt)("inlineCode",{parentName:"p"},"CALayer.render(in:)")," isn't a great idea in most cases because it actually uses the ",(0,i.kt)("inlineCode",{parentName:"p"},"CG")," rendering path, instead of the ",(0,i.kt)("inlineCode",{parentName:"p"},"OGL")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"Metal")," rendering paths that Core Animation can use to accelerate layers on the GPU, and so it's actually a visual approximation to what the layer actually looks like. This doesn't really bother us because we only need the shape to be correct, though, but it's something to keep in mind in general when designing a view with sublayers."),(0,i.kt)("h3",{id:"layout-updateconstraints--intrinsiccontentsize"},(0,i.kt)("inlineCode",{parentName:"h3"},"layout"),", ",(0,i.kt)("inlineCode",{parentName:"h3"},"updateConstraints"),", & ",(0,i.kt)("inlineCode",{parentName:"h3"},"intrinsicContentSize")),(0,i.kt)("p",null,"Because we have sublayers and subviews, we should adjust their layout here. We've already taken care of ",(0,i.kt)("inlineCode",{parentName:"p"},"underlayer"),", so now let's dynamically resize our ",(0,i.kt)("inlineCode",{parentName:"p"},"font")," to match our control's height. It's surprisingly not straightforward, because the facility to do so is found on ",(0,i.kt)("inlineCode",{parentName:"p"},"NSFontManager")," and not ",(0,i.kt)("inlineCode",{parentName:"p"},"NSFont"),", but using the facility is pretty easy."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-swift"},"open override func layout() {\n    // ...\n    \n    if let font = self.font {\n        self.textLabel.font = NSFontManager.shared.convert(font, toSize: self.bounds.height / 1.7)\n    } else {\n        self.textLabel.font = NSFont.systemFont(ofSize: self.bounds.height / 1.7)\n    }\n}\n")),(0,i.kt)("p",null,"Here's where we finally set up and handle constraints! We'll use constraints to handle our subviews, because our sublayer just needs to match our frame. We could, however, add an ",(0,i.kt)("inlineCode",{parentName:"p"},"NSLayoutGuide")," to our control, set up constraints on that guide, and then synchronize its frame to the sublayer frame, but it's not worth the trouble."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-swift"},"open override class var requiresConstraintBasedLayout: Bool {\n    return true\n}\n\nprivate var childConstraints: [NSLayoutConstraint] = []\n\nopen override func updateConstraints() {\n    if self.childConstraints.count == 0 {\n        self.childConstraints = [\n            self.textLabel.leadingAnchor.constraint(equalTo: self.leadingAnchor, constant: 4.0),\n            self.textLabel.trailingAnchor.constraint(equalTo: self.clearButton.leadingAnchor, constant: 0.0),\n            self.clearButton.trailingAnchor.constraint(equalTo: self.trailingAnchor, constant: 0.0),\n            self.clearButton.heightAnchor.constraint(equalTo: self.heightAnchor, multiplier: 1.0),\n            self.clearButton.widthAnchor.constraint(equalTo: self.clearButton.heightAnchor, multiplier: 1.0),\n            self.textLabel.centerYAnchor.constraint(equalTo: self.centerYAnchor, constant: -1.0),\n            self.clearButton.centerYAnchor.constraint(equalTo: self.centerYAnchor),\n        ]\n        NSLayoutConstraint.activate(self.childConstraints)\n    }\n    super.updateConstraints()\n}\n")),(0,i.kt)("p",null,"The gist of it is, ",(0,i.kt)("inlineCode",{parentName:"p"},"updateConstraints()")," is called post-initialization, and whenever we set ",(0,i.kt)("inlineCode",{parentName:"p"},"self.needsUpdateConstraints = true"),", and if we haven't configured any constraints, we'll cache our constraints and activate them. It's helpful to do so in this method because we may, in the future, want to dynamically adjust our constraints, and we can do that in order with the layout and display cycle here."),(0,i.kt)("p",null,"The last thing we should do as a good citizen control, is provide an ",(0,i.kt)("inlineCode",{parentName:"p"},"intrinsicContentSize"),": this is the size that our control will take up if we don't add any size constraints to it. Usually, it's just the smallest bounding box of the control's contents, which we can sum the ",(0,i.kt)("inlineCode",{parentName:"p"},"intrinsicContentSize"),"s of our ",(0,i.kt)("inlineCode",{parentName:"p"},"textLabel")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"clearButton")," to find. Since there's a chance that they might provide a ",(0,i.kt)("inlineCode",{parentName:"p"},".noIntrinsicMetric"),", and our control ",(0,i.kt)("em",{parentName:"p"},"does")," have intrinsic metrics for width (both ",(0,i.kt)("inlineCode",{parentName:"p"},"textLabel")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"clearButton")," do, in fact), we should be cautious of that case. We'll factor in our padding from the constraints above as well."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-swift"},"open override var intrinsicContentSize: NSSize {\n    var _t = self.textLabel.intrinsicContentSize\n    var _b = self.clearButton.intrinsicContentSize\n    if _t.width == NSView.noIntrinsicMetric { _t.width = 0.0 }\n    if _b.width == NSView.noIntrinsicMetric { _b.width = 0.0 }\n    \n    // Compute the sum/max of the intrinsicContentSizes of our subviews.\n    return NSSize(width: _t.width + _b.width + 12.0 /* padding */,\n                  height: max(_t.height, _b.height) /* 22.0? */)\n}\n")),(0,i.kt)("p",null,"We could also take the approach that ",(0,i.kt)("inlineCode",{parentName:"p"},"NSButton")," and similar controls take, which is to clamp the intrinsic size to ",(0,i.kt)("inlineCode",{parentName:"p"},"22px")," in height. For a platform with a cursor, ",(0,i.kt)("inlineCode",{parentName:"p"},"22px"),' is the "right height" for a clickable control that contains a label, and for a platform that relies on touch input, it\'s between ',(0,i.kt)("inlineCode",{parentName:"p"},"32px")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"44px"),". ",(0,i.kt)("em",{parentName:"p"},"(That's from the Apple HIG somewhere.)")),(0,i.kt)("h3",{id:"hover--cursors"},"Hover & Cursors"),(0,i.kt)("p",null,"To support any kind of cursor change or mouse hovering, we need to use ",(0,i.kt)("inlineCode",{parentName:"p"},"NSTrackingArea")," and the related methods on ",(0,i.kt)("inlineCode",{parentName:"p"},"NSView")," used to add and remove them. It's not recommended to use any of the methods with the phrase ",(0,i.kt)("inlineCode",{parentName:"p"},"TrackingRect")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"CursorRect")," in them - they've been superseded since Leopard by ",(0,i.kt)("inlineCode",{parentName:"p"},"NSTrackingArea"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-swift"},"private func commonInit() {\n    // ...\n    self.addTrackingArea(NSTrackingArea(rect: .zero,\n                                        options: [.activeInKeyWindow, .inVisibleRect, .cursorUpdate],\n                                        owner: self, userInfo: nil))\n}\n\nopen override func cursorUpdate(with event: NSEvent) {\n    NSCursor.pointingHand.set()\n}\n")),(0,i.kt)("p",null,"We don't even have to implement ",(0,i.kt)("inlineCode",{parentName:"p"},"updateTrackingAreas()")," to handle changing frames or anything. The ",(0,i.kt)("inlineCode",{parentName:"p"},"NSTrackingArea")," makes sure that ",(0,i.kt)("inlineCode",{parentName:"p"},"cursorUpdate(with:)")," is only called with the visible frame of the view, when the window containing the view is key. It's dead simple; if we wanted to support mouse hovering, to perhaps display suggestions or change our drawing in some way, we would just change ",(0,i.kt)("inlineCode",{parentName:"p"},".cursorUpdate")," to ",(0,i.kt)("inlineCode",{parentName:"p"},".mouseEnteredAndExited")," or ",(0,i.kt)("inlineCode",{parentName:"p"},".mouseMoved"),". Maybe we just want to change our drawing or cursor when we're the first responder? Just change ",(0,i.kt)("inlineCode",{parentName:"p"},".activeInKeyWindow")," to ",(0,i.kt)("inlineCode",{parentName:"p"},".activeWhenFirstResponder")," -- be mindful that the ",(0,i.kt)("inlineCode",{parentName:"p"},"options")," are three individual option sets masked together. You can't use ",(0,i.kt)("inlineCode",{parentName:"p"},".activeInKeyWindow")," and ",(0,i.kt)("inlineCode",{parentName:"p"},".activeWhenFirstResponder")," simultaneously for example."),(0,i.kt)("h3",{id:"haptic--audio-feedback"},"Haptic & Audio Feedback"),(0,i.kt)("p",null,"Some controls may want to add audio feedback support, like ",(0,i.kt)("inlineCode",{parentName:"p"},"NSButton.sound"),", but in my opinion, this makes assumptions on the availability and implementation of the audo feedback (what if the client wishes to use ",(0,i.kt)("inlineCode",{parentName:"p"},"AVAudioPlayer"),"?); instead, it's probably a better idea to play the sound in our delegate or target/action methods. If we did want to support audio feedback with ",(0,i.kt)("inlineCode",{parentName:"p"},"NSSound"),", however, it's quite simple:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-swift"},"@objc open var sound: NSSound? = nil\n\n// ...\n\nopen func doSomething() {\n    // ...\n    self.sound?.play()\n}\n")),(0,i.kt)("p",null,"Likewise, some controls may want to add haptic feedback, but those controls ",(0,i.kt)("em",{parentName:"p"},"(should)")," primarily rely on ",(0,i.kt)("em",{parentName:"p"},"(specifically)")," force touch interaction, like dragging or deep pressing, and our shortcut recording control relies primarily on keyboard input. If we were to, adding simple haptic responses is just as simple, albeit a little more wordy:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-swift"},"@objc open var hapticPerformer: NSHapticFeedbackPerformer? = NSHapticFeedbackManager.defaultPerformer\n\n// ...\n\nopen func doSomething() {\n    // ...\n    self.hapticPerformer?.perform(.levelChange, performanceTime: .drawCompleted)\n}\n")),(0,i.kt)("p",null,"In this specific case, while currently on macOS, there is only a ",(0,i.kt)("inlineCode",{parentName:"p"},"defaultPerformer"),", we can expect that there may be more in the future, perhaps one for the touch bar, as an example. In anticipating such changes, it might be a good idea to allow our client to set the desired ",(0,i.kt)("inlineCode",{parentName:"p"},"hapticPerformer")," - if it's set to ",(0,i.kt)("inlineCode",{parentName:"p"},"nil"),", it acts as if we've disabled haptic feedback."),(0,i.kt)("h3",{id:"window-keyedness"},"Window Keyedness"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"NSWindow State",src:n(9596).Z,width:"608",height:"417"})),(0,i.kt)("p",null,'An important concept on macOS is that of window "keyedness" and "main-ness", as you can see above. Controls are expected to draw accordingly to visually explain to the user if they\'re able to be interacted with or not. We can monitor our parent ',(0,i.kt)("inlineCode",{parentName:"p"},"window"),"'s state without any strong reference to the ",(0,i.kt)("inlineCode",{parentName:"p"},"window")," by using the ",(0,i.kt)("inlineCode",{parentName:"p"},"viewWillMove(toWindow:)")," method, and then trampoline that using ",(0,i.kt)("inlineCode",{parentName:"p"},"NSNotificationCenter"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-swift"},"@objc private func windowKeyednessChanged(_ note: Notification) {\n    guard let window = self.window, (note.object as? NSWindow) == window else { return }\n    // do nothing for now\n}\n\nopen override func viewWillMove(toWindow newWindow: NSWindow?) {\n    let n = NotificationCenter.default // shorthand\n    if let oldWindow = self.window {\n        n.removeObserver(self, name: NSWindow.didBecomeKeyNotification,\n                         object: oldWindow)\n        n.removeObserver(self, name: NSWindow.didResignKeyNotification,\n                         object: oldWindow)\n    }\n    if let newWindow = newWindow {\n        n.addObserver(self, selector: #selector(self.windowKeyednessChanged(_:)),\n                      name: NSWindow.didBecomeKeyNotification, object: newWindow)\n        n.addObserver(self, selector: #selector(self.windowKeyednessChanged(_:)),\n                      name: NSWindow.didResignKeyNotification, object: newWindow)\n    }\n}\n\ndeinit {\n    NotificationCenter.default.removeObserver(self) // just in case\n}\n")),(0,i.kt)("p",null,"Now, we'll get the ",(0,i.kt)("inlineCode",{parentName:"p"},"windowKeyednessChanged(_:)")," notifications whenever keyedness changes (and note that we could do the same for main-ness as well) without worrying about which window we're contained within. The next thing to do is wire our first responder state into the method, which sounds inappropriate, but since we use the method ",(0,i.kt)("em",{parentName:"p"},"just")," for handling drawing and event state, it's okay to do so without getting pedantic about it."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-swift"},"open override func becomeFirstResponder() -> Bool {\n    DispatchQueue.main.async {\n        self.windowKeyednessChanged(Notification(name: NSWindow.didBecomeKeyNotification,\n                                                 object: self.window, userInfo: nil))\n    }\n    return true\n}\n\nopen override func resignFirstResponder() -> Bool {\n    DispatchQueue.main.async {\n        self.windowKeyednessChanged(Notification(name: NSWindow.didResignKeyNotification,\n                                                 object: self.window, userInfo: nil))\n    }\n    // ...\n    return true\n}\n")),(0,i.kt)("p",null,"We need to enqueue the ",(0,i.kt)("inlineCode",{parentName:"p"},"windowKeyednessChanged")," invocation to the main queue because we haven't yet become the first responder until the ",(0,i.kt)("inlineCode",{parentName:"p"},"become/resignFirstResponder")," method returns."),(0,i.kt)("h3",{id:"global-hotkey-interference"},"Global HotKey Interference"),(0,i.kt)("p",null,"At this point we have a fully functional keyboard shortcut recorder! However... attempting to record certain shortcuts, you'll find, don't work, mysteriously. After a few different shortcuts you've tried to record, it hits you: these are symbolic shortcuts that we've set in the System Preferences! We're accidentally triggering them instead of recording the shortcut! Surely, you wonder, how does System Preferences allow you to record shortcuts without triggering symbolic ones willy-nilly? The answer lies in a den of dragons:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-swift"},'// Here lie dragons!\nfileprivate typealias CGSConnectionID = UInt\nfileprivate enum CGSGlobalHotKeyOperatingMode: UInt {\n    case enable = 0, disable = 1, universalAccessOnly = 2\n}\n@_silgen_name("CGSMainConnectionID")\nfileprivate func CGSMainConnectionID() -> CGSConnectionID\n@_silgen_name("CGSGetGlobalHotKeyOperatingMode")\nfileprivate func CGSGetGlobalHotKeyOperatingMode(_ connection: CGSConnectionID,\n                                                 _ mode: UnsafeMutablePointer<CGSGlobalHotKeyOperatingMode?>) -> CGError\n@_silgen_name("CGSSetGlobalHotKeyOperatingMode")\nfileprivate func CGSSetGlobalHotKeyOperatingMode(_ connection: CGSConnectionID,\n                                                 _ mode: CGSGlobalHotKeyOperatingMode) -> CGError\n')),(0,i.kt)("p",null,"The answer to recording hotkeys that have been reserved already... is to turn off hotkeys globally while you're first responder. I swear up and down this is exactly what System Preferences does - take a look yourself if you don't believe me! It's pretty simple to cache the existing global state, turn the hotkeys off, and then once we're resigning first responder, reset the global state. Here's what that looks like:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-swift"},"private var savedOperatingMode: CGSGlobalHotKeyOperatingMode? = nil\n    \ndeinit {\n    if self.savedOperatingMode != nil {\n        _ = CGSSetGlobalHotKeyOperatingMode(CGSMainConnectionID(), self.savedOperatingMode!)\n    }\n    // ...\n}\n\n@objc private func windowKeyednessChanged(_ note: Notification) {\n    // ...\n    if window.isKeyWindow && window.firstResponder == self { // becomeKey\n        guard self.savedOperatingMode == nil else { return }\n        \n        _ = CGSGetGlobalHotKeyOperatingMode(CGSMainConnectionID(), &self.savedOperatingMode)\n        _ = CGSSetGlobalHotKeyOperatingMode(CGSMainConnectionID(), .disable)\n    } else { // resignKey\n        guard self.savedOperatingMode != nil else { return }\n\n        _ = CGSSetGlobalHotKeyOperatingMode(CGSMainConnectionID(), self.savedOperatingMode!)\n        self.savedOperatingMode = nil\n        window.makeFirstResponder(nil) // resign ourselves if window resigned\n    }\n}\n")),(0,i.kt)("p",null,"A disclaimer: ",(0,i.kt)("em",{parentName:"p"},"you don't need to include this to roll a fully functional shortcut recorder.")," You ",(0,i.kt)("strong",{parentName:"p"},"can")," ignore the fact that the user will be trying to record shortcuts and then be disappointed that it's not working. You ",(0,i.kt)("strong",{parentName:"p"},"can!")," let your user down! And you ",(0,i.kt)("strong",{parentName:"p"},"will")," if you're submitting your app to the MAS, so keep this in mind. We're not to use this facility for evil, but to respond to exactly what the user is doing. The unfortunate downside is that the symbolic/other hot keys will be triggered when the user double-dips with our app, unless we claim the shortcut exclusively (see, there ",(0,i.kt)("em",{parentName:"p"},"was")," a reason for that!)."),(0,i.kt)("h3",{id:"string-localization"},"String Localization"),(0,i.kt)("p",null,"Alright, we're done now right? No one using this control lives outside America (and even those that live within, they definitely speak English fluently, right?) and none of ",(0,i.kt)("em",{parentName:"p"},"our users")," are disabled right? ",(0,i.kt)("strong",{parentName:"p"},"Wrong.")," Always consider that you, as the developer, are not the target audience of your tool (be it a control, or an app), and always focus on ",(0,i.kt)("strong",{parentName:"p"},"i18n")," and ",(0,i.kt)("strong",{parentName:"p"},"accessibility"),", because like it or not, it's not beneficence, it's a responsibility."),(0,i.kt)("p",null,"Luckily, localization support is pretty easy, except for the hard part (which is the localization itself). I've opted to wrap it into a ",(0,i.kt)("inlineCode",{parentName:"p"},"Localized")," container with a helper function ",(0,i.kt)("inlineCode",{parentName:"p"},"value(_:default:comment:)")," that looks up the string from the bundle that contains the class. This is important, because your control may or may not be in the ",(0,i.kt)("inlineCode",{parentName:"p"},"main")," bundle. To use it, just create static properties like ",(0,i.kt)("inlineCode",{parentName:"p"},"Localized.voiceOverBegin")," below:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-swift"},'private enum Localized {\n    private static func value(_ key: String, `default`: String, comment: String) -> String {\n        return NSLocalizedString(key, tableName: nil, bundle: Bundle(for: KeyboardShortcutView.self),\n                                 value: `default`, comment: comment) // helper!\n    }\n\n    // ...\n    \n    fileprivate static var actionName: String {\n        return value("action_name", default: "Record Shortcut",\n                     comment: "The action name for undo and redo")\n    }\n    \n    fileprivate static var voiceOverBegin: String {\n        return value("voiceover_begin", default: "Now recording a shortcut",\n                     comment: "The notification name for VoiceOver if the control began recording")\n    }\n\n    // ...\n}\n')),(0,i.kt)("p",null,"Always provide helpful comments for your translators, and provide a ",(0,i.kt)("inlineCode",{parentName:"p"},"default")," in your expected target language in case you haven't loaded a good ",(0,i.kt)("inlineCode",{parentName:"p"},"strings")," file, or you just plain don't have one in the current bundle."),(0,i.kt)("h3",{id:"accessibility"},"Accessibility"),(0,i.kt)("p",null,"I'm no accessibility expert, but here's the bare minimum you should implement for a control that resembles a button and contains other sub-controls. Be sure to conform ",(0,i.kt)("inlineCode",{parentName:"p"},"KeyboardShortcutView")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"NSAccessibilityButton")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"NSAccessibilityGroup"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-swift"},"open override func isAccessibilityElement() -> Bool {\n    return true\n}\nopen override func accessibilityHelp() -> String? {\n    return Localized.help\n}\nopen override func accessibilityRole() -> NSAccessibilityRole? {\n    return .button\n}\nopen override func accessibilityLabel() -> String? {\n    let str = self.stringRepresentation\n    return str.isEmpty ? Localized.noShortcut : str\n}\nopen override func accessibilityValue() -> Any? {\n    return self.accessibilityLabel()\n}\nopen override func accessibilityRoleDescription() -> String? {\n    return Localized.tooltipPrefix\n}\nopen override var accessibilityFocusedUIElement: Any? {\n    return self.window?.firstResponder == self\n}\nopen override func accessibilityChildren() -> [Any]? {\n    return [self.clearButton]\n}\nopen override func accessibilityPerformPress() -> Bool {\n    guard self.isEnabled else { return false }\n    self.performClick(nil)\n    return true\n}\n")),(0,i.kt)("p",null,"And while that presents our accessible properties to the accessibility daemons and tools, we should also post notifications using ",(0,i.kt)("inlineCode",{parentName:"p"},"NSAccessibilityPostNotification")," when ",(0,i.kt)("inlineCode",{parentName:"p"},"shortcut")," changes, and definitely emit a VoiceOver announcement when we change recording state or set the shortcut from user input."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-swift"},"\n/*@objc*/ open var shortcut: KeyboardShortcutView.Pair? {\n    didSet {\n        // ...\n        NSAccessibilityPostNotification(self, .valueChanged)\n        // ...\n    }\n}\nopen override func performKeyEquivalent(with event: NSEvent) -> Bool {\n    // ...\n    if /* we should record the new shortcut */ {\n        // ...\n        NSAccessibilityPostNotificationWithUserInfo(self, .announcementRequested, [\n            .announcement: Localized.voiceOverRecorded,\n            .priority: NSAccessibilityPriorityLevel.high\n        ])\n        return true\n    }\n    // ...\n}\n\n\npublic func beginRecording() -> Bool {\n    // ...\n    NSAccessibilityPostNotificationWithUserInfo(self, .announcementRequested, [\n        .announcement: Localized.voiceOverBegin,\n        .priority: NSAccessibilityPriorityLevel.high\n    ])\n    return true\n}\n\n@objc private func buttonAction(_ button: NSButton) {\n    // ...\n    if /* we should clear the shortcut set */ {\n        // ...\n        NSAccessibilityPostNotificationWithUserInfo(self, .announcementRequested, [\n            .announcement: Localized.voiceOverCleared,\n            .priority: NSAccessibilityPriorityLevel.high\n        ])\n    }\n}\n\nopen override func updateLayer() {\n    // ...\n    self.clearButton.setAccessibilityLabel(canStop ? Localized.buttonRecordLabel\n                                                   : Localized.buttonClearLabel)\n}\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-swift"},"in KeyboardShortcutView.clearButton.getter:\n        button.toolTip = Localized.buttonTooltip\n        button.setAccessibilityHelp(Localized.buttonTooltip)\n")),(0,i.kt)("p",null,"We don't just place the VoiceOver announcements in ",(0,i.kt)("inlineCode",{parentName:"p"},"willSet"),"/",(0,i.kt)("inlineCode",{parentName:"p"},"didSet")," for ",(0,i.kt)("inlineCode",{parentName:"p"},"isRecording"),", because they are unique to the reason why the recording state changed."),(0,i.kt)("h3",{id:"nscoding--state-restoration"},(0,i.kt)("inlineCode",{parentName:"h3"},"NSCoding")," & State Restoration"),(0,i.kt)("p",null,"One of the most crucial things is to support ",(0,i.kt)("inlineCode",{parentName:"p"},"NSCoding")," if you aim to be Interface Builder-compatible, and to support automatic termination, through ",(0,i.kt)("inlineCode",{parentName:"p"},"NSResponder")," state restoration. State restoration should encode and decode only a subset of the keys the class typically encodes or decodes for ",(0,i.kt)("inlineCode",{parentName:"p"},"NSCoding"),": the ones that are actually user-facing state. As Apple says, ",(0,i.kt)("em",{parentName:"p"},'"you must store enough data to reconfigure the responder and return it to its current state during a subsequent launch of the application."')),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Here, you really should ",(0,i.kt)("em",{parentName:"strong"},"not")," be passing ",(0,i.kt)("inlineCode",{parentName:"strong"},"NSCoding")," methods onto ",(0,i.kt)("inlineCode",{parentName:"strong"},"NSResponder"),"'s state restoration.")," I leave the proper implementation as an exercise for the reader. ",(0,i.kt)("em",{parentName:"p"},"(read: I was lazy about it.)")," I've decided to not implement it correctly as I'm currently experimenting with a ",(0,i.kt)("inlineCode",{parentName:"p"},"Codable")," <--\x3e ",(0,i.kt)("inlineCode",{parentName:"p"},"NSCoding")," adapter specific to my implementation of this control. I'll possibly write another post on that later."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-swift"},'open static var supportsSecureCoding: Bool {\n    return true\n}\n\npublic required init?(coder: NSCoder) {\n    super.init(coder: coder)\n    self.restoreState(with: coder)\n    self.commonInit()\n}\n\nopen override func encode(with coder: NSCoder) {\n    super.encode(with: coder)\n    self.encodeRestorableState(with: coder)\n}\n\nopen override func encodeRestorableState(with coder: NSCoder) {\n    //super.encodeRestorableState(with: coder)\n    \n    coder.encode(self.suggestions.map { representation(of: $0) }, forKey: "suggestions")\n    coder.encode(representation(of:self.shortcut), forKey: "shortcut")\n    coder.encode(self.isEnabled as NSNumber, forKey: "isEnabled")\n}\n\nopen override func restoreState(with coder: NSCoder) {\n    //super.restoreState(with: coder)\n    \n    let s = coder.decodeObject(of: NSArray.self, forKey: "suggestions") as? [NSDictionary]\n    self.suggestions = (s ?? []).compactMap { representation(of: $0) }\n    self.shortcut = representation(of: coder.decodeObject(of: NSDictionary.self, forKey: "shortcut"))\n    self.isEnabled = coder.decodeObject(of: NSNumber.self, forKey: "isEnabled") as? Bool ?? false\n}\n')),(0,i.kt)("p",null,"Be sure to conform ",(0,i.kt)("inlineCode",{parentName:"p"},"KeyboardShortcutView")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"NSSecureCoding"),". When we change certain properties (the ones we're encoding and decoding), we should call ",(0,i.kt)("inlineCode",{parentName:"p"},"invalidateRestorableState")," to ensure our current state is encoded (automatic termination is like the grim reaper: it arrives without warning, and thus we must protect our interests before its arrival). Add the ",(0,i.kt)("inlineCode",{parentName:"p"},"self.invalidateRestorableState()")," call to the ",(0,i.kt)("inlineCode",{parentName:"p"},"didSet")," of ",(0,i.kt)("inlineCode",{parentName:"p"},"shortcut"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"suggestions"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"isEnabled"),". "),(0,i.kt)("p",null,"Now when you make a change, quit the app, reopen it, and you'll find that things were as you left it before you quit the app!"),(0,i.kt)("h3",{id:"context-nsmenu-popups"},"Context ",(0,i.kt)("inlineCode",{parentName:"h3"},"NSMenu")," Popups"),(0,i.kt)("p",null,"It may be desirable to allow the user to select a keyboard shortcut from a list of suggestions, like the Siri System Preferences pane, for example. To support this, let's add a ",(0,i.kt)("inlineCode",{parentName:"p"},"suggestions")," property that takes an ",(0,i.kt)("inlineCode",{parentName:"p"},"[KeyboardShortcutView.Pair]"),". When a ",(0,i.kt)("inlineCode",{parentName:"p"},"Pair")," is selected from the list, the ",(0,i.kt)("inlineCode",{parentName:"p"},"shortcut")," property is overridden with the selected value."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-swift"},"/*@objc*/ open var suggestions: [KeyboardShortcutView.Pair] = [] {\n    willSet { self.willChangeValue(forKey: #function) }\n    didSet {\n        self.didChangeValue(forKey: #function)\n        // ...\n    }\n}\n")),(0,i.kt)("p",null,"Now, how do we actually display the list of suggestions to the user, in-band with the control itself? ",(0,i.kt)("inlineCode",{parentName:"p"},"NSView")," offers a ",(0,i.kt)("inlineCode",{parentName:"p"},"menu")," property, but we can also override ",(0,i.kt)("inlineCode",{parentName:"p"},"menu(for:)")," to return an ",(0,i.kt)("inlineCode",{parentName:"p"},"NSMenu")," based on where the menu-opening right click occurred, specifically. Since we don't need that level of granularity, let's go ahead and override ",(0,i.kt)("inlineCode",{parentName:"p"},"menu")," directly and map ",(0,i.kt)("inlineCode",{parentName:"p"},"suggestions")," into ",(0,i.kt)("inlineCode",{parentName:"p"},"NSMenuItem"),"s. Note that to be able to manually enable or disable menu items, we should set ",(0,i.kt)("inlineCode",{parentName:"p"},"NSMenu.autoenablesItems")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),", because otherwise, ",(0,i.kt)("inlineCode",{parentName:"p"},"NSMenu")," will validate the existence of each menu item's ",(0,i.kt)("inlineCode",{parentName:"p"},"action")," method existing on the item's ",(0,i.kt)("inlineCode",{parentName:"p"},"target"),". "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-swift"},'open override var menu: NSMenu? {\n    get {\n        let menu = NSMenu()\n        menu.autoenablesItems = false\n        for (i, x) in self.suggestions.enumerated() {\n            let str = Localized.menuPrefix + " " + x.modifierFlags.characters + x.keyCode.characters\n            let item = NSMenuItem(title: str, action: #selector(self.selectAction(_:)), keyEquivalent: "")\n            item.tag = i\n            item.target = self\n            item.isEnabled = self.isEnabled\n            menu.addItem(item)\n        }\n        return menu\n    }\n    set { }\n}\n\n@objc private func selectAction(_ item: NSMenuItem) {\n    guard self.isEnabled else { return }\n    self.endRecording()\n    self.shortcut = self.suggestions[item.tag]\n}\n')),(0,i.kt)("p",null,"We've also overridden ",(0,i.kt)("inlineCode",{parentName:"p"},"menu.setter")," to become a no-op, because we no longer want to allow a client to set a ",(0,i.kt)("inlineCode",{parentName:"p"},"menu")," that may have no context with our control. In effect, we're forcing our clients to use ",(0,i.kt)("inlineCode",{parentName:"p"},"suggestions")," only. An alternative could be to override ",(0,i.kt)("inlineCode",{parentName:"p"},"menu(for:)")," and return a new ",(0,i.kt)("inlineCode",{parentName:"p"},"NSMenu")," with ",(0,i.kt)("inlineCode",{parentName:"p"},"self.menu.items + self.suggestions.map { $0.toMenuItem() }")," (pseudocode). "),(0,i.kt)("p",null,"Astute readers will spot the race condition possible with this code: ",(0,i.kt)("inlineCode",{parentName:"p"},"suggestions")," may have been modified between ",(0,i.kt)("inlineCode",{parentName:"p"},"menu.getter")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"selectAction(_:)"),", causing ",(0,i.kt)("inlineCode",{parentName:"p"},"self.suggestions[item.tag]")," to become inconsistent or crash. ",(0,i.kt)("em",{parentName:"p"},"Solving this race condition is an exercise left to the reader... (I'm just using that phrase to avoid solving the problems myself aren't I?)")),(0,i.kt)("h3",{id:"undo-management"},"Undo Management"),(0,i.kt)("p",null,"Because macOS applications use variations of the ",(0,i.kt)("inlineCode",{parentName:"p"},"\u2318Z")," shortcut to undo or redo, it might seem a little odd to support undo management in a control that's designed to record keyboard shortcuts themselves. However, as long as the control isn't the first responder, the undo action will always trigger, ",(0,i.kt)("em",{parentName:"p"},"except")," in cases where the app has registered ",(0,i.kt)("inlineCode",{parentName:"p"},"\u2318Z")," as a global shortcut (the ",(0,i.kt)("inlineCode",{parentName:"p"},"delegate")," should ideally prevent things like that)."),(0,i.kt)("p",null,"Adding support for undo management is actually very easy; since setting the ",(0,i.kt)("inlineCode",{parentName:"p"},"shortcut")," property changes what the user sees, and we set this property internally in ",(0,i.kt)("inlineCode",{parentName:"p"},"performKeyEquivalent(_:)"),", we can register our undo action there! This does have an unintended/unwanted side effect of also pushing the undo stack when the app is programmatically setting the ",(0,i.kt)("inlineCode",{parentName:"p"},"shortcut")," value. However, I think it's perfectly acceptable to keep a continuous undo stack between the app and user actions in this case."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-swift"},"/*@objc*/ open var shortcut: KeyboardShortcutView.Pair? {\n    didSet {\n        // ...\n        self.undoManager?.registerUndo(withTarget: self) { [oldValue] _ in\n            self.shortcut = oldValue\n        }\n        self.setActionName(Localized.actionName)\n        // ...\n    }\n}\n")),(0,i.kt)("p",null,"Each ",(0,i.kt)("inlineCode",{parentName:"p"},"NSResponder")," has an ",(0,i.kt)("inlineCode",{parentName:"p"},"undoManager")," that we can just register the undo action with -- an undo action takes ",(0,i.kt)("inlineCode",{parentName:"p"},"self")," as the target, with a handler to execute when the user un-does the current action. Notice that we capture ",(0,i.kt)("inlineCode",{parentName:"p"},"oldValue")," at registration-time, instead of invocation-time: this is so we don't set the undone ",(0,i.kt)("inlineCode",{parentName:"p"},"shortcut")," value to itself accidentally."),(0,i.kt)("p",null,"Running an application with an existing saved state, we'll notice an unusual glitch: it appears that even though the app was just launched (and restored its state), the user sees an undo action, even though they haven't interacted with the control yet! This is because the one edge-case we need to control in setting the ",(0,i.kt)("inlineCode",{parentName:"p"},"shortcut")," property is the initializer(s) setting it. A ",(0,i.kt)("inlineCode",{parentName:"p"},"Swift")," initializer does not invoke any property observers when a member's value is set, ",(0,i.kt)("strong",{parentName:"p"},"however"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"restoreState(_:)")," is not an initializer! It's a normal method, and thus, will invoke the ",(0,i.kt)("inlineCode",{parentName:"p"},"didSet"),", which is harmless, except for this particular side effect. The solution is to only register an action with the undo manager if we aren't restoring state."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-swift"},"/*@objc*/ open var shortcut: KeyboardShortcutView.Pair? {\n    didSet {\n        // ...\n        if !self.isRestoringState {\n            self.undoManager?.registerUndo(withTarget: self) { [oldValue] _ in\n                self.shortcut = oldValue\n            }\n            self.setActionName(Localized.actionName)\n        }\n        // ...\n    }\n}\n\n// ...\n\nprivate var isRestoringState: Bool = false\n\nopen override func restoreState(with coder: NSCoder) {\n    // ...\n    self.isRestoringState = true\n    defer {self.isRestoringState = false }\n    // ...\n}\n")),(0,i.kt)("p",null,"Now, running the app from an existing saved state won't cause unexpected undo actions to register! The astute reader will also observe that we could just flip the condition on ",(0,i.kt)("inlineCode",{parentName:"p"},"isRestoringState"),", calling the boolean ",(0,i.kt)("inlineCode",{parentName:"p"},"shouldRegisterUndo"),", and only enable it during ",(0,i.kt)("inlineCode",{parentName:"p"},"performKeyEquivalent(_:)"),". That's a perfectly fine solution as well, depending on what undo registration behavior you want to achieve."),(0,i.kt)("p",null,"What about redo actions? We've only set up undo actions: if the user types ",(0,i.kt)("inlineCode",{parentName:"p"},"\u2318L")," and then undoes the action, how do we allow the user to redo that (that is, set the shortcut again to ",(0,i.kt)("inlineCode",{parentName:"p"},"\u2318L"),")? It turns out that ",(0,i.kt)("inlineCode",{parentName:"p"},"UndoManager")," handles this logic already, and if we're currently executing the registered undo action's handler, ",(0,i.kt)("inlineCode",{parentName:"p"},"isUndoing")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),', and the "undo action of the undo action" is translated into a "redo action" for us. We\'re all done here!'),(0,i.kt)("h2",{id:"conclusion"},"Conclusion"),(0,i.kt)("p",null,"With that, we've completely designed and implemented a keyboard shortcut recording control, following correct practice and masquerading as a first class AppKit citizen! If you have any questions, comments, or concerns, contact me on Twitter or Github @avaidyam!"))}c.isMDXComponent=!0},6824:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/finalcut-keyboard-a42ab2a630db0d4127a3b1e7072d6545.jpg"},4306:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/shortcut-recorder-b7f561211d859622dbfe5614b14170fc.gif"},9596:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/window-state-ccecc78070390cf7b33c68fa20484132.png"}}]);