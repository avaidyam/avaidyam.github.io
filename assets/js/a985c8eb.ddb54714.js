"use strict";(self.webpackChunkAditya_Vaidyam=self.webpackChunkAditya_Vaidyam||[]).push([[499],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>C});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function p(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),s=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=s(e.components);return a.createElement(l.Provider,{value:t},e.children)},m="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,d=p(e,["components","mdxType","originalType","parentName"]),m=s(n),h=i,C=m["".concat(l,".").concat(h)]||m[h]||c[h]||r;return n?a.createElement(C,o(o({ref:t},d),{},{components:n})):a.createElement(C,o({ref:t},d))}));function C(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=h;var p={};for(var l in t)hasOwnProperty.call(t,l)&&(p[l]=t[l]);p.originalType=e,p[m]="string"==typeof e?e:i,o[1]=p;for(var s=2;s<r;s++)o[s]=n[s];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},9842:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>r,metadata:()=>p,toc:()=>s});var a=n(7462),i=(n(7294),n(3905));const r={},o="DIY: Core Animation",p={permalink:"/blog/2019/02/19/",source:"@site/blog/2019-02-19.md",title:"DIY: Core Animation",description:"(Check out the project over here.)",date:"2019-02-19T00:00:00.000Z",formattedDate:"February 19, 2019",tags:[],readingTime:5.96,hasTruncateMarker:!0,authors:[],frontMatter:{},prevItem:{title:"On the debate of iOS vs. macOS",permalink:"/blog/2019/06/02/"},nextItem:{title:"An Exercise in Modern Cocoa Views",permalink:"/blog/2018/03/22/"}},l={authorsImageUrls:[]},s=[],d={toc:s},m="wrapper";function c(e){let{components:t,...n}=e;return(0,i.kt)(m,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/avaidyam/DIYAnimation"},"(Check out the project over here.)")),(0,i.kt)("p",null,"After having been a consumer of the ",(0,i.kt)("strong",{parentName:"p"},"Core Animation")," (originally ",(0,i.kt)("strong",{parentName:"p"},"LayerKit"),') framework for about a decade now, I began to wonder how it was designed and implemented under the hood. Not simply the surface details such as "it\'s rendered out of process" or "it handles the animation interpolation for you" or whatnot, but more specifically, ',(0,i.kt)("strong",{parentName:"p"},"HOW")," all of its beautiful bells and whistles translate into nitty gritty graphics ideas and associated draw calls. I figured the best way was to try to build it myself from scratch!"),(0,i.kt)("p",null,"So I took iron to the anvil and decided to reimplement ",(0,i.kt)("strong",{parentName:"p"},"Core Animation")," in near-pure Swift -- that is, avoiding ",(0,i.kt)("inlineCode",{parentName:"p"},"NSObject"),"/Cocoa wherever possible. I didn't attempt to implement the entire API surface, such as ",(0,i.kt)("inlineCode",{parentName:"p"},"CAAtom"),", or the layout managers API (for that matter, layout managers have been remarked by Core Animation engineers as a bad idea anyways). I chose to design a closely matched, but overall Swift-ier API, such as ",(0,i.kt)("inlineCode",{parentName:"p"},"Render.Value"),". I haven't yet, however, implemented wrappers for all ",(0,i.kt)("inlineCode",{parentName:"p"},"Codable")," types, partially because ",(0,i.kt)("strong",{parentName:"p"},"Core Animation")," is implemented in C++ and some internal types such as ",(0,i.kt)("inlineCode",{parentName:"p"},"CA::Render::Vector")," are actually wrappers around ",(0,i.kt)("inlineCode",{parentName:"p"},"float[]"),", for example. Implementing serialization for a ",(0,i.kt)("inlineCode",{parentName:"p"},"[Float]")," in Swift is free, so we don't necessarily need these wrapper types. Some facilities like ",(0,i.kt)("inlineCode",{parentName:"p"},"fence"),"s to synchronize rendering between threads or processes, or ",(0,i.kt)("inlineCode",{parentName:"p"},"slot"),"s to share drawable items (if I recall correctly), aren't implemented yet simply because they're not required in ",(0,i.kt)("strong",{parentName:"p"},"DIYAnimation")," yet. Ultimately, only the Objective-C ",(0,i.kt)("inlineCode",{parentName:"p"},"CA*")," and the internal ",(0,i.kt)("inlineCode",{parentName:"p"},"CA::Render::*")," API surfaces are the same, as I've reimplemented the actual rendering (",(0,i.kt)("inlineCode",{parentName:"p"},"CA::OGL::*"),") in an entirely different way atop ",(0,i.kt)("inlineCode",{parentName:"p"},"Metal"),"."),(0,i.kt)("p",null,"Another major departure from the C++ implementation is the use of ",(0,i.kt)("inlineCode",{parentName:"p"},"XPC")," serialization and transport over raw ",(0,i.kt)("inlineCode",{parentName:"p"},"mach_msg")," types and calls. While ",(0,i.kt)("inlineCode",{parentName:"p"},"XPC")," is best known for its service and connection facilities, ",(0,i.kt)("strong",{parentName:"p"},"DIYAnimation")," uses the ",(0,i.kt)("inlineCode",{parentName:"p"},"xpc_pipe_t")," object atop raw mach ports, a transport medium for serialized ",(0,i.kt)("inlineCode",{parentName:"p"},"XPC")," objects to be passed between threads and processes which underlies ",(0,i.kt)("inlineCode",{parentName:"p"},"xpc_connection_t"),". After writing an ",(0,i.kt)("inlineCode",{parentName:"p"},"XPC")," encoder and decoder pair in Swift, the ",(0,i.kt)("inlineCode",{parentName:"p"},"XPCPipe")," wrapper works with any ",(0,i.kt)("inlineCode",{parentName:"p"},"Codable")," with some notable exceptions involving patched implementations. Though I've got a mach shared memory object in Swift matching the original implementation, I'm instead using ",(0,i.kt)("inlineCode",{parentName:"p"},"IOSurface")," in a few places simply because it's easier to work with at the moment. I'll talk a bit more about the ",(0,i.kt)("inlineCode",{parentName:"p"},"XPC")," internals later, but for now I'll share a few tidbits I came across while implementing parts of ",(0,i.kt)("strong",{parentName:"p"},"DIYAnimation"),"."),(0,i.kt)("p",null,"Since ",(0,i.kt)("strong",{parentName:"p"},"Core Animation")," doesn't deal with accelerated 2D graphics (i.e. the now-defunct ",(0,i.kt)("inlineCode",{parentName:"p"},"QuartzGL")," from ",(0,i.kt)("strong",{parentName:"p"},"Core Graphics"),"), text rendering, for example, is CPU-bound -- it's implemented in an identical manner in ",(0,i.kt)("strong",{parentName:"p"},"DIYAnimation"),". However, while ",(0,i.kt)("inlineCode",{parentName:"p"},"QuartzGL")," is indeed defunct, ",(0,i.kt)("strong",{parentName:"p"},"Core Animation")," does actually indirectly support accelerated drawing! To make a very long story short, non-accelerated/CPU-bound drawing is performed through ",(0,i.kt)("inlineCode",{parentName:"p"},"CGContext")," from ",(0,i.kt)("inlineCode",{parentName:"p"},"Core Graphics"),", which is actually just a wrapper around ",(0,i.kt)("inlineCode",{parentName:"p"},"CGGState"),", which manages the transparency layers and graphics state stack, and ",(0,i.kt)("inlineCode",{parentName:"p"},"CGContextDelegate"),", which handles conversion of Quartz draw calls into actual rasterization. (As a side-side-note, ",(0,i.kt)("inlineCode",{parentName:"p"},"CGLayers")," and transparency layers are essentially identical, but capture context state at different points in the drawing lifecycle.) ",(0,i.kt)("inlineCode",{parentName:"p"},"CAWindowContextDelegate")," is the delegate used by all ",(0,i.kt)("inlineCode",{parentName:"p"},"CGContext"),"s drawing to a Cocoa window, and ",(0,i.kt)("inlineCode",{parentName:"p"},"CAIOSurfaceContextDelegate")," is the delegate used by all ",(0,i.kt)("inlineCode",{parentName:"p"},"CGContext"),"s attached to a ",(0,i.kt)("inlineCode",{parentName:"p"},"CALayer")," that's currently accelerating drawing within ",(0,i.kt)("inlineCode",{parentName:"p"},"-drawInContext:"),". It accelerates drawing by buffering its queued draw calls until its associated layer needs to draw to screen, and subsequently thereafter, its associated ",(0,i.kt)("inlineCode",{parentName:"p"},"IOSurface")," needs to draw to screen. "),(0,i.kt)("p",null,"I've attempted to replicate window server functionality as seen in ",(0,i.kt)("inlineCode",{parentName:"p"},"CAWindowServer")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"CADisplay"),", using ",(0,i.kt)("inlineCode",{parentName:"p"},"CGS")," windows (",(0,i.kt)("inlineCode",{parentName:"p"},"CoreGraphicsServices"),", now known as ",(0,i.kt)("inlineCode",{parentName:"p"},"SkyLight")," in macOS 11+), though it's done somewhat strangely at the moment. Not only does ",(0,i.kt)("inlineCode",{parentName:"p"},"SkyLight")," on macOS handle event routing and layer compositing like ",(0,i.kt)("strong",{parentName:"p"},"Core Animation")," on iOS, but also desktop management, spaces, the menu bar, cursors, and controlling the dock, and more on macOS. That's a lot of additional functionality that I'll be ignoring. In ",(0,i.kt)("inlineCode",{parentName:"p"},"AppKit"),", for example, invoking the modern drag and drop API eventually calls into ",(0,i.kt)("inlineCode",{parentName:"p"},"HIServices"),", the vestigial ",(0,i.kt)("inlineCode",{parentName:"p"},"Carbon.framework")," remnant underlying most of ",(0,i.kt)("inlineCode",{parentName:"p"},"AppKit"),", which then calls into the ",(0,i.kt)("inlineCode",{parentName:"p"},"CoreDrag.framework"),", which then creates a new ",(0,i.kt)("inlineCode",{parentName:"p"},"CGSWindow")," with the ",(0,i.kt)("strong",{parentName:"p"},"SkyLight")," window server, a new ",(0,i.kt)("inlineCode",{parentName:"p"},"CAContext")," to go with it (therefore enabling ",(0,i.kt)("strong",{parentName:"p"},"Core Animation")," embedding in that window), and a new root ",(0,i.kt)("inlineCode",{parentName:"p"},"CALayer"),". That layer is then what you see while dragging a file or anything else. The actual movement of data between one process to another (",(0,i.kt)("inlineCode",{parentName:"p"},"NSPasteboard")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"AppKit"),") is actually implemented using ",(0,i.kt)("inlineCode",{parentName:"p"},"CFMessagePort")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"HIServices")," - every AppKit-linked process has this port pair allocated for drag-and-drop or other pasteboard synchronization. "),(0,i.kt)("p",null,"Speaking of ",(0,i.kt)("inlineCode",{parentName:"p"},"CGSWindow")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"CAContext"),", by the way, these two API are actually somewhat identical in some ways. ",(0,i.kt)("inlineCode",{parentName:"p"},"AppKit"),"'s ",(0,i.kt)("inlineCode",{parentName:"p"},"NSWindow")," wraps a ",(0,i.kt)("inlineCode",{parentName:"p"},"CGSWindow"),", and supports on-screen drawing through providing a ",(0,i.kt)("inlineCode",{parentName:"p"},"CGContext")," to its children ",(0,i.kt)("inlineCode",{parentName:"p"},"NSView"),"s. System events are passed from the ",(0,i.kt)("inlineCode",{parentName:"p"},"SkyLight")," window server to the most appropriate ",(0,i.kt)("inlineCode",{parentName:"p"},"CGSWindow")," (through a callback into the application's run loop) which then is translated and passed to the appropriate ",(0,i.kt)("inlineCode",{parentName:"p"},"NSView")," by that ",(0,i.kt)("inlineCode",{parentName:"p"},"NSWindow"),". The connection to the window server, ",(0,i.kt)("inlineCode",{parentName:"p"},"CGSConnection")," is actually explicit in all these API, and must be created by ",(0,i.kt)("inlineCode",{parentName:"p"},"AppKit")," for each thread that wants to manage on-screen elements. Each connection is recorded by the server in an identifier-based lookup table, and upon each call to the server, its originating connection's rights are validated for each resource modified or accessed by that call. ",(0,i.kt)("inlineCode",{parentName:"p"},"SkyLight")," actually uses ",(0,i.kt)("strong",{parentName:"p"},"Mach Interface Generator (MIG)")," to marshall these calls, and connections are actually just composed of a server request mach port and an on-demand client notification/event port. In ",(0,i.kt)("strong",{parentName:"p"},"Core Animation"),", however, ",(0,i.kt)("inlineCode",{parentName:"p"},"CAContext")," doesn't handle any drawing or rendering control itself, instead delegating this to its root ",(0,i.kt)("inlineCode",{parentName:"p"},"CALayer"),". It does control inter-context ordering (i.e. ordering root layers relative to all other on-screen root layers) and event routing when initialized connected to a remote window server instead of initialized as a local rendering context. So, CA windows (contexts) are equivalent to SkyLight windows, but while one SkyLight connection can control many windows, one CA connection may only control one CA window (context). In a way though, for quite some time now, ",(0,i.kt)("inlineCode",{parentName:"p"},"AppKit")," internal/private API has slowly been modernized to match ",(0,i.kt)("strong",{parentName:"p"},"Core Animation"),", with functions like ",(0,i.kt)("inlineCode",{parentName:"p"},"NSWindowMark")," mimicking ",(0,i.kt)("inlineCode",{parentName:"p"},"CALayerMark")," along with the recent addition of transactions. (With ",(0,i.kt)("inlineCode",{parentName:"p"},"CGPixelAccess")," and direct ",(0,i.kt)("inlineCode",{parentName:"p"},"CGContext")," drawing, ",(0,i.kt)("inlineCode",{parentName:"p"},"SkyLight")," actually has an analogous concept to ",(0,i.kt)("inlineCode",{parentName:"p"},"CABackingStore"),"; ",(0,i.kt)("inlineCode",{parentName:"p"},"CA::Shape")," too is essentially the same as ",(0,i.kt)("inlineCode",{parentName:"p"},"CGSRegionObj"),"/",(0,i.kt)("inlineCode",{parentName:"p"},"CGRegion"),".)"),(0,i.kt)("p",null,"Anyways, the next steps for this project include adding ",(0,i.kt)("inlineCode",{parentName:"p"},"CADynamicsBehavior")," (probably hard, requiring ",(0,i.kt)("inlineCode",{parentName:"p"},"box2d")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"PhysicsKit")," integration), ",(0,i.kt)("inlineCode",{parentName:"p"},"CAStateController")," (likely easy), ",(0,i.kt)("inlineCode",{parentName:"p"},"CAPresentationModifier")," (likely easy), and ",(0,i.kt)("inlineCode",{parentName:"p"},"CAML")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"CAPackage")," support (likely easy... if using ",(0,i.kt)("inlineCode",{parentName:"p"},"NSXMLParser"),"). Though they've since been removed from ",(0,i.kt)("strong",{parentName:"p"},"Core Animation"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"CALight")," and related lighting filters did used to exist, roughly matching SVG's ",(0,i.kt)("inlineCode",{parentName:"p"},"feDiffuseLighting")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"feSpecularLighting"),", for example. They were meant to be used with ",(0,i.kt)("inlineCode",{parentName:"p"},"CAMeshTransform"),", which is also currently unimplemented. In summary, as you can see, there's a lot of private and some public API that are yet unimplemented, even though the groundwork has been laid. Take a look at the implementation details -- I'm sure you'll find them interesting, as they're mostly faithful to the original (decompiled) C++ implementation!"))}c.isMDXComponent=!0}}]);