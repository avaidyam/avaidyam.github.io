"use strict";(self.webpackChunkAditya_Vaidyam=self.webpackChunkAditya_Vaidyam||[]).push([[477],{10:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"/2019/06/02/","metadata":{"permalink":"/blog/2019/06/02/","source":"@site/blog/2019-06-02.md","title":"On the debate of iOS vs. macOS","description":"I\'ve been seeing a lot of opinions on this topic and decided to articulate some of my own after having spent a month primarily using an iPad for nearly everything. I\'ve closely monitored the few cases where I\'ve needed to use my MacBook Pro and effectively made a list of things iOS should implement for feature parity with macOS.","date":"2019-06-02T00:00:00.000Z","formattedDate":"June 2, 2019","tags":[],"readingTime":7.45,"truncated":true,"authors":[],"frontMatter":{},"nextItem":{"title":"DIY: Core Animation","permalink":"/blog/2019/02/19/"}},"content":"I\'ve been seeing a lot of opinions on this topic and decided to articulate some of my own after having spent a month primarily using an iPad for nearly everything. I\'ve closely monitored the few cases where I\'ve needed to use my MacBook Pro and effectively made a list of things iOS should implement for feature parity with macOS.  \\n\\n\x3c!--truncate--\x3e\\n\\n#### First, a summary. **macOS takes the old approach: everything is a file (a la UNIX) and apps are tools to manipulate files. iOS takes a new approach: everything is an app and files are byproducts of the apps.** Furthermore, macOS offers to its apps the organization paradigms of spaces (virtual desktops), windows, tabs, and menus (the vertical variety).\\n\\nThe biggest confusion I had was thinking about where my files would go in iOS. The `~/Desktop` on macOS would just be the `Files` app\'s local app container. `~/Documents` would be the set of ALL app containers on the device. (Side note: this is actually how the `iCloud Drive` folder works.) `/Applications` isn\'t a folder at all in this case, obviously. `~/Music`, `~/Photos`, `~/Videos`, and so on are just the app containers for those apps. Because there\'s only one user account on iOS there\'s no `/Users` folder (or `~/Applications` folder, for that matter). Likewise, there\'s no need for UNIX chmod permissions or the `~/Public` folder anymore because of the single-user model. `~/Library`, `/Library`, and `/System/Library` are basically all merged into a new **\\"System\\" app** container, if such a thing were to exist. This model, however, doesn\'t account for any loose files in the home directory or system directories, though they might hypothetically be merged into the `Files` or `System` app container. \\n\\nThe `System` app should basically be responsible for the app launcher, dock, gesture navigation, notification center, and the lock screen. These are actually all things that the `Dock` app on macOS handles with `NotificationCenter`. The macOS login window is also basically the lock screen as well. The `System` app should also offer extension points (how about letting third-party apps define extension points?) for the control center actions, notifications, today widgets, and lock screen quick-launch (instead of just the `Camera`). `Spotlight` and `Siri` should be merged as a system feature into `System` instead of standalone apps. While I mention this, why are `Mission Control`, `Dashboard`, `Launchpad`, `Siri` and other system features their own \\"apps\\" on macOS? They shouldn\'t be (and `Dashboard` is long dead anyway). \\n\\nInstead of multitasking showing **all** recent apps, it work like `Mission Control` on macOS - if enabled and supported by the device. Currently on iPads, Split View app pairs are remembered in the multitasking view, and if you open an app that was placed in Split View, iOS will bring you to the Split View instead of re-opening the app on its own. This effectively is the same idea as Spaces on macOS, which further remembers and separates multiple windows from a single app. \\n\\nmacOS is already much closer to the iOS model than I had previously thought: I\'ve always ran `defaults write com.apple.Finder CreateDesktop -bool NO` to disable `Desktop` icons as soon as I\'ve set up a new Mac. Using the five-finger pinch, I\'d be able to see all my apps in `Launchpad` (though I stick to using Spotlight with `CMD-Space` instead). If you\'ve enabled iCloud Drive, nearly every app that supports it will open with a document picker as well... I could full-screen every app I use on a Mac and completely avoid using `Finder` if I really wanted to replicate iOS. One incongruency in `Launchpad` is actually that it doesn\'t hide apps that you\'ve already pinned to the Dock because the `Dock` also serves as a \\"recent apps\\" view, and you can\'t add the virtual (as opposed to actually putting apps in sub-folders) `Launchpad` folders to the `Dock`.\\n\\nAnd now for an unpopular opinion: the Touch Bar\'s Control Strip is the macOS replacement for the Control Center on iOS. It serves exactly every same purpose, but does lack the action buttons to create a new note or voice memo, shortcuts for timers/alarms/stopwatch, and HomeKit toggles. However, macOS basically just got the half-baked `Voice Memo` and `Home` apps, and still lacks a `Clock` app so I think just the Notes action would be nice for now... The Touch Bar on macOS however lacks discoverability: just like the trackpad, it needs force touch to mimic physical keys. When you \\"touch\\" or \\"scan\\" your fingers across, you should feel the haptics of keys, dials, or sliders - but only when you deep press, should you \\"activate\\" the button or control, mimicking a physical keyboard press. Also, why doesn\'t every single Mac come with it? By fragmenting features like 3D Touch or the Touch Bar to just a few devices, only a few good developers support those features, and most people dismiss it as a gimmick because it\'s not fleshed out or integrated into every single app. \\n\\nThe `Files` app is also missing Quick Look extensions, system-wide `Spotlight`, filtered-and-sorted search, smart folders (which rely on the two before), customized folder views with background images, aliases, jumping to a location by tying it like \\"Go To Folder\\", a built-in `Archive Utility` for folder compression, and support for DMGs, external drives, or remote servers. When selecting multiple files, the app no longer offers you a tap-and-hold menu which is very inconsistent design, but further doesn\'t support multi-rename, multi-copy, or multi-quick-look (but multi-get-info on macOS is a terrifying experience if you\'ve accidentally done that for 1000+ files so maybe this is a good exception). The most heinous crime is actually that \\"Open With\\" isn\'t possible, thanks to the lack of File and URL associations; this way you\'d be able to go from file **TO** app instead of vice versa, like with macOS. It\'s very clear that on iOS, the `Files` app is a majority of the bottleneck in the experience of interoperability.\\n\\n`Folder Actions` however could instead be integrated into `Shortcuts` or `Automator` (one of which should be renamed to match the other...). Also, Apple should commit to either dropping AppleScript/Apple Events on macOS and implementing Intents-based automation as with iOS, **OR** bring AppleScript support to iOS apps. Chances are the former is more likely, which means I\'d like to see AppleScript or JSX transition to become a textual language for `Shortcuts` workflows. Also, global keyboard shortcuts aren\'t even supported on iOS - I can\'t quickly switch to an app or invoke some action when I\'m within a different app. \\n\\nIn apps like `Notes`, I\'d like to see the addition of physical files that I could move around to represent the notes being taken in the app. One might claim the `Notes` app then couldn\'t keep track of all its generated notes and that might confuse the user... but that\'s the indexing job of `Spotlight` at the end of the day. Speaking of `Notes`, I\'d like to see on both iOS and macOS, the integration of `TextEdit` for basic RTF editing and the features of the `Stickies` app. `Notes` on macOS already supports floating notes, it just has a massive title bar and can\'t shrink to a smaller size. Furthermore, why can\'t they just add a Today Widget on `macOS`?\\n\\nThere\'s a long list of apps I think iOS needs from macOS: `Activity Monitor`, `Terminal`, `Console`, `Disk Utility`, `Dictionary`, `Image Capture` built-into `Camera`, `Grapher` and `Calculator` merged, and `Keychain`, `Audio/MIDI Setup`, `Font Book` and `ColorSync` in Settings. macOS however definitely needs a `Clock` app. There\'s also some hidden core apps on macOS like `Directory Utility`, `Network Utility`, `RAID Utility`, `System Image Utility`, `Wireless Diagnostics`, `Certificate Assistant` `Screen Sharing`, `Storage Management`, and some others probably not mentioned that could be useful on iOS someday, even if only managing a macOS network remotely.\\n\\nAt the end of the day, I can have 5 to 10 different documents from 3 or 4 apps on say, 4 spaces, between two displays. iOS just doesn\'t support that. If it added support for multiple windows and opening different apps on the external display when attached, I could then see this becoming much much closer to reality, but I\'m doubtful. A user shouldn\'t be forced into picking sides, especially when both iOS and macOS have pretty much all the same capabilities. iOS apps and Mac apps aren\'t even all that different most of the time and what framework or language is used to make an app is probably the least of anyone\'s concern if the app does what it\'s supposed to do well enough for most users.\\n\\nThe convergence of iOS and macOS features isn\'t a limitation but a blessing to users who can now pick and choose to build their own unique workflows. Not everyone uses full screen apps, not everyone likes using tabs for web pages, and that\'s fine. The goal should be to empower users with choice, not make their decisions for them and tell them to look elsewhere, if they can\'t fit in."},{"id":"/2019/02/19/","metadata":{"permalink":"/blog/2019/02/19/","source":"@site/blog/2019-02-19.md","title":"DIY: Core Animation","description":"(Check out the project over here.)","date":"2019-02-19T00:00:00.000Z","formattedDate":"February 19, 2019","tags":[],"readingTime":5.96,"truncated":true,"authors":[],"frontMatter":{},"prevItem":{"title":"On the debate of iOS vs. macOS","permalink":"/blog/2019/06/02/"},"nextItem":{"title":"An Exercise in Modern Cocoa Views","permalink":"/blog/2018/03/22/"}},"content":"[(Check out the project over here.)](https://github.com/avaidyam/DIYAnimation)\\n\\nAfter having been a consumer of the **Core Animation** (originally **LayerKit**) framework for about a decade now, I began to wonder how it was designed and implemented under the hood. Not simply the surface details such as \\"it\'s rendered out of process\\" or \\"it handles the animation interpolation for you\\" or whatnot, but more specifically, **HOW** all of its beautiful bells and whistles translate into nitty gritty graphics ideas and associated draw calls. I figured the best way was to try to build it myself from scratch!\\n\\n\x3c!--truncate--\x3e\\n\\nSo I took iron to the anvil and decided to reimplement **Core Animation** in near-pure Swift -- that is, avoiding `NSObject`/Cocoa wherever possible. I didn\'t attempt to implement the entire API surface, such as `CAAtom`, or the layout managers API (for that matter, layout managers have been remarked by Core Animation engineers as a bad idea anyways). I chose to design a closely matched, but overall Swift-ier API, such as `Render.Value`. I haven\'t yet, however, implemented wrappers for all `Codable` types, partially because **Core Animation** is implemented in C++ and some internal types such as `CA::Render::Vector` are actually wrappers around `float[]`, for example. Implementing serialization for a `[Float]` in Swift is free, so we don\'t necessarily need these wrapper types. Some facilities like `fence`s to synchronize rendering between threads or processes, or `slot`s to share drawable items (if I recall correctly), aren\'t implemented yet simply because they\'re not required in **DIYAnimation** yet. Ultimately, only the Objective-C `CA*` and the internal `CA::Render::*` API surfaces are the same, as I\'ve reimplemented the actual rendering (`CA::OGL::*`) in an entirely different way atop `Metal`.\\n\\nAnother major departure from the C++ implementation is the use of `XPC` serialization and transport over raw `mach_msg` types and calls. While `XPC` is best known for its service and connection facilities, **DIYAnimation** uses the `xpc_pipe_t` object atop raw mach ports, a transport medium for serialized `XPC` objects to be passed between threads and processes which underlies `xpc_connection_t`. After writing an `XPC` encoder and decoder pair in Swift, the `XPCPipe` wrapper works with any `Codable` with some notable exceptions involving patched implementations. Though I\'ve got a mach shared memory object in Swift matching the original implementation, I\'m instead using `IOSurface` in a few places simply because it\'s easier to work with at the moment. I\'ll talk a bit more about the `XPC` internals later, but for now I\'ll share a few tidbits I came across while implementing parts of **DIYAnimation**.\\n\\nSince **Core Animation** doesn\'t deal with accelerated 2D graphics (i.e. the now-defunct `QuartzGL` from **Core Graphics**), text rendering, for example, is CPU-bound -- it\'s implemented in an identical manner in **DIYAnimation**. However, while `QuartzGL` is indeed defunct, **Core Animation** does actually indirectly support accelerated drawing! To make a very long story short, non-accelerated/CPU-bound drawing is performed through `CGContext` from `Core Graphics`, which is actually just a wrapper around `CGGState`, which manages the transparency layers and graphics state stack, and `CGContextDelegate`, which handles conversion of Quartz draw calls into actual rasterization. (As a side-side-note, `CGLayers` and transparency layers are essentially identical, but capture context state at different points in the drawing lifecycle.) `CAWindowContextDelegate` is the delegate used by all `CGContext`s drawing to a Cocoa window, and `CAIOSurfaceContextDelegate` is the delegate used by all `CGContext`s attached to a `CALayer` that\'s currently accelerating drawing within `-drawInContext:`. It accelerates drawing by buffering its queued draw calls until its associated layer needs to draw to screen, and subsequently thereafter, its associated `IOSurface` needs to draw to screen. \\n\\nI\'ve attempted to replicate window server functionality as seen in `CAWindowServer` and `CADisplay`, using `CGS` windows (`CoreGraphicsServices`, now known as `SkyLight` in macOS 11+), though it\'s done somewhat strangely at the moment. Not only does `SkyLight` on macOS handle event routing and layer compositing like **Core Animation** on iOS, but also desktop management, spaces, the menu bar, cursors, and controlling the dock, and more on macOS. That\'s a lot of additional functionality that I\'ll be ignoring. In `AppKit`, for example, invoking the modern drag and drop API eventually calls into `HIServices`, the vestigial `Carbon.framework` remnant underlying most of `AppKit`, which then calls into the `CoreDrag.framework`, which then creates a new `CGSWindow` with the **SkyLight** window server, a new `CAContext` to go with it (therefore enabling **Core Animation** embedding in that window), and a new root `CALayer`. That layer is then what you see while dragging a file or anything else. The actual movement of data between one process to another (`NSPasteboard` in `AppKit`) is actually implemented using `CFMessagePort` in `HIServices` - every AppKit-linked process has this port pair allocated for drag-and-drop or other pasteboard synchronization. \\n\\nSpeaking of `CGSWindow` and `CAContext`, by the way, these two API are actually somewhat identical in some ways. `AppKit`\'s `NSWindow` wraps a `CGSWindow`, and supports on-screen drawing through providing a `CGContext` to its children `NSView`s. System events are passed from the `SkyLight` window server to the most appropriate `CGSWindow` (through a callback into the application\'s run loop) which then is translated and passed to the appropriate `NSView` by that `NSWindow`. The connection to the window server, `CGSConnection` is actually explicit in all these API, and must be created by `AppKit` for each thread that wants to manage on-screen elements. Each connection is recorded by the server in an identifier-based lookup table, and upon each call to the server, its originating connection\'s rights are validated for each resource modified or accessed by that call. `SkyLight` actually uses **Mach Interface Generator (MIG)** to marshall these calls, and connections are actually just composed of a server request mach port and an on-demand client notification/event port. In **Core Animation**, however, `CAContext` doesn\'t handle any drawing or rendering control itself, instead delegating this to its root `CALayer`. It does control inter-context ordering (i.e. ordering root layers relative to all other on-screen root layers) and event routing when initialized connected to a remote window server instead of initialized as a local rendering context. So, CA windows (contexts) are equivalent to SkyLight windows, but while one SkyLight connection can control many windows, one CA connection may only control one CA window (context). In a way though, for quite some time now, `AppKit` internal/private API has slowly been modernized to match **Core Animation**, with functions like `NSWindowMark` mimicking `CALayerMark` along with the recent addition of transactions. (With `CGPixelAccess` and direct `CGContext` drawing, `SkyLight` actually has an analogous concept to `CABackingStore`; `CA::Shape` too is essentially the same as `CGSRegionObj`/`CGRegion`.)\\n\\nAnyways, the next steps for this project include adding `CADynamicsBehavior` (probably hard, requiring `box2d` or `PhysicsKit` integration), `CAStateController` (likely easy), `CAPresentationModifier` (likely easy), and `CAML` and `CAPackage` support (likely easy... if using `NSXMLParser`). Though they\'ve since been removed from **Core Animation**, `CALight` and related lighting filters did used to exist, roughly matching SVG\'s `feDiffuseLighting` and `feSpecularLighting`, for example. They were meant to be used with `CAMeshTransform`, which is also currently unimplemented. In summary, as you can see, there\'s a lot of private and some public API that are yet unimplemented, even though the groundwork has been laid. Take a look at the implementation details -- I\'m sure you\'ll find them interesting, as they\'re mostly faithful to the original (decompiled) C++ implementation!"},{"id":"/2018/03/22/","metadata":{"permalink":"/blog/2018/03/22/","source":"@site/blog/2018-03-22.md","title":"An Exercise in Modern Cocoa Views","description":"Like I said in the previous \\"episode\\", recently, I\'ve wanted to get around to adding \\"hot key\\" support for Parrot, and realized I didn\'t like any of the existing solutions:","date":"2018-03-22T00:00:00.000Z","formattedDate":"March 22, 2018","tags":[],"readingTime":42.36,"truncated":true,"authors":[],"frontMatter":{},"prevItem":{"title":"DIY: Core Animation","permalink":"/blog/2019/02/19/"},"nextItem":{"title":"Building a Better RegisterEventHotKey","permalink":"/blog/2018/03/16/"}},"content":"Like I said in the previous \\"episode\\", recently, I\'ve wanted to get around to adding \\"hot key\\" support for Parrot, and realized I didn\'t like any of the existing solutions:\\n\\n1. Use `MASShortcut` or `ShortcutRecorder` which are tried and proven to work in ObjC-land.\\n2. Use a new but not proven Swift hotkey recorder (there\'s a few out there).\\n3. Roll my own (probably somehow using dangerous private SPI) and not test it at all! \\n\\n*Obviously I went with option #3.* \\n\\nAnd here we are now, onto part two of the thrilling saga in which you witness me breaking AppKit and WindowServer and inviting the wrath and fury of the engineers that work on said components. I hope you brought your popcorn. \\n\\n\x3c!--truncate--\x3e\\n\\nI\'d like to clarify that we\'ll only be building a single self-contained control that manages a single shortcut. I expect Parrot, like most apps, will not need a Command Editor like Final Cut Pro, which is purpose-built for video editors with more than two keyboards and more than two hands to match, clearly.\\n\\n![Final Cut Pro Command Editor](assets/finalcut-keyboard.jpg)\\n\\nOur end result will look, sound, and feel something like this, instead:\\n\\n![KeyboardShortcutView](assets/shortcut-recorder.gif)\\n\\nBefore we get into the nitty gritty hand-holding pair-programming stuff, if you\'d like to jump straight to the comment-annotated final source code, [I\'ve included a snapshot here.](https://gist.github.com/avaidyam/32975976c23dd3b38336f22d971f5eaa) It\'s the whole final product, exactly 1500 LOC, including the code from the previous \\"episode\\" - the corresponding keyboard shortcut facility! If you think this should be a formal repository and whatnot, contact me on Twitter or Github @avaidyam!\\n\\n## Principles of Modern Views\\n\\n### Subclassing a `View` or a `ViewController`\\n\\nThe first question we should answer is, what kind of component are we building? The answer to this question is what determines what kind of a subclass we are, as well as the interaction model we have with other components in our app. \\n\\nWhen you\'re building a discrete component that takes a program input and presents a display to the user, and in the case of a control, receives user input and presents a program output, you should be subclassing a `View`. Anything beyond that should be a subclass of a `ViewController`, a component that mediates interactions between other components, or a component that handles model/database objects, or really just anything else. A `View` should be easily reusable in other contexts outside of the one you\'re building in immediately, but a `ViewController` is not necessarily capable of fulfilling this contract. \\n\\nFor example, a contact avatar would best be a `View` subclass, but a contact avatar **picker** should be a `ViewController`, as it not only displays an avatar image, but it also allows the user to select an image, and might handle the synchronization with the contact store (maybe it\'s a JSON file, maybe it\'s a remote API, or maybe it\'s a `CNContact`). \\n\\nOn macOS, you should also consider subclassing an `WindowController` if the component you\'re building both composes other components (like a `ViewController`) and is self-contained in a `Window` -- a contact avatar picker may not fit this criteria, but a contact **editor panel** would, where the contact avatar picker would be a `ViewController` nested within, alongside name, phone, email, and other editable fields.\\n\\n### Layers\\n\\nWhile `AppKit` is often seen as a dinosaur compared to its younger sibling, `UIKit`, it\'s important to know that nearly all the design patterns that `UIKit` sports came from `AppKit`, and if not, they eventually make their way back into `AppKit`, with the exception of a very limited few. For example, the concept of a `UIView` being backed by an underlying `CALayer` type is very similar to how `NSControl` is (rather, used to be?) backed by `NSCell`. The differences being that the `CALayer` is actually driving the rendering of display content instead of the `UIView`, and that `NSCell` acts as a \\"rubber stamp\\" for specific event handling and drawing. \\n\\nWhen it comes to layer-backed views, `AppKit` actually has several modes by which to achieve this: \\n1. **Layer-hosting:** \\n    * `self.layer = CALayer(); self.wantsLayer = true`\\n    * The `NSView` owns the `CALayer` and is responsible for creating and managing it; `NSView` does nothing except create its rendering surface.\\n2. **Implicit Layer-backed and drawn:** \\n    * `superview.wantsLayer = true`\\n    * The `NSView` has an explicitly layer-backed parent and will grant itself a private `CALayer` to draw into, using the rendering surface of the layer-backed parent\'s `CALayer`.\\n3. **Implicit Superview Layer-drawn:** \\n    * `superview.wantsLayer = true; superview.canDrawSubviewsIntoLayer = true`\\n    * **If you expect to use animations or any layer-related properties, you must opt out of this!**\\n    * The `NSView` has an explicitly layer-backed parent whose `canDrawSubviewsIntoLayer` is true, and thus, will not grant itself a `CALayer`, and instead draw directly into the layer-backed parent\'s `CALayer`. \\n4. **Explicit Layer-backed and drawn:** \\n    * `self.wantsLayer = true`\\n    * The `NSView` has explicitly declared itself as layer-backed and will set its layer\'s `contents` with the result of its `drawRect:` call (that is, drawing directly into the layer).\\n    * If this view declares that it `canDrawSubviewsIntoLayer`, its subviews are rendered into this view\'s `layer`. \\n5. **Explicit Layer-backed:** \\n    * `self.wantsLayer = true; self.wantsUpdateLayer = true; self.layerContentsRedrawPolicy = .onSetNeedsDisplay`\\n    * *Note: you must actually override the `wantsUpdateLayer` function in your custom `NSView` subclass to achieve this, as there is no setter for the property. This property is queried at each view update cycle, if the view is marked dirty - don\'t attempt any complex computations here.*\\n    * The `NSView` has explicitly declared itself as layer-backed and that it will not `drawRect:` into the layer. Instead, the layer is manually managed, **but not owned by the subview**, during the `updateLayer` method.\\n    * It\'s important to set `layerContentsRedrawPolicy` to `.onSetNeedsDisplay` here, since the `layer.contents` are no longer dependent on your `drawRect:`.\\n\\n*Note: where I say \\"rendering surface\\", the underlying type is either a `CAContext`, which is used by the WindowServer to render your layers out-of-process, **or** by `CAViewRef` which can be thought of as a wrapper around `CA::Render::*`, which is rendered in-process but likely off the main thread.*\\n\\nPersonally, I think the `NSView.layer` property should never have been public; instead, if layer-hosting, it\'s the view\'s responsibility to keep a strong reference to its layer, and in explicit `updateLayer` views, the `updateLayer` method signature should have been `- (void)updateLayer:(CALayer *)layer`, so as to pass in the `AppKit`-owned layer for the view to update. Too many iOS developers mistake `NSView` for being identical to `UIView`, where it\'s almost even orthogonal to it depending on the scenario. `UIView`\'s layer ownership model is most closely represented by layer-hosting, but in AppKit, this means layer hierarchies and other view facilities are not managed for you, and so, the closest to it would be explicit layer-backed. This is the approach we\'ll be taking. It may appear that you won\'t be able to use `drawRect:`, but there are ways to work around that, as we\'ll see soon.\\n\\n### `NSControl`?\\n\\nThe next question we need to tackle is, should we design a subclass of `NSControl` or `NSView`? In this specific instance, the answer is pretty straight forward, as we\'re designing a control, it makes the most sense to take advantage of `NSControl`... it\'s in the name, after all. \\n\\nHowever, here\'s a few things you\'ll want to consider:\\n* **`NSCell`:** Because this class has been soft-deprecated, it\'s pretty safe to assume `NSControl`s can be written without a corresponding cell (spoiler alert: yep).\\n* **Polymorphic `*Value` Properties:** `NSControl` has several `*Value` properties, like `objectValue`, and `take*ValueFrom(_:)` methods to go along with them, for use in Interface Builder and Cocoa Bindings. These aren\'t really that helpful, from my experience, and if they were, re-implementing them for `NSView` classes isn\'t that hard.\\n* **Field Editors:** This is another of those `NeXT`-era ideas, where instead of loading say, a hundred, heavyweight `NSTextView`s into a window, which would kill performance and memory, you would only load one, and share it across a hundred lightweight `NSTextFieldCell`s. It doesn\'t make much of a difference in 2018, especially since your memory and performance competition are Electron apps: **as long as you don\'t use Electron (or develop in JS for Desktop apps), you\'re winning.**\\n* **Target/Action Model:** This is what we know and love `NSControl` (and `UIControl`) for! A control has a target, and an action that fires on that target, when the control has been activated somehow. `UIControl` goes a step further, allowing you to register different targets for different event types, but `NSControl` offers a single condition-setting `sendAction(on:)` version. It\'s arguable which is more convenient.\\n\\nIn summary, there\'s a few reasons to use or not use `NSControl`, but after weighing out the options, a standard of conformity in being a \\"control,\\" and just having the target/action model already implemented for you is pretty helpful, so we\'ll go with that.\\n\\n## Working With `CGSKeyboardShortcut`\\n\\n### Human-Readable String Representation\\n\\nBefore we begin building a user-facing control, we need to make sure `CGSKeyboardShortcut` and friends can be translated to a human-readable string representation. This is because modifiers and virtual key codes that compose a shortcut like `\u2318D` are device-independent mechanism, and when registering a shortcut, we can\'t use a string containing the shortcut. It\'s important to note that virtual key codes are not ASCII-ordered (that is, sequential in the ASCII table), and may not always have a corresponding glyph to match the key. To determine what the virtual key code points to on the current keyboard, we unfortunately have to return to `Carbon.framework` for *Text Input Services* (`TIS`) and *Unicode Utilities* (`UC`). To translate the key code, we grab the current input source\'s keyboard layout, and use the `UCKeyTranslate` facility to determine what the unicode character resulting from pressing this key in the current layout will be. There are a few special cases like Fn keys that print `F13`, for example, or the spacebar, which we want to print `Space`.\\n\\n*Cocoa key equivalents, used by `NSMenu` and `NSButton`, for example, internally translate a string containg `\\"x\\"` into the right virtual key code; this is left as an exercise for the reader. Hint: just create a reverse mapping table and look it up!*\\n\\n```swift\\npublic extension CGKeyCode {\\n    public var isFunctionKey: Bool {\\n        switch Int(self) {\\n        case kVK_F1, kVK_F2, kVK_F3, kVK_F4, kVK_F5, kVK_F6, kVK_F7, kVK_F8,\\n             kVK_F9, kVK_F10, kVK_F11, kVK_F12, kVK_F13, kVK_F14, kVK_F15,\\n             kVK_F16, kVK_F17, kVK_F18, kVK_F19, kVK_F20:\\n            return true\\n        default:\\n            return false\\n        }\\n    }\\n\\n    public var characters: String {\\n        if let special = CGKeyCode._special[Int(self)] { return special }\\n        \\n        let source = TISCopyCurrentASCIICapableKeyboardLayoutInputSource().takeUnretainedValue()\\n        let layoutData = TISGetInputSourceProperty(source, kTISPropertyUnicodeKeyLayoutData)\\n        let dataRef = unsafeBitCast(layoutData, to: CFData.self)\\n        let keyLayout = unsafeBitCast(CFDataGetBytePtr(dataRef), to: UnsafePointer<CoreServices.UCKeyboardLayout>.self)\\n        \\n        let keyTranslateOptions = OptionBits(CoreServices.kUCKeyTranslateNoDeadKeysBit)\\n        var deadKeyState: UInt32 = 0\\n        let maxChars = 256\\n        var chars = [UniChar](repeating: 0, count: maxChars)\\n        var length = 0\\n        \\n        let error = CoreServices.UCKeyTranslate(keyLayout, self,\\n                                                UInt16(CoreServices.kUCKeyActionDisplay),\\n                                                0, UInt32(LMGetKbdType()),\\n                                                keyTranslateOptions, &deadKeyState,\\n                                                maxChars, &length, &chars)\\n        \\n        if error != noErr { return \\"\\" }\\n        return NSString(characters: &chars, length: length).uppercased\\n    }\\n    private static var _special: [Int: String] = [...]\\n}\\n\\npublic extension CGEventFlags {\\n    public var characters: String {\\n        var string = \\"\\"\\n        if self.contains(.maskAlphaShift) { string.append(\\"\u21ea\\") }\\n        if self.contains(.maskHelp) { string.append(\\"?\u20dd\\") }\\n        if self.contains(.maskControl) { string.append(\\"\u2303\\") }\\n        if self.contains(.maskAlternate) { string.append(\\"\u2325\\") }\\n        if self.contains(.maskShift) { string.append(\\"\u21e7\\") }\\n        if self.contains(.maskCommand) { string.append(\\"\u2318\\") }\\n        return string\\n    }\\n}\\n\\npublic extension NSEvent.ModifierFlags {\\n    public var characters: String {\\n        return CGEventFlags(self).characters\\n    }\\n}\\n```\\n*Portions of this code are copyright \xa9 2016 Shunsuke Furubayashi, author of the `Magnet` library.*\\n\\n### A Simpler Shortcut Representation\\n\\nBecause we don\'t want to lock ourselves into `CGSKeyboardShortcut`, and we don\'t exactly manage state like `identifier` or `acquisitionPolicy`, which are more within-app intrinsics, we\'ll define a new, simpler type: `KeyboardShortcutView.Pair = (CGKeyCode, CGEventFlags)`, and create two wrapper functions to transform it to and from an `NSDictionary`. This is important because we\'ll need to be able to encode and decode it for state restoration and `NSCoding`.\\n\\n```swift\\nopen class KeyboardShortcutView: NSControl, ... {\\n    public typealias Pair = (keyCode: CGKeyCode, modifierFlags: CGEventFlags)\\n}\\n\\npublic func representation(of pair: KeyboardShortcutView.Pair?) -> NSDictionary? {\\n    guard let pair = pair else { return nil }\\n    return [\\n        \\"keyCode\\": pair.keyCode,\\n        \\"modifierFlags\\": pair.modifierFlags.rawValue\\n    ] as NSDictionary\\n}\\npublic func representation(of dict: NSDictionary?) -> KeyboardShortcutView.Pair? {\\n    guard let dict = dict as? [String: Any],\\n        let kc = dict[\\"keyCode\\"] as? CGKeyCode,\\n        let mf = dict[\\"modifierFlags\\"] as? CGEventFlags.RawValue\\n        else { return nil }\\n    return (kc, CGEventFlags(rawValue: mf))\\n}\\n```\\n\\nWith that, we have a facility to converse with other keyboard shortcut libraries or non-Swift objects, like `UserDefaults`. *(Recall that tuples cannot conform to `Codable`!)*\\n\\n## Being A Good Citizen\\n\\nWe\'ll have our recorder control compose a label (`NSTextField`) and a record/stop button (`NSButton`):\\n\\n```swift\\nopen class KeyboardShortcutView: NSControl, ... {\\n\\n    /*@objc*/ open weak var delegate: KeyboardShortcutViewDelegate? {\\n        willSet { self.willChangeValue(forKey: #function) }\\n        didSet { self.didChangeValue(forKey: #function) }\\n    }\\n    \\n    @objc open override var alignment: NSTextAlignment {\\n        get { return self.textLabel.alignment }\\n        set { self.textLabel.alignment = newValue }\\n    }\\n    \\n    @objc open var tintColor: NSColor = .keyboardFocusIndicatorColor {\\n        didSet { /* ... */ }\\n    }\\n    @objc open var placeholderString: String? {\\n        get { return self.textLabel.placeholderAttributedString?.string }\\n        set {\\n            let style = NSMutableParagraphStyle()\\n            style.alignment = self.alignment\\n            let attr = NSAttributedString(string: newValue ?? \\"\\", attributes: [\\n                .foregroundColor: NSColor.secondaryLabelColor,\\n                .paragraphStyle: style\\n            ])\\n            self.textLabel.placeholderAttributedString = attr\\n        }\\n    }\\n    \\n    @objc open override var isEnabled: Bool {\\n        didSet { /* .. */ }\\n    }\\n    \\n    open override var isHighlighted: Bool {\\n        // ...\\n    }\\n    \\n    private lazy var clearButton: NSButton = {\\n        let button = NSButton()\\n        button.wantsLayer = true\\n        button.translatesAutoresizingMaskIntoConstraints = false\\n        button.image = NSImage(named: .stopProgressTemplate)\\n        button.bezelStyle = .texturedRounded // for template image rendering\\n        button.setButtonType(.momentaryChange)\\n        button.isBordered = false\\n        button.title = \\"\\"\\n        button.target = self\\n        button.action = #selector(self.buttonAction(_:))\\n        return button\\n    }()\\n    \\n    private lazy var textLabel: NSTextField = {\\n        let label = NSTextField()\\n        label.wantsLayer = true\\n        label.translatesAutoresizingMaskIntoConstraints = false\\n        label.isEditable = false\\n        label.isSelectable = false\\n        label.isContinuous = false\\n        label.isEnabled = true\\n        label.textColor = self.tintColor\\n        label.backgroundColor = .clear\\n        label.refusesFirstResponder = true\\n        label.drawsBackground = false\\n        label.isBezeled = false\\n        label.lineBreakMode = .byClipping\\n        label.setValue(true, forKey: \\"ignoreHitTest\\")\\n        return label\\n    }()\\n\\n    public override init(frame frameRect: NSRect) {\\n        super.init(frame: frameRect)\\n        self.commonInit()\\n    }\\n\\n    public required init?(coder: NSCoder) {\\n        super.init(coder: coder)\\n        self.commonInit()\\n    }\\n    \\n    private func commonInit() {\\n        self.wantsLayer = true\\n        self.layerContentsRedrawPolicy = .onSetNeedsDisplay\\n        self.translatesAutoresizingMaskIntoConstraints = false\\n        self.addSubview(self.clearButton)\\n        self.addSubview(self.textLabel)\\n        self.isEnabled = true // NSControl.isEnabled is false by default.\\n        self.alignment = .center\\n    }\\n}\\n```\\n\\nThis bit of code is pretty basic subview setup, and we\'re using lazy initialization for our views, but it\'s not necessary to do so. In addition, we\'ve added or overridden some properties that forward into our `subviews` or to our `superclass`. Remember to always set `wantsLayer`, `layerContentsRedrawPolicy` **and definitely never forget `translatesAutoresizingMaskIntoConstraints` or you will cry.** Notice that we didn\'t touch constraints in our `commonInit()`, and I\'ll explain why soon.\\n\\nSpeaking of that, there\'s a particular side effect of invoking setters in `commonInit()` versus in the initializer itself: it allows us to call the `didSet` on the property! Just be aware of that, and double check that there are no unintended side effects in your `didSet`s. Note the `will/didChangeValue` in our properties, though - we used `#function` as the key path, but these aren\'t the magical Swift `KeyPath`s (like `\\\\.isRecording`) we got in Swift 4.1! What gives? It actually is because we aren\'t able to mark our properties as `@objc` because they aren\'t able to be represented in ObjC. As a workaround, we\'re able to get the ObjC `KeyPath` stuff working, but it\'s by no means a good solution. If you have a better solution, let me know!\\n\\nTake note that we have to wrap the `placeholderString` in an `NSAttributedString` because the default label color is way too dim/translucent and therefore hard to read. This causes an unintended non-updating effect: `alignment` should be set before setting `placeholderString`, because we\'re not updating the `placeholderString`\'s `paragraphStyle`\'s `alignment` in `updateLayer`, and so `placeholderString`, if set only once, uses the exact value given to it at that time.\\n\\nA few more notes about the subviews:\\n  * `ignoreHitTest` is a **Private SPI**! We need it though, because without this flag, the label steals our firstMouse/responder status. If you would rather *not* do this, subclass `NSTextField` and override `hitTest:` to return `nil`. It has the same effect.\\n  * To render template images (that is, `NSImage`s whose `isTemplate` is `true`, or their name ends with `Template`) in the current `NSAppearance`, `NSButton` has to be a textured style. This adds a little bit of padding around the button, so we\'ll take that into account when working with constraints.\\n\\nSince we\'ll also be using the `NSControl` target/action model, our `delegate` should primarily be for decision-making. If we wanted to focus on notification of control state, it\'s better to use `NSNotificationCenter`, which some Cocoa text classes do.\\n\\n```swift\\npublic protocol KeyboardShortcutViewDelegate: class {\\n    func keyboardShortcutViewShouldBeginRecording(_ keyboardShortcutView: KeyboardShortcutView) -> Bool\\n    func keyboardShortcutView(_ keyboardShortcutView: KeyboardShortcutView,\\n                              canRecordShortcut shortcut: KeyboardShortcutView.Pair) -> Bool\\n    func keyboardShortcutViewDidEndRecording(_ keyboardShortcutView: KeyboardShortcutView)\\n}\\n```\\n\\nThere - now we have a pretty effective API client interface to determine what the control should do in a given situation, along with a visual foundation.\\n\\n### Accepting Key View\\n\\nThe important part of a control is to allow the user to activate and deactivate it, which we\'ll do by just clicking within or outside of the control bounds. It\'s very easy to allow becoming the key view or first responder:\\n\\n```swift\\nopen override var acceptsFirstResponder: Bool {\\n    return self.isEnabled\\n}\\n\\nopen override var canBecomeKeyView: Bool {\\n    return super.canBecomeKeyView && NSApp.isFullKeyboardAccessEnabled\\n}\\n\\nopen override var needsPanelToBecomeKey: Bool {\\n    return true\\n}\\n\\nopen override func acceptsFirstMouse(for event: NSEvent?) -> Bool {\\n    return true\\n}\\n\\nopen override func performClick(_ sender: Any?) {\\n    self.window?.makeFirstResponder(self)\\n}\\n```\\n\\nThat\'s all you need to do! Now, clicking inside the control will give us key input, which we\'ll focus on in the next section. \\n\\n### Responding to User Input\\n\\nThis is the meat of the control: actually recording the shortcut. The first thing we should do is get our `isEnabled`, `isHighlighted`, `isRecording` properties correctly wired together. We shouldn\'t be able to set our highlight state because that\'s for the user to do; instead, wire its getter through to `isRecording`. The two main properties are `shortcut` and `inputModifiers`, the latter of which we\'ll use to track which modifier flags are set when the user is entering the shortcut. When setting the `shortcut`, we\'ll use the `NSControl` target/action mechanism to send our `action` to our `target`. If we don\'t have a defined `target` (that is, it\'s `nil`), the message travels up the responder chain automatically! If the client (instead of the user) sets the `shortcut` directly, it\'ll still trigger the action, so keep that in mind - the solution to this is to wrap it in an `if self.isRecording`, but in this case, it\'s the behavior we might want.\\n\\n```swift\\n@objc open override var isEnabled: Bool {\\n    didSet {\\n        if !self.isEnabled { self.endRecording() }\\n    }\\n}\\n\\nopen override var isHighlighted: Bool {\\n    get { return self.isRecording }\\n    set { }\\n}\\n\\n@objc open private(set) var isRecording = false {\\n    willSet { self.willChangeValue(forKey: #function) }\\n    didSet { self.didChangeValue(forKey: #function) }\\n}\\n/*@objc*/ open var shortcut: KeyboardShortcutView.Pair? {\\n    willSet {\\n        guard self.shortcut?.keyCode != newValue?.keyCode &&\\n            self.shortcut?.modifierFlags != newValue?.modifierFlags else { return }\\n        self.willChangeValue(forKey: #function)\\n    }\\n    didSet {\\n        guard self.shortcut?.keyCode != oldValue?.keyCode &&\\n            self.shortcut?.modifierFlags != oldValue?.modifierFlags else { return }\\n        \\n        _ = self.sendAction(self.action, to: self.target)\\n        \\n        // ...\\n        self.didChangeValue(forKey: #function)\\n    }\\n}\\n\\nprivate var inputModifiers: NSEvent.ModifierFlags = [] {\\n    didSet {\\n        // ...\\n    }\\n}\\n```\\n\\nNow we\'ll have to actually handle mouse activation and keyboard events:\\n\\n```swift\\nopen override func mouseDown(with event: NSEvent) {\\n    guard self.isEnabled else {\\n        super.mouseDown(with: event); return\\n    }\\n\\n    let locationInView = self.convert(event.locationInWindow, from: nil)\\n    if self.mouse(locationInView, in: self.bounds) && !self.isRecording {\\n        self.inputModifiers = []\\n        _ = self.beginRecording()\\n    } else {\\n        super.mouseDown(with: event)\\n    }\\n}\\n```\\n\\nIf we\'re enabled, and the mouse press was within our bounds, reset our recording state and begin recording. Next, if our `flagsChanged(with:)` is called, change our input modifiers state (and we\'ll cover soon how that reflects in the UI). The easy thing about writing a shortcut recorder is that we can use `performKeyEquivalent(with:)`! It\'s called when a \\"key equivalent\\" *(read: \\"keyboard shortcut\\")* is pressed and we\'re first responder. This basically has already taken care of all the work for us, and we just need to validate the new shortcut with the delegate and end recording.\\n\\n```swift\\nopen override func performKeyEquivalent(with event: NSEvent) -> Bool {\\n    if !self.isEnabled || !self.isRecording { return false }\\n    if self.window?.firstResponder != self { return false }\\n    let shortcut = (keyCode: CGKeyCode(event.keyCode),\\n                    modifierFlags: CGEventFlags(event.modifierFlags))\\n    \\n    // inline validation func if we have no delegate response:\\n    func validate() -> Bool {\\n        guard !shortcut.keyCode.isFunctionKey else { return true }\\n        return !shortcut.modifierFlags.intersection(.maskUserFlags).isEmpty\\n    }\\n    \\n    let del = (self.delegate ?? self.target as? KeyboardShortcutViewDelegate)\\n    if del?.keyboardShortcutView(self, canRecordShortcut: shortcut) ?? validate() {\\n        self.shortcut = shortcut\\n        self.endRecording()\\n        return true\\n    }\\n    return false\\n}\\n\\nopen override func flagsChanged(with event: NSEvent) {\\n    self.inputModifiers = self.isRecording ? event.modifierFlags : []\\n    super.flagsChanged(with: event)\\n}\\n```\\n\\nIf we don\'t have a `delegate`, we\'ll check if our `target` is *also* capable of being our `delegate` -- this is mostly convenience, kinda like how you have a `delegate` and a `dataSource` for a collection or table view, but usually it\'s one view controller implementing both. If neither the `delegate` or `target` can help us validate the input, we\'ll just allow it to go through as long as it\'s not a single non-Fn key (that is, you shouldn\'t allow just `Q` as a hot key: that would lead to a lot of problems!).\\n\\n```swift\\nopen override func keyDown(with event: NSEvent) {\\n    guard !self.performKeyEquivalent(with: event) else { return }\\n    super.keyDown(with: event)\\n}\\n\\nopen override func resignFirstResponder() -> Bool {\\n    self.endRecording()\\n    return true\\n}\\n```\\n\\nAnd with that, we\'ve completed handling our event handling: if we get a stray `keyDown(with:)` message, just invoke `performKeyEquivalent(with:)`, as this can occur in the case described before, where a single non-Fn key is pressed. Again, **allowing this is bad practice and interferes with system keyboard input!** But who are we to judge, right? \\n\\nThe recording actions take place primarily in `beginRecording()` and `endRecording()`; we could have just placed the body of these methods in `isRecording.didSet` but that would be very very bloated and inappropriate code style. Be sure to handle state correctly and guard against out-of-place calls to these methods, as that can lead to unexpected user-visible state leakage. \\n\\n```swift\\npublic func beginRecording() -> Bool {\\n    if !self.isEnabled { return false }\\n    if self.isRecording { return true }\\n    \\n    let del = (self.delegate ?? self.target as? KeyboardShortcutViewDelegate)\\n    guard del?.keyboardShortcutViewShouldBeginRecording(self) ?? true else {\\n        NSSound.beep(); return false\\n    }\\n    self.isRecording = true\\n    return true\\n}\\n\\npublic func endRecording() {\\n    if !self.isRecording { return }\\n    self.inputModifiers = []\\n    self.isRecording = false\\n    \\n    if self.window?.firstResponder == self && !self.canBecomeKeyView {\\n        self.window?.makeFirstResponder(nil)\\n    }\\n    let del = (self.delegate ?? self.target as? KeyboardShortcutViewDelegate)\\n    del?.keyboardShortcutViewDidEndRecording(self)\\n}\\n```\\n\\nIt\'s pretty self-explanatory, as all we do is consult (or notify) the `delegate`/`target`, and fallback to the assumption that we are allowed to record, if none are available. When we `resignFirstResponder()` or `endRecording()`, we end up calling the opposite method, but these calls aren\'t re-entrant as `NSWindow.makeFirstResponder(_:)` does the verification for us. Finally, we just need to wire up the `clearButton` action to perform the context-specific thing: if we\'re not recording but we don\'t have a set `shortcut`, `beginRecording()`; if we **do** have a set `shortcut`, clear it and end recording. Otherwise, we\'re already recording - `endRecording()` without losing the previously set `shortcut`, if any.\\n\\n```swift\\n@objc private func buttonAction(_ button: NSButton) {\\n    if !self.isRecording && self.shortcut == nil { // cleared state\\n        self.window?.makeFirstResponder(self)\\n        _ = self.beginRecording()\\n    } else if self.isRecording && self.shortcut != nil { // cleared state\\n        self.endRecording()\\n    } else {\\n        if self.shortcut != nil { self.shortcut = nil }\\n        self.endRecording()\\n    }\\n}\\n```\\n\\n### `updateLayer`\\n\\nLet\'s take a brief moment to provide a convenience function for visually representing the whole shortcut to the user: \\n\\n```swift\\nprivate var stringRepresentation: String {\\n    var modifiers: NSEvent.ModifierFlags = self.inputModifiers\\n    if self.isRecording {\\n        return modifiers.characters\\n    } else {\\n        if let shortcut = self.shortcut {\\n            modifiers.formUnion(NSEvent.ModifierFlags(shortcut.modifierFlags))\\n        }\\n        return modifiers.characters + (self.shortcut?.keyCode.characters ?? \\"\\")\\n    }\\n}\\n```\\n\\nIt\'s not too much: if we\'re recording, return the input modifers as a string, but if we\'re not, use the `shortcut`\'s `modifier.characters` **and** the input modifier\'s, together, along with the `keyCode` as a string at the very end. This will match the canonical string representation seen in `NSMenuItem`s. Since we\'re explicitly layer-backed and requesting `updateLayer`, we should definitely control our visual appearance here:\\n\\n```swift\\nopen override var allowsVibrancy: Bool {\\n    return false\\n}\\n\\nopen override var wantsUpdateLayer: Bool {\\n    return true\\n}\\n\\nopen override func updateLayer() {\\n    // ...\\n\\n    self.textLabel.textColor = self.isEnabled ? self.tintColor : .disabledControlTextColor\\n    \\n    let str = self.stringRepresentation\\n    self.textLabel.stringValue = str\\n    self.toolTip = Localized.tooltipPrefix + \\": \\" + (str.isEmpty ? Localized.noShortcut : str)\\n                    + \\"\\\\n\\\\n\\" + Localized.help\\n    \\n    self.clearButton.isEnabled = self.isEnabled\\n    let canStop = self.isRecording || self.shortcut != nil\\n    self.clearButton.image = NSImage(named: canStop ? .stopProgressFreestandingTemplate\\n                                                    : .statusUnavailable)\\n}\\n```\\n\\nYou\'ll notice we set the `tooltip` here as well. It\'s important to do so per-view, or if we\'re drawing specific regions with different tooltips, we can use `addToolTipRect...` and friends; these are hover-based context clues as to what the view under the mouse provides, and there\'s no iOS equivalent. For now, ignore the `Localized...` values, as we\'ll talk about that later.\\n\\nAdd a `self.needsDisplay = true` call to the `didSet` of the properties: `tintColor`, `shortcut`, `isEnabled`, and `inputModifers`. This will mark the view as needing `updateLayer()` called, which we can then update visual appearances in.\\n\\n### Drawing a Button Without Being One\\n\\nAn important thing to do in designing and implementing a new control is to **always look and feel like a system control!** It\'s very obvious to a user when an app doesn\'t do this and it provides the perception of a cheap or poorly designed app, leading to possible user dissatisfaction. For this control, let\'s act like a mix between a button and text input, because we act like a mix between the two. A good example of a control that already has this appearance is an `NSSearchField` in an `NSToolbar` (in a regular `NSView`, it looks recessed, but in the toolbar it has a button-like appearance). Instead, however, we\'ll steal the appearance of an `NSButton` directly using an `NSButtonCell`. Like I said much earlier in the article, `NSCell`s encapsulate both event-handling *and* visual appearance, without being an actual view! We can quite simply share a button cell between all instances of our control and draw it into a sublayer in `updateLayer()`, using the `drawBezel(withFrame:in:)` method. Be sure to add the sublayer to our hierarchy and set the correct `bezelStyle`.\\n\\n```swift\\nprivate static var stampCell: NSButtonCell = {\\n    let c = NSButtonCell()\\n    c.bezelStyle = .texturedRounded\\n    return c\\n}()\\n\\nprivate lazy var underlayer = CALayer()\\n\\nprivate func commonInit() {\\n    // ...\\n    self.layer?.addSublayer(self.underlayer)\\n    // ...\\n}\\n\\nopen override func updateLayer() {\\n    var b = self.bounds.size; b.height = 22\\n    let img = NSImage(size: b, flipped: false) { r in\\n        KeyboardShortcutView.stampCell.drawBezel(withFrame: r, in: self)\\n        return true\\n    }\\n    \\n    CATransaction.begin()\\n    CATransaction.setDisableActions(true)\\n    self.underlayer.contents = img\\n    self.underlayer.contentsScale = self.layer!.contentsScale // inherit\\n    self.underlayer.contentsCenter = CGRect(x: 0.25, y: 0.25, width: 0.5, height: 0.5)\\n    CATransaction.commit()\\n\\n    // ...\\n}\\n\\nopen override func layout() {\\n    super.layout()\\n\\n    CATransaction.begin()\\n    CATransaction.setDisableActions(true)\\n    self.underlayer.frame = self.layer!.bounds\\n    CATransaction.commit()\\n\\n    // ...\\n}\\n```\\n\\n*`-[NSButtonCell updateLayerWithFrame:inView:]` actually uses a private `NSLayerContentsFacet` and CoreUI to optimize drawing `CALayer` contents, but it\'s a non-issue for us.*\\n\\nIf we could use `drawRect:` it might be more straight forward, but we lose the ability to set the `CALayer.contentsCenter` which automatically does 9-part image slicing for us, if the `underlayer` frame and the `content` size don\'t match up. You might notice that if you just set `layer.frame`, it\'ll animate and look weird as it snaps into a new frame, where we don\'t expect this to occur. To fix this, we just open an explicit sub-transaction, which disables `CALayer` actions. Another possible approach to avoid `frame` implicit animations is to modify the layer\'s `actions` dictionary:\\n\\n```swift\\nvar implicits = layer.actions\\nimplicits[\\"position\\"] = NSNull()\\nimplicits[\\"bounds\\"] = NSNull()\\nlayer.actions = implicits\\n```\\n\\nAnother small visual issue is that the `NSCell` we\'re drawing has no understanding of the control\'s `effectiveAppearance`, unless we tell it using `NSAppearance.current`:\\n\\n```swift\\nopen override func updateLayer() {\\n    // ...\\n    let img = NSImage(size: b, flipped: false) { r in\\n        self.effectiveAppearance.using {\\n            KeyboardShortcutView.stampCell.drawBezel(withFrame: r, in: self)\\n        }\\n        return true\\n    }\\n    // ...\\n}\\n\\n// ...\\n\\npublic extension NSAppearance {\\n    public func using(_ handler: () -> ()) {\\n        let x = NSAppearance.current\\n        NSAppearance.current = self\\n        handler()\\n        NSAppearance.current = x\\n    }\\n}\\n```\\n\\nNow, if you set the whole `window`\'s `appearance` to, say, `vibrantDark`, the control will render perfectly no matter what size, in that appearance! (It\'s a little baffling to me that `NSButton`s don\'t stretch their drawing, but oh well.)\\n\\n### Focus Rings\\n\\nNow, as a control that can become key and first responder in its `window`, we should inform the user that we have done so using a focus ring. After macOS Lion, we no longer need to draw them ourselves, but instead provide their bounds and a mask to match our view\'s shape. Let\'s just ask our layer to render itself *as* a mask, since only the alpha channel is used for masking!\\n\\n```swift\\nopen override var focusRingMaskBounds: NSRect {\\n    return (self.isEnabled && self.window?.firstResponder == self) ? self.bounds : .zero\\n}\\n\\nopen override func drawFocusRingMask() {\\n    guard self.isEnabled && window?.firstResponder == self else { return }\\n    self.underlayer.render(in: NSGraphicsContext.current!.cgContext)\\n}\\n```\\n\\nNow we just need to add a `self.noteFocusRingMaskChanged()` call to `isEnabled.didSet`, so we can show and hide the focus ring automatically. `CALayer.render(in:)` isn\'t a great idea in most cases because it actually uses the `CG` rendering path, instead of the `OGL` or `Metal` rendering paths that Core Animation can use to accelerate layers on the GPU, and so it\'s actually a visual approximation to what the layer actually looks like. This doesn\'t really bother us because we only need the shape to be correct, though, but it\'s something to keep in mind in general when designing a view with sublayers.\\n\\n### `layout`, `updateConstraints`, & `intrinsicContentSize` \\n\\nBecause we have sublayers and subviews, we should adjust their layout here. We\'ve already taken care of `underlayer`, so now let\'s dynamically resize our `font` to match our control\'s height. It\'s surprisingly not straightforward, because the facility to do so is found on `NSFontManager` and not `NSFont`, but using the facility is pretty easy.\\n\\n```swift\\nopen override func layout() {\\n    // ...\\n    \\n    if let font = self.font {\\n        self.textLabel.font = NSFontManager.shared.convert(font, toSize: self.bounds.height / 1.7)\\n    } else {\\n        self.textLabel.font = NSFont.systemFont(ofSize: self.bounds.height / 1.7)\\n    }\\n}\\n```\\n\\nHere\'s where we finally set up and handle constraints! We\'ll use constraints to handle our subviews, because our sublayer just needs to match our frame. We could, however, add an `NSLayoutGuide` to our control, set up constraints on that guide, and then synchronize its frame to the sublayer frame, but it\'s not worth the trouble.\\n\\n```swift\\nopen override class var requiresConstraintBasedLayout: Bool {\\n    return true\\n}\\n\\nprivate var childConstraints: [NSLayoutConstraint] = []\\n\\nopen override func updateConstraints() {\\n    if self.childConstraints.count == 0 {\\n        self.childConstraints = [\\n            self.textLabel.leadingAnchor.constraint(equalTo: self.leadingAnchor, constant: 4.0),\\n            self.textLabel.trailingAnchor.constraint(equalTo: self.clearButton.leadingAnchor, constant: 0.0),\\n            self.clearButton.trailingAnchor.constraint(equalTo: self.trailingAnchor, constant: 0.0),\\n            self.clearButton.heightAnchor.constraint(equalTo: self.heightAnchor, multiplier: 1.0),\\n            self.clearButton.widthAnchor.constraint(equalTo: self.clearButton.heightAnchor, multiplier: 1.0),\\n            self.textLabel.centerYAnchor.constraint(equalTo: self.centerYAnchor, constant: -1.0),\\n            self.clearButton.centerYAnchor.constraint(equalTo: self.centerYAnchor),\\n        ]\\n        NSLayoutConstraint.activate(self.childConstraints)\\n    }\\n    super.updateConstraints()\\n}\\n```\\n\\nThe gist of it is, `updateConstraints()` is called post-initialization, and whenever we set `self.needsUpdateConstraints = true`, and if we haven\'t configured any constraints, we\'ll cache our constraints and activate them. It\'s helpful to do so in this method because we may, in the future, want to dynamically adjust our constraints, and we can do that in order with the layout and display cycle here.\\n\\nThe last thing we should do as a good citizen control, is provide an `intrinsicContentSize`: this is the size that our control will take up if we don\'t add any size constraints to it. Usually, it\'s just the smallest bounding box of the control\'s contents, which we can sum the `intrinsicContentSize`s of our `textLabel` and `clearButton` to find. Since there\'s a chance that they might provide a `.noIntrinsicMetric`, and our control *does* have intrinsic metrics for width (both `textLabel` and `clearButton` do, in fact), we should be cautious of that case. We\'ll factor in our padding from the constraints above as well.\\n\\n```swift\\nopen override var intrinsicContentSize: NSSize {\\n    var _t = self.textLabel.intrinsicContentSize\\n    var _b = self.clearButton.intrinsicContentSize\\n    if _t.width == NSView.noIntrinsicMetric { _t.width = 0.0 }\\n    if _b.width == NSView.noIntrinsicMetric { _b.width = 0.0 }\\n    \\n    // Compute the sum/max of the intrinsicContentSizes of our subviews.\\n    return NSSize(width: _t.width + _b.width + 12.0 /* padding */,\\n                  height: max(_t.height, _b.height) /* 22.0? */)\\n}\\n```\\n\\nWe could also take the approach that `NSButton` and similar controls take, which is to clamp the intrinsic size to `22px` in height. For a platform with a cursor, `22px` is the \\"right height\\" for a clickable control that contains a label, and for a platform that relies on touch input, it\'s between `32px` and `44px`. *(That\'s from the Apple HIG somewhere.)*\\n\\n### Hover & Cursors \\n\\nTo support any kind of cursor change or mouse hovering, we need to use `NSTrackingArea` and the related methods on `NSView` used to add and remove them. It\'s not recommended to use any of the methods with the phrase `TrackingRect` or `CursorRect` in them - they\'ve been superseded since Leopard by `NSTrackingArea`.\\n\\n```swift\\nprivate func commonInit() {\\n    // ...\\n    self.addTrackingArea(NSTrackingArea(rect: .zero,\\n                                        options: [.activeInKeyWindow, .inVisibleRect, .cursorUpdate],\\n                                        owner: self, userInfo: nil))\\n}\\n\\nopen override func cursorUpdate(with event: NSEvent) {\\n    NSCursor.pointingHand.set()\\n}\\n```\\n\\nWe don\'t even have to implement `updateTrackingAreas()` to handle changing frames or anything. The `NSTrackingArea` makes sure that `cursorUpdate(with:)` is only called with the visible frame of the view, when the window containing the view is key. It\'s dead simple; if we wanted to support mouse hovering, to perhaps display suggestions or change our drawing in some way, we would just change `.cursorUpdate` to `.mouseEnteredAndExited` or `.mouseMoved`. Maybe we just want to change our drawing or cursor when we\'re the first responder? Just change `.activeInKeyWindow` to `.activeWhenFirstResponder` -- be mindful that the `options` are three individual option sets masked together. You can\'t use `.activeInKeyWindow` and `.activeWhenFirstResponder` simultaneously for example.\\n\\n### Haptic & Audio Feedback \\n\\nSome controls may want to add audio feedback support, like `NSButton.sound`, but in my opinion, this makes assumptions on the availability and implementation of the audo feedback (what if the client wishes to use `AVAudioPlayer`?); instead, it\'s probably a better idea to play the sound in our delegate or target/action methods. If we did want to support audio feedback with `NSSound`, however, it\'s quite simple:\\n\\n```swift\\n@objc open var sound: NSSound? = nil\\n\\n// ...\\n\\nopen func doSomething() {\\n    // ...\\n    self.sound?.play()\\n}\\n```\\n\\nLikewise, some controls may want to add haptic feedback, but those controls *(should)* primarily rely on *(specifically)* force touch interaction, like dragging or deep pressing, and our shortcut recording control relies primarily on keyboard input. If we were to, adding simple haptic responses is just as simple, albeit a little more wordy:\\n\\n```swift\\n@objc open var hapticPerformer: NSHapticFeedbackPerformer? = NSHapticFeedbackManager.defaultPerformer\\n\\n// ...\\n\\nopen func doSomething() {\\n    // ...\\n    self.hapticPerformer?.perform(.levelChange, performanceTime: .drawCompleted)\\n}\\n```\\n\\nIn this specific case, while currently on macOS, there is only a `defaultPerformer`, we can expect that there may be more in the future, perhaps one for the touch bar, as an example. In anticipating such changes, it might be a good idea to allow our client to set the desired `hapticPerformer` - if it\'s set to `nil`, it acts as if we\'ve disabled haptic feedback.\\n\\n### Window Keyedness\\n\\n![NSWindow State](assets/window-state.png)\\n\\nAn important concept on macOS is that of window \\"keyedness\\" and \\"main-ness\\", as you can see above. Controls are expected to draw accordingly to visually explain to the user if they\'re able to be interacted with or not. We can monitor our parent `window`\'s state without any strong reference to the `window` by using the `viewWillMove(toWindow:)` method, and then trampoline that using `NSNotificationCenter`.\\n\\n```swift\\n@objc private func windowKeyednessChanged(_ note: Notification) {\\n    guard let window = self.window, (note.object as? NSWindow) == window else { return }\\n    // do nothing for now\\n}\\n\\nopen override func viewWillMove(toWindow newWindow: NSWindow?) {\\n    let n = NotificationCenter.default // shorthand\\n    if let oldWindow = self.window {\\n        n.removeObserver(self, name: NSWindow.didBecomeKeyNotification,\\n                         object: oldWindow)\\n        n.removeObserver(self, name: NSWindow.didResignKeyNotification,\\n                         object: oldWindow)\\n    }\\n    if let newWindow = newWindow {\\n        n.addObserver(self, selector: #selector(self.windowKeyednessChanged(_:)),\\n                      name: NSWindow.didBecomeKeyNotification, object: newWindow)\\n        n.addObserver(self, selector: #selector(self.windowKeyednessChanged(_:)),\\n                      name: NSWindow.didResignKeyNotification, object: newWindow)\\n    }\\n}\\n\\ndeinit {\\n    NotificationCenter.default.removeObserver(self) // just in case\\n}\\n```\\n\\nNow, we\'ll get the `windowKeyednessChanged(_:)` notifications whenever keyedness changes (and note that we could do the same for main-ness as well) without worrying about which window we\'re contained within. The next thing to do is wire our first responder state into the method, which sounds inappropriate, but since we use the method *just* for handling drawing and event state, it\'s okay to do so without getting pedantic about it.\\n\\n```swift\\nopen override func becomeFirstResponder() -> Bool {\\n    DispatchQueue.main.async {\\n        self.windowKeyednessChanged(Notification(name: NSWindow.didBecomeKeyNotification,\\n                                                 object: self.window, userInfo: nil))\\n    }\\n    return true\\n}\\n\\nopen override func resignFirstResponder() -> Bool {\\n    DispatchQueue.main.async {\\n        self.windowKeyednessChanged(Notification(name: NSWindow.didResignKeyNotification,\\n                                                 object: self.window, userInfo: nil))\\n    }\\n    // ...\\n    return true\\n}\\n```\\n\\nWe need to enqueue the `windowKeyednessChanged` invocation to the main queue because we haven\'t yet become the first responder until the `become/resignFirstResponder` method returns.\\n\\n###  Global HotKey Interference\\n\\nAt this point we have a fully functional keyboard shortcut recorder! However... attempting to record certain shortcuts, you\'ll find, don\'t work, mysteriously. After a few different shortcuts you\'ve tried to record, it hits you: these are symbolic shortcuts that we\'ve set in the System Preferences! We\'re accidentally triggering them instead of recording the shortcut! Surely, you wonder, how does System Preferences allow you to record shortcuts without triggering symbolic ones willy-nilly? The answer lies in a den of dragons:\\n\\n```swift\\n// Here lie dragons!\\nfileprivate typealias CGSConnectionID = UInt\\nfileprivate enum CGSGlobalHotKeyOperatingMode: UInt {\\n    case enable = 0, disable = 1, universalAccessOnly = 2\\n}\\n@_silgen_name(\\"CGSMainConnectionID\\")\\nfileprivate func CGSMainConnectionID() -> CGSConnectionID\\n@_silgen_name(\\"CGSGetGlobalHotKeyOperatingMode\\")\\nfileprivate func CGSGetGlobalHotKeyOperatingMode(_ connection: CGSConnectionID,\\n                                                 _ mode: UnsafeMutablePointer<CGSGlobalHotKeyOperatingMode?>) -> CGError\\n@_silgen_name(\\"CGSSetGlobalHotKeyOperatingMode\\")\\nfileprivate func CGSSetGlobalHotKeyOperatingMode(_ connection: CGSConnectionID,\\n                                                 _ mode: CGSGlobalHotKeyOperatingMode) -> CGError\\n```\\n\\nThe answer to recording hotkeys that have been reserved already... is to turn off hotkeys globally while you\'re first responder. I swear up and down this is exactly what System Preferences does - take a look yourself if you don\'t believe me! It\'s pretty simple to cache the existing global state, turn the hotkeys off, and then once we\'re resigning first responder, reset the global state. Here\'s what that looks like:\\n\\n```swift\\nprivate var savedOperatingMode: CGSGlobalHotKeyOperatingMode? = nil\\n    \\ndeinit {\\n    if self.savedOperatingMode != nil {\\n        _ = CGSSetGlobalHotKeyOperatingMode(CGSMainConnectionID(), self.savedOperatingMode!)\\n    }\\n    // ...\\n}\\n\\n@objc private func windowKeyednessChanged(_ note: Notification) {\\n    // ...\\n    if window.isKeyWindow && window.firstResponder == self { // becomeKey\\n        guard self.savedOperatingMode == nil else { return }\\n        \\n        _ = CGSGetGlobalHotKeyOperatingMode(CGSMainConnectionID(), &self.savedOperatingMode)\\n        _ = CGSSetGlobalHotKeyOperatingMode(CGSMainConnectionID(), .disable)\\n    } else { // resignKey\\n        guard self.savedOperatingMode != nil else { return }\\n\\n        _ = CGSSetGlobalHotKeyOperatingMode(CGSMainConnectionID(), self.savedOperatingMode!)\\n        self.savedOperatingMode = nil\\n        window.makeFirstResponder(nil) // resign ourselves if window resigned\\n    }\\n}\\n```\\n\\nA disclaimer: *you don\'t need to include this to roll a fully functional shortcut recorder.* You **can** ignore the fact that the user will be trying to record shortcuts and then be disappointed that it\'s not working. You **can!** let your user down! And you **will** if you\'re submitting your app to the MAS, so keep this in mind. We\'re not to use this facility for evil, but to respond to exactly what the user is doing. The unfortunate downside is that the symbolic/other hot keys will be triggered when the user double-dips with our app, unless we claim the shortcut exclusively (see, there *was* a reason for that!).\\n\\n### String Localization\\n\\nAlright, we\'re done now right? No one using this control lives outside America (and even those that live within, they definitely speak English fluently, right?) and none of *our users* are disabled right? **Wrong.** Always consider that you, as the developer, are not the target audience of your tool (be it a control, or an app), and always focus on **i18n** and **accessibility**, because like it or not, it\'s not beneficence, it\'s a responsibility.\\n\\nLuckily, localization support is pretty easy, except for the hard part (which is the localization itself). I\'ve opted to wrap it into a `Localized` container with a helper function `value(_:default:comment:)` that looks up the string from the bundle that contains the class. This is important, because your control may or may not be in the `main` bundle. To use it, just create static properties like `Localized.voiceOverBegin` below:\\n\\n```swift\\nprivate enum Localized {\\n    private static func value(_ key: String, `default`: String, comment: String) -> String {\\n        return NSLocalizedString(key, tableName: nil, bundle: Bundle(for: KeyboardShortcutView.self),\\n                                 value: `default`, comment: comment) // helper!\\n    }\\n\\n    // ...\\n    \\n    fileprivate static var actionName: String {\\n        return value(\\"action_name\\", default: \\"Record Shortcut\\",\\n                     comment: \\"The action name for undo and redo\\")\\n    }\\n    \\n    fileprivate static var voiceOverBegin: String {\\n        return value(\\"voiceover_begin\\", default: \\"Now recording a shortcut\\",\\n                     comment: \\"The notification name for VoiceOver if the control began recording\\")\\n    }\\n\\n    // ...\\n}\\n```\\n\\nAlways provide helpful comments for your translators, and provide a `default` in your expected target language in case you haven\'t loaded a good `strings` file, or you just plain don\'t have one in the current bundle.\\n\\n### Accessibility\\n\\nI\'m no accessibility expert, but here\'s the bare minimum you should implement for a control that resembles a button and contains other sub-controls. Be sure to conform `KeyboardShortcutView` to `NSAccessibilityButton` and `NSAccessibilityGroup`.\\n\\n```swift\\nopen override func isAccessibilityElement() -> Bool {\\n    return true\\n}\\nopen override func accessibilityHelp() -> String? {\\n    return Localized.help\\n}\\nopen override func accessibilityRole() -> NSAccessibilityRole? {\\n    return .button\\n}\\nopen override func accessibilityLabel() -> String? {\\n    let str = self.stringRepresentation\\n    return str.isEmpty ? Localized.noShortcut : str\\n}\\nopen override func accessibilityValue() -> Any? {\\n    return self.accessibilityLabel()\\n}\\nopen override func accessibilityRoleDescription() -> String? {\\n    return Localized.tooltipPrefix\\n}\\nopen override var accessibilityFocusedUIElement: Any? {\\n    return self.window?.firstResponder == self\\n}\\nopen override func accessibilityChildren() -> [Any]? {\\n    return [self.clearButton]\\n}\\nopen override func accessibilityPerformPress() -> Bool {\\n    guard self.isEnabled else { return false }\\n    self.performClick(nil)\\n    return true\\n}\\n```\\n\\nAnd while that presents our accessible properties to the accessibility daemons and tools, we should also post notifications using `NSAccessibilityPostNotification` when `shortcut` changes, and definitely emit a VoiceOver announcement when we change recording state or set the shortcut from user input.\\n\\n```swift\\n\\n/*@objc*/ open var shortcut: KeyboardShortcutView.Pair? {\\n    didSet {\\n        // ...\\n        NSAccessibilityPostNotification(self, .valueChanged)\\n        // ...\\n    }\\n}\\nopen override func performKeyEquivalent(with event: NSEvent) -> Bool {\\n    // ...\\n    if /* we should record the new shortcut */ {\\n        // ...\\n        NSAccessibilityPostNotificationWithUserInfo(self, .announcementRequested, [\\n            .announcement: Localized.voiceOverRecorded,\\n            .priority: NSAccessibilityPriorityLevel.high\\n        ])\\n        return true\\n    }\\n    // ...\\n}\\n\\n\\npublic func beginRecording() -> Bool {\\n    // ...\\n    NSAccessibilityPostNotificationWithUserInfo(self, .announcementRequested, [\\n        .announcement: Localized.voiceOverBegin,\\n        .priority: NSAccessibilityPriorityLevel.high\\n    ])\\n    return true\\n}\\n\\n@objc private func buttonAction(_ button: NSButton) {\\n    // ...\\n    if /* we should clear the shortcut set */ {\\n        // ...\\n        NSAccessibilityPostNotificationWithUserInfo(self, .announcementRequested, [\\n            .announcement: Localized.voiceOverCleared,\\n            .priority: NSAccessibilityPriorityLevel.high\\n        ])\\n    }\\n}\\n\\nopen override func updateLayer() {\\n    // ...\\n    self.clearButton.setAccessibilityLabel(canStop ? Localized.buttonRecordLabel\\n                                                   : Localized.buttonClearLabel)\\n}\\n```\\n\\n```swift\\nin KeyboardShortcutView.clearButton.getter:\\n        button.toolTip = Localized.buttonTooltip\\n        button.setAccessibilityHelp(Localized.buttonTooltip)\\n```\\n\\nWe don\'t just place the VoiceOver announcements in `willSet`/`didSet` for `isRecording`, because they are unique to the reason why the recording state changed.\\n\\n### `NSCoding` & State Restoration\\n\\nOne of the most crucial things is to support `NSCoding` if you aim to be Interface Builder-compatible, and to support automatic termination, through `NSResponder` state restoration. State restoration should encode and decode only a subset of the keys the class typically encodes or decodes for `NSCoding`: the ones that are actually user-facing state. As Apple says, *\\"you must store enough data to reconfigure the responder and return it to its current state during a subsequent launch of the application.\\"*\\n\\n**Here, you really should *not* be passing `NSCoding` methods onto `NSResponder`\'s state restoration.** I leave the proper implementation as an exercise for the reader. *(read: I was lazy about it.)* I\'ve decided to not implement it correctly as I\'m currently experimenting with a `Codable` <--\x3e `NSCoding` adapter specific to my implementation of this control. I\'ll possibly write another post on that later.\\n\\n```swift\\nopen static var supportsSecureCoding: Bool {\\n    return true\\n}\\n\\npublic required init?(coder: NSCoder) {\\n    super.init(coder: coder)\\n    self.restoreState(with: coder)\\n    self.commonInit()\\n}\\n\\nopen override func encode(with coder: NSCoder) {\\n    super.encode(with: coder)\\n    self.encodeRestorableState(with: coder)\\n}\\n\\nopen override func encodeRestorableState(with coder: NSCoder) {\\n    //super.encodeRestorableState(with: coder)\\n    \\n    coder.encode(self.suggestions.map { representation(of: $0) }, forKey: \\"suggestions\\")\\n    coder.encode(representation(of:self.shortcut), forKey: \\"shortcut\\")\\n    coder.encode(self.isEnabled as NSNumber, forKey: \\"isEnabled\\")\\n}\\n\\nopen override func restoreState(with coder: NSCoder) {\\n    //super.restoreState(with: coder)\\n    \\n    let s = coder.decodeObject(of: NSArray.self, forKey: \\"suggestions\\") as? [NSDictionary]\\n    self.suggestions = (s ?? []).compactMap { representation(of: $0) }\\n    self.shortcut = representation(of: coder.decodeObject(of: NSDictionary.self, forKey: \\"shortcut\\"))\\n    self.isEnabled = coder.decodeObject(of: NSNumber.self, forKey: \\"isEnabled\\") as? Bool ?? false\\n}\\n```\\n\\nBe sure to conform `KeyboardShortcutView` to `NSSecureCoding`. When we change certain properties (the ones we\'re encoding and decoding), we should call `invalidateRestorableState` to ensure our current state is encoded (automatic termination is like the grim reaper: it arrives without warning, and thus we must protect our interests before its arrival). Add the `self.invalidateRestorableState()` call to the `didSet` of `shortcut`, `suggestions`, and `isEnabled`. \\n\\nNow when you make a change, quit the app, reopen it, and you\'ll find that things were as you left it before you quit the app!\\n\\n### Context `NSMenu` Popups\\n\\nIt may be desirable to allow the user to select a keyboard shortcut from a list of suggestions, like the Siri System Preferences pane, for example. To support this, let\'s add a `suggestions` property that takes an `[KeyboardShortcutView.Pair]`. When a `Pair` is selected from the list, the `shortcut` property is overridden with the selected value.\\n\\n```swift\\n/*@objc*/ open var suggestions: [KeyboardShortcutView.Pair] = [] {\\n    willSet { self.willChangeValue(forKey: #function) }\\n    didSet {\\n        self.didChangeValue(forKey: #function)\\n        // ...\\n    }\\n}\\n```\\n\\nNow, how do we actually display the list of suggestions to the user, in-band with the control itself? `NSView` offers a `menu` property, but we can also override `menu(for:)` to return an `NSMenu` based on where the menu-opening right click occurred, specifically. Since we don\'t need that level of granularity, let\'s go ahead and override `menu` directly and map `suggestions` into `NSMenuItem`s. Note that to be able to manually enable or disable menu items, we should set `NSMenu.autoenablesItems` to `false`, because otherwise, `NSMenu` will validate the existence of each menu item\'s `action` method existing on the item\'s `target`. \\n\\n```swift\\nopen override var menu: NSMenu? {\\n    get {\\n        let menu = NSMenu()\\n        menu.autoenablesItems = false\\n        for (i, x) in self.suggestions.enumerated() {\\n            let str = Localized.menuPrefix + \\" \\" + x.modifierFlags.characters + x.keyCode.characters\\n            let item = NSMenuItem(title: str, action: #selector(self.selectAction(_:)), keyEquivalent: \\"\\")\\n            item.tag = i\\n            item.target = self\\n            item.isEnabled = self.isEnabled\\n            menu.addItem(item)\\n        }\\n        return menu\\n    }\\n    set { }\\n}\\n\\n@objc private func selectAction(_ item: NSMenuItem) {\\n    guard self.isEnabled else { return }\\n    self.endRecording()\\n    self.shortcut = self.suggestions[item.tag]\\n}\\n```\\n\\nWe\'ve also overridden `menu.setter` to become a no-op, because we no longer want to allow a client to set a `menu` that may have no context with our control. In effect, we\'re forcing our clients to use `suggestions` only. An alternative could be to override `menu(for:)` and return a new `NSMenu` with `self.menu.items + self.suggestions.map { $0.toMenuItem() }` (pseudocode). \\n\\nAstute readers will spot the race condition possible with this code: `suggestions` may have been modified between `menu.getter` and `selectAction(_:)`, causing `self.suggestions[item.tag]` to become inconsistent or crash. *Solving this race condition is an exercise left to the reader... (I\'m just using that phrase to avoid solving the problems myself aren\'t I?)*\\n\\n### Undo Management\\n\\nBecause macOS applications use variations of the `\u2318Z` shortcut to undo or redo, it might seem a little odd to support undo management in a control that\'s designed to record keyboard shortcuts themselves. However, as long as the control isn\'t the first responder, the undo action will always trigger, *except* in cases where the app has registered `\u2318Z` as a global shortcut (the `delegate` should ideally prevent things like that).\\n\\nAdding support for undo management is actually very easy; since setting the `shortcut` property changes what the user sees, and we set this property internally in `performKeyEquivalent(_:)`, we can register our undo action there! This does have an unintended/unwanted side effect of also pushing the undo stack when the app is programmatically setting the `shortcut` value. However, I think it\'s perfectly acceptable to keep a continuous undo stack between the app and user actions in this case.\\n\\n```swift\\n/*@objc*/ open var shortcut: KeyboardShortcutView.Pair? {\\n    didSet {\\n        // ...\\n        self.undoManager?.registerUndo(withTarget: self) { [oldValue] _ in\\n            self.shortcut = oldValue\\n        }\\n        self.setActionName(Localized.actionName)\\n        // ...\\n    }\\n}\\n```\\n\\nEach `NSResponder` has an `undoManager` that we can just register the undo action with -- an undo action takes `self` as the target, with a handler to execute when the user un-does the current action. Notice that we capture `oldValue` at registration-time, instead of invocation-time: this is so we don\'t set the undone `shortcut` value to itself accidentally.\\n\\nRunning an application with an existing saved state, we\'ll notice an unusual glitch: it appears that even though the app was just launched (and restored its state), the user sees an undo action, even though they haven\'t interacted with the control yet! This is because the one edge-case we need to control in setting the `shortcut` property is the initializer(s) setting it. A `Swift` initializer does not invoke any property observers when a member\'s value is set, **however**, `restoreState(_:)` is not an initializer! It\'s a normal method, and thus, will invoke the `didSet`, which is harmless, except for this particular side effect. The solution is to only register an action with the undo manager if we aren\'t restoring state.\\n\\n```swift\\n/*@objc*/ open var shortcut: KeyboardShortcutView.Pair? {\\n    didSet {\\n        // ...\\n        if !self.isRestoringState {\\n            self.undoManager?.registerUndo(withTarget: self) { [oldValue] _ in\\n                self.shortcut = oldValue\\n            }\\n            self.setActionName(Localized.actionName)\\n        }\\n        // ...\\n    }\\n}\\n\\n// ...\\n\\nprivate var isRestoringState: Bool = false\\n\\nopen override func restoreState(with coder: NSCoder) {\\n    // ...\\n    self.isRestoringState = true\\n    defer {self.isRestoringState = false }\\n    // ...\\n}\\n```\\n\\nNow, running the app from an existing saved state won\'t cause unexpected undo actions to register! The astute reader will also observe that we could just flip the condition on `isRestoringState`, calling the boolean `shouldRegisterUndo`, and only enable it during `performKeyEquivalent(_:)`. That\'s a perfectly fine solution as well, depending on what undo registration behavior you want to achieve.\\n\\nWhat about redo actions? We\'ve only set up undo actions: if the user types `\u2318L` and then undoes the action, how do we allow the user to redo that (that is, set the shortcut again to `\u2318L`)? It turns out that `UndoManager` handles this logic already, and if we\'re currently executing the registered undo action\'s handler, `isUndoing` is `true`, and the \\"undo action of the undo action\\" is translated into a \\"redo action\\" for us. We\'re all done here!\\n\\n## Conclusion\\n\\nWith that, we\'ve completely designed and implemented a keyboard shortcut recording control, following correct practice and masquerading as a first class AppKit citizen! If you have any questions, comments, or concerns, contact me on Twitter or Github @avaidyam!"},{"id":"/2018/03/16/","metadata":{"permalink":"/blog/2018/03/16/","source":"@site/blog/2018-03-16.md","title":"Building a Better RegisterEventHotKey","description":"Okay, well, maybe not better, but at least, not under imminent threat of deprecation - and even that is questionable, because we\'ll be using [Private SPI] (I mean, would you really be here reading this if it didn\'t? At least I\'ve marked it all so you can cut it out for MAS apps.)","date":"2018-03-16T00:00:00.000Z","formattedDate":"March 16, 2018","tags":[],"readingTime":16.195,"truncated":true,"authors":[],"frontMatter":{},"prevItem":{"title":"An Exercise in Modern Cocoa Views","permalink":"/blog/2018/03/22/"},"nextItem":{"title":"The Secret Life of Core Animation","permalink":"/blog/2018/02/22/"}},"content":"Okay, well, maybe not better, but at least, not under imminent threat of deprecation - and even that is questionable, because we\'ll be using `[Private SPI]` (I mean, would you really be here reading this if it didn\'t? At least I\'ve marked it all so you can cut it out for MAS apps.)\\n\\nRecently, I\'ve wanted to get around to adding \\"hot key\\" support for Parrot, and realized I didn\'t like any of the existing solutions:\\n\\n1. Use `MASShortcut` or `ShortcutRecorder` which are tried and proven to work in ObjC-land.\\n2. Use a new but not proven Swift hotkey recorder (there\'s a few out there).\\n3. Roll my own using dangerous private SPI and not test it at all! \\n\\n*Obviously I went with option #3.* \\n\\n\x3c!--truncate--\x3e\\n\\nI ended up building a \xb5Framework (everything these days is one, right?) that handles hotkeys, provides a user input and display for hotkeys, and a small high-level recognizer platform to handle them with ease. I\'ll walk you, the reader, through each step! But first, I want to clarify something: the terms \\"hot key\\", \\"key equivalent\\", \\"keyboard shortcut\\", and \\"mnemonic\\" are not the same things, on the same or different (i.e. macOS vs Windows) platforms, and so here, I\'ve chosen \\"keyboard shortcut\\" as the most descriptive term. \\n\\nBefore we get into the nitty gritty hand-holding pair-programming stuff, if you\'d like to jump straight to the comment-annotated final source code, [I\'ve included a snapshot here.](https://gist.github.com/avaidyam/32975976c23dd3b38336f22d971f5eaa) It\'s the whole final product, exactly 1500 LOC, including the code from the next \\"episode\\" - a corresponding keyboard shortcut recording control! If you think this should be a formal repository and whatnot, contact me on Twitter or Github @avaidyam!\\n\\n--- \\n\\n## How does `RegisterEventHotKey` work?\\n\\n### Disassembly & Reverse Engineering\\n\\nThe first step to designing a better `X` is to understand how `X` works. To do that, whip out `Hopper` (I\'m not paid to say this but if you don\'t have this app yet, you definitely need it!) and disassemble `/System/Library/Carbon.framework/Frameworks/HIToolbox.framework`. Locate the function and take a peek -- or, if you\'d like, [just take a look at my cleaned up version of the function here.](https://gist.github.com/avaidyam/18b7c3d0a15afade931d10a27ed53872) I also added a similar function from `ScreenReader.framework` to cross-reference with.\\n\\nAll the function basically does is wrap its parameters into an internal data type and call through to `SkyLight.framework` (you may know it as `CoreGraphicsServices`, from `CoreGraphics.framework` on pre-macOS 12) while keeping track of the hotkey registration in a static var dictionary. I\'ll come back to the CoreGraphics call in a little bit, because this function does something very interesting... we\'ll also ignore the `CGSSetHotButtonWithExclusion` call, which is actually an alias for the function `CGSSetHotKeyRepresentationWithOptions`, because that\'s not what we want right now. We\'ll instead be using `CGSSetHotKeyWithExclusion`. \\n\\n### CGSHotKey Symbols\\n\\nHere\'s a complete list of `CGSHot*` symbols:\\n* `CGSGetHotButton`\\n* `CGSGetHotKeyRepresentation`\\n* `CGSGetHotKeyType`\\n* `CGSGetHotModifier`\\n* `CGSSetHotButtonWithExclusion`\\n* `CGSSetHotKeyEnabled`\\n* `CGSSetHotKeyRepresentation`\\n* `CGSSetHotKeyRepresentationWithOptions`\\n* `CGSSetHotKeyType`\\n* `CGSSetHotKeyWithExclusion`\\n* `CGSSetHotKeyWithOptions`\\n* `CGSSetHotModifierWithExclusion`\\n* `CGSSetHotModifierWithOptions`\\n* `CGSGetSymbolicHotKeyButtonValue`\\n* `CGSGetSymbolicHotKeyRepresentation`\\n* `CGSGetSymbolicHotKeyRepresentationList`\\n* `CGSGetSymbolicHotKeyValuesAndStates`\\n* `CGSGetSymbolicHotModifierValue`\\n* `CGSSetSymbolicHotKey`\\n* `CGSSetSymbolicHotKeyButtonValue`\\n* `CGSSetSymbolicHotKeyEnabledForConnection`\\n* `CGSSetSymbolicHotKeyRepresentation`\\n* `CGSSetSymbolicHotKeyValue`\\n* `CGSSetSymbolicHotKeyWithExclusion`\\n* `CGSSetSymbolicHotKeyWithOptions`\\n* `CGSSetSymbolicHotModifierValue`\\n* `CGSIsSymbolicHotKeyEnabledForConnection`\\n\\nI\'ll demystify some of these symbols: there are two types of \\"hot\\" events: **regular**, and **symbolic**. Symbolic hot events are those that the `WindowServer` has designated and named. [You can find a near-full list of symbolic identifiers here.](https://github.com/NUIKit/CGSInternal/blob/master/CGSHotKeys.h#L38) These include things like Expos\xe9 or Screenshot keys, basically those that are defined in the \\"System Preferences > Keyboard > Shortcut\\" pane. \\n\\nNow, within these types, there are subtypes: `HotKey`, `HotButton`, `HotModifier`, and `HotKeyRepresentation`. `HotButton` is actually just an alias for `HotKeyRepresentation`, which I\'ll admit, I\'m not savvy to the reason behind its specific distinction. `HotModifier` is just that -- a modifier press that activates an event, like Siri or Dictation shortcuts. Finally, what we want, is the `HotKey` facility, which is a plain old keyboard shortcut, with a virtual key code, and a modifier list. \\n\\nThere is a special `WithExclusion` function, which calls through to `WithOptions` (presumably, there are more options, but I doubt any are used right now): setting a hot key with exclusion implies that no other application (including the calling one) may register this same hot key again, and if it was already acquired by another application, the call fails. As far as I\'m able to tell, this is the behavior, but I can\'t be sure since I haven\'t dug deeper into this option.\\n\\n--- \\n\\n## Building a replacement: `CGSKeyboardShortcut`!\\n\\nSince we\'ve got a cursory understanding of how the existing Carbon facility works, and what hot events facilities Window Server offers, we can architect our own version. \\n\\n```swift\\npublic final class CGSKeyboardShortcut: Hashable {\\n\\t// ...\\n}\\n```\\n\\n### Properties & Acquisition Policy\\n\\nA keyboard shortcut needs a virtual key code (`CGKeyCode`), modifier flags (`CGEventFlags`, instead of `NSEvent.ModifierFlags`), and an identifier (we\'ll create a intly-typed wrapper, for better developer&user-side management), at the very least.\\n\\n```swift\\npublic struct Identifier: RawRepresentable, Hashable, Codable {\\n    public typealias RawValue = Int\\n    public let rawValue: Identifier.RawValue\\n    public init(rawValue: Identifier.RawValue) {\\n        self.rawValue = rawValue\\n    }\\n    public init(_ rawValue: Identifier.RawValue) {\\n        self.rawValue = rawValue\\n    }\\n}\\n\\npublic let identifier: CGSKeyboardShortcut.Identifier\\npublic let keyCode: CGKeyCode\\npublic let modifierFlags: CGEventFlags\\n```\\n\\nNow, returning to the issue of `WithExclusion`, we\'ll also add an `AcquisitionPolicy` to handle that:\\n\\n```swift\\npublic enum AcquisitionPolicy: Int, Codable {\\n    case none\\n    case exclusively\\n    case exclusivelyIfPossible\\n}\\npublic let acquisitionPolicy: AcquisitionPolicy\\n\\npublic init(identifier: CGSKeyboardShortcut.Identifier, keyCode: CGKeyCode,\\n       modifierFlags: CGEventFlags, acquisitionPolicy: AcquisitionPolicy = .none) throws\\n{\\n\\t// ...\\n    self.identifier = identifier\\n    self.keyCode = keyCode\\n    self.modifierFlags = modifierFlags\\n    self.acquisitionPolicy = acquisitionPolicy\\n    // ...\\n}\\n```\\n\\nEssentially, this will be the policy to use when initializing a new `CGSKeyboardShortcut` - do we want to do so `exclusively`, not (`none`) at all, or maybe `exclusivelyIfPossible`? The final option is a special case where we\'ll attempt to be exclusive, but if someone else got to the shortcut first, we still do want a shortcut event delivered to our handler. (Note that we shouldn\'t be considering this value in equality between two `CGSKeyboardShortcut`s.)\\n\\n### Resource Management\\n\\nSince keyboard shortcuts are something of a finite resource (there are only so many key combinations viable for user input) and application or component acquisition matters, we\'ll keep a `Set` of registered keyboard shortcuts at all times, but note that we can only keep track of the shortcuts tracked through our new facility, and not those by `CGS` or `HIToolbox` facilities, unfortunately.\\n\\n```swift\\npublic private(set) static var all: Set<CGSKeyboardShortcut> = []\\n\\npublic init(...) {\\n    guard CGSKeyboardShortcut.all.filter({ $0.identifier == identifier }).count == 0 else {\\n        throw CGError.cannotComplete\\n    }\\n\\t// ...\\n\\tCGSKeyboardShortcut.all.insert(self)\\n}\\n\\ndeinit {\\n\\tCGSKeyboardShortcut.all.remove(self)\\n}\\n```\\n\\nThere is an issue with this mechanism as it stands, though. If we\'d like to invalidate a keyboard shortcut, we have no way of `deinit`ing it without removing it from the `Set`, which only happens upon `deinit`! That\'s a problem, so we\'ll add an explicit `invalidate` method (or two).\\n\\n```swift\\n\\ndeinit {\\n\\tself.invalidate()\\n}\\npublic func invalidate() {\\n    // ...\\n    CGSKeyboardShortcut.all.remove(self)\\n}\\npublic static func invalidateAll() {\\n    CGSKeyboardShortcut.all = []\\n}\\n```\\n\\nThere, that\'s a little better. Now, we don\'t need to hold an explicit reference to a shortcut to keep it valid, and we\'ll need this `Set` for actually handling shortcuts soon anyway. \\n\\n### WindowServer Acquisition & Invalidation\\n\\nNow that we\'ve defined our shortcut class and its containment/usage policies, how do we actually... you know, make it do stuff? For that, we\'ll need to add a suffix to our file here:\\n\\n```swift\\n// Here lie dragons!\\nfileprivate typealias CGSConnectionID = UInt\\n@_silgen_name(\\"CGSMainConnectionID\\")\\nfileprivate func CGSMainConnectionID() -> CGSConnectionID\\n@_silgen_name(\\"CGSSetHotKeyWithExclusion\\")\\nfileprivate func CGSSetHotKeyWithExclusion(_ connection: CGSConnectionID,\\n                                           _ hotKeyID: Int,\\n                                           _ hotKeyMask: UInt16, // always 0xffff\\n                                           _ keyCode: UInt16,\\n                                           _ modifierFlags: UInt64,\\n                                           _ options: Int8) -> CGError\\n@_silgen_name(\\"CGSSetHotKeyType\\")\\nfileprivate func CGSSetHotKeyType(_ connection: CGSConnectionID,\\n                                  _ hotKeyID: Int,\\n                                  _ options: Int8) -> CGError\\n@_silgen_name(\\"CGSSetHotKeyEnabled\\")\\nfileprivate func CGSSetHotKeyEnabled(_ connection: CGSConnectionID,\\n                                     _ hotKeyID: Int,\\n                                     _ enabled: Bool) -> CGError\\n@_silgen_name(\\"CGSIsHotKeyEnabled\\")\\nfileprivate func CGSIsHotKeyEnabled(_ connection: CGSConnectionID,\\n                                    _ hotKeyID: Int) -> Bool\\n@_silgen_name(\\"CGSRemoveHotKey\\")\\nfileprivate func CGSRemoveHotKey(_ connection: CGSConnectionID,\\n                                 _ hotKeyID: Int) -> CGError\\n```\\n\\nThis is a horrible terrible idea. But then again, you\'ve read this much already, so you\'re probably okay with this sick twisted kind of stuff. :)  After elucidating the function arguments, we\'re using `@_silgen_name` to tell the Swift compiler that \\"hey, these functions exist somewhere, so just go along with my devious plans\\". Obviously, if anything goes wrong, you\'re on your own. Be careful with this block of code. \\n\\nNow we\'ll register and unregister the shortcut where necessary, and add a way to enable or disable the shortcut (since `WindowServer` allows us this functionality).\\n\\n```swift\\n\\npublic var isEnabled: Bool {\\n    get { return CGSIsHotKeyEnabled(CGSMainConnectionID(), self.identifier.rawValue) }\\n    set { _ = CGSSetHotKeyEnabled(CGSMainConnectionID(), self.identifier.rawValue, newValue) }\\n}\\n\\npublic init(...) {\\n    // ...\\n\\n    var error: CGError = .success\\n    error = CGSSetHotKeyWithExclusion(CGSMainConnectionID(), self.identifier.rawValue,\\n                                      0xffff, self.keyCode, self.modifierFlags.rawValue,\\n                                      self.acquisitionPolicy == .none ? 0x0 : 0x1)\\n    \\n    // If our acquisition policy can fallback, register non-exclusively.\\n    if error == .noneAvailable && self.acquisitionPolicy == .exclusivelyIfPossible {\\n        error = CGSSetHotKeyWithExclusion(CGSMainConnectionID(), self.identifier.rawValue,\\n                                          0xffff, self.keyCode, self.modifierFlags.rawValue, 0x0)\\n    }\\n    guard error == .success else { throw error }\\n    \\n    error = CGSSetHotKeyType(CGSMainConnectionID(), self.identifier.rawValue, 0x1)\\n    guard error == .success else { throw error }\\n\\n    // ...\\n}\\n\\npublic func invalidate() {\\n    _ = CGSRemoveHotKey(CGSMainConnectionID(), self.identifier.rawValue)\\n    // ...\\n}\\n```\\n\\n### Local Event Handling\\n\\nAlright, now we\'ve got a functioning shortcut right? Not yet! We actually need to get `WindowServer` to send **us** specifically the event for the shortcut! However, (it turns out, in macOS 6+) `NSApplication` actually handles these kinds of events in `-sendEvent:`, but we need to register an event monitor to be notified of them. Let\'s use a local `NSEvent` monitor to trampoline notifications into `NotificationCenter`.\\n\\n```swift\\npublic static let pressedNotification = Notification.Name(\\"CGSKeyboardShortcut.pressedNotification\\")\\npublic static let releasedNotification = Notification.Name(\\"CGSKeyboardShortcut.releasedNotification\\")\\n\\nprivate static var monitor = NSEvent.addLocalMonitorForEvents(matching: .systemDefined) { event in\\n    if [6, 9].contains(event.subtype.rawValue) {\\n        CGSKeyboardShortcut.all.filter { $0.identifier.rawValue == event.data1 }.forEach { obj in\\n            let name: Notification.Name = event.subtype.rawValue == 6\\n                ? CGSKeyboardShortcut.pressedNotification /* 6 */\\n                : CGSKeyboardShortcut.releasedNotification /* 9 */\\n            NotificationCenter.default.post(name: name, object: obj)\\n        }\\n        return nil // consumed\\n    }\\n    return event\\n}\\n\\npublic init(...) {\\n\\t_ = CGSKeyboardShortcut.monitor // bootstrap!\\n\\t// ...\\n}\\n```\\n\\nAll we\'ve done here is grab the shortcut identifier from the `data1` field of the `.systemDefined` event if it\'s of `subtype` `6` or `9`, which are the `-keyDown:` and `-keyUp:` event subtypes, respectively. Once we\'ve done so, and our facility registered the shortcut (that is, not Carbon or another CGS client), bounce the event into a notification. Be sure to \\"bootstrap\\" the event monitor in your `init`, otherwise it\'ll never be initialized and trampoline shortcut events.\\n\\nHere, I\'ve explicitly chosen to use `NotificationCenter` over a delegation or target-action/handler pattern, because it turns a single-producer (the user input) single-consumer (portions of our app) model into a single-producer multiple-consumer pattern. With a single shortcut registration, multiple components can share event information. If we wanted a shortcut to be exclusive to the app, but multiple components acted on it, we would either end up in a hairy mess or end up using `NotificationCenter` anyway. \\n\\n### The Magic Within `RegisterEventHotKey`\\n\\nRemember how earlier, I said `RegisterEventHotKey` was doing something interesting? It `malloc`\'s what I\'m dubbing a `HotButtonData` to hold hot key parameters (presumably) and uses its pointer as the hot key identifier! Holy carp, that\'s insanely bad practice! It is, however, an extremely intelligent alternative to our global `Set`. That was really it. I found it pretty interesting, and I\'m not even really sure if that was developer-intended or a compiler optimization/mangling of some sort. :)\\n\\n### Frozen Representations\\n\\nWhile we\'ve now built a complete and functional shortcut facility, we have no way of storing a shortcut in a non-live, or frozen, way. We could make our class `Codable`, our initializer is where shortcut registration occurs, and invoking a `Codable` initializer should not have any side effects. Instead, I\'ve opted for a design that mirrors only the internal properties of the shortcut class but with no activity of its own, called `CGSKeyboardShortcut.Definition`. It\'s effectively a frozen version of a `CGSKeyboardShortcut`, and we can use this type to inform the client of our class that explicit initialization is required. While there may be better approaches to this problem, I feel that this solution separates the notion of a live shortcut and a frozen one pretty cleanly.\\n\\n```swift\\npublic struct Definition: Hashable, Codable {\\n    public let identifier: CGSKeyboardShortcut.Identifier\\n    public let keyCode: CGKeyCode\\n    public let modifierFlags: CGEventFlags\\n    public let acquisitionPolicy: AcquisitionPolicy\\n    \\n    public init(identifier: CGSKeyboardShortcut.Identifier, keyCode: CGKeyCode, modifierFlags: CGEventFlags, acquisitionPolicy: AcquisitionPolicy) {\\n        self.identifier = identifier\\n        self.keyCode = keyCode\\n        self.modifierFlags = modifierFlags\\n        self.acquisitionPolicy = acquisitionPolicy\\n    }\\n}\\n\\npublic convenience init(definition: Definition) throws {\\n    try self.init(identifier: definition.identifier, keyCode: definition.keyCode,\\n                  modifierFlags: definition.modifierFlags,\\n                  acquisitionPolicy: definition.acquisitionPolicy)\\n}\\n\\npublic var definition: Definition {\\n    return Definition(identifier: self.identifier, keyCode: self.keyCode,\\n                      modifierFlags: self.modifierFlags,\\n                      acquisitionPolicy: self.acquisitionPolicy)\\n}\\n```\\n\\n### CGKeyCode & CGEventFlags Supplements\\n\\nFinally, we\'re not out of the woods yet. There\'s a slight issue with registering a shortcut with any old `NSEvent`-provided modifier flags - only a few flag bits are allowed (the physical key modifer ones)! Modify the line in `init(...) { ... }` that reads `self.modifierFlags = modifierFlags` to `self.modifierFlags = modifierFlags.intersection(.maskShortcutFlags)`. We\'ll define a few extensions to `CGEventFlags` to support this, and to allow conversion between `NSEvent.ModifierFlags`. In addition, we\'ll conform `CGError` to `Error` since it\'s not already for some reason...\\n\\n\\n```swift\\nextension CGError: Error {}\\n\\nextension CGEventFlags: Hashable, Codable {\\n    public var hashValue: Int { return self.rawValue.hashValue }\\n}\\n\\npublic extension CGEventFlags {\\n    public init(_ flags: NSEvent.ModifierFlags) {\\n        self.init(rawValue: UInt64(flags.rawValue))\\n    }\\n    \\n    public static let maskDeviceIndependentFlags = CGEventFlags(rawValue: 0x00000000ffff0000)\\n    public static let maskShortcutFlags = CGEventFlags(rawValue: 0x0000000000ff0000)\\n    public static let maskUserFlags: CGEventFlags = [.maskCommand, .maskControl, .maskShift, .maskAlternate]\\n}\\n\\npublic extension NSEvent.ModifierFlags {\\n    public init(_ flags: CGEventFlags) {\\n        self.init(rawValue: UInt(flags.rawValue))\\n    }\\n}\\n```\\n\\n---\\n\\n## Building Higher-Order Recognizers\\n\\n### Why?\\n\\nRealistically, a developer could use the `CGSKeyboardShortcut` class as is and be perfectly fine! It does everything, after all, from maintaining the shortcut list, to trampolining events into notifications, and more. However, building \\"higher-order\\" facilities to handle complex interactions is well worth it, even if it means a little more code to accomplish the simple use-case (because remember, we\'re not removing the original facility, only building atop it). Let\'s define a `ShortcutRecognizer` protocol that takes two inputs: `keyDown` and `keyUp`, but does not provide a standard output. It\'ll be up to our implementing classes to do that.\\n\\n```swift\\npublic protocol ShortcutRecognizer: class {\\n    func keyDown()\\n    func keyUp()\\n}\\n```\\n\\nSo what would handling a shortcut, the normal way, look like with this protocol?\\n\\n```swift\\npublic final class PressShortcutRecognizer: ShortcutRecognizer {\\n    public let handler: () -> ()\\n    public init(_ handler: @escaping () -> ()) {\\n        self.handler = handler\\n    }\\n    \\n    public func keyDown() {\\n        /// ignored!\\n    }\\n    \\n    public func keyUp() {\\n        self.handler()\\n    }\\n}\\n```\\nUgh, that\'s like, 10 extra lines of code and another class to deal with! But that\'s not the point! We\'ve written something that doesn\'t actually rely on `CGS` facilities or even our `CGSKeyboardShortcut` facility! We don\'t even need to use this for shortcuts! It can do anything! (Maybe limiting its scope is a good thing to do though...) \\n\\n### How?\\n\\nOkay, but the whole point of a recognizer type was to be able to simplify complex interactions, so how about this, an action in my app requires the user to do this exact sequence:  `keyDown` -> `keyUp` -> `keyDown` within 1sec -> `keyUp` after 2sec. \\n\\nIt\'ll be a `TapHoldShortcutRecognizer` with a variable hold duration:\\n```swift\\npublic final class TapHoldShortcutRecognizer: ShortcutRecognizer {\\n    private var timeInterval = DispatchTimeInterval.seconds(0)\\n    \\n    public let handler: () -> ()\\n    public init(for t: DispatchTimeInterval = .seconds(2), _ handler: @escaping () -> ()) {\\n        self.timeInterval = t\\n        self.handler = handler\\n    }\\n    \\n    public func keyDown() {\\n        // ...\\n    }\\n    \\n    public func keyUp() {\\n    \\t// ...\\n    }\\n}\\n```\\n\\nSince we actually never need to handle the first `keyUp`, let\'s handle the double `keyDown` first, using a bool as well as a time marker, to maintain the inter-`keyDown` and hold durations. \\n\\n```swift\\nprivate var timeReference: CFAbsoluteTime = 0.0\\nprivate var inDoubleTap = false\\n\\npublic func keyDown() {\\n\\tdefer { self.timeReference = CFAbsoluteTimeGetCurrent() }\\n\\tguard CFAbsoluteTimeGetCurrent() - self.timeReference < 1.0 else { return } // double-tapped\\n\\n\\tself.inDoubleTap = true\\n\\tDispatchQueue.main.asyncAfter(deadline: .now() + self.timeInterval) {\\n\\t\\t// ...\\n\\t}\\n}\\n```\\n\\nWe\'ve put the time tracking in a `defer { ... }` statement because we want it execute only after the method has finished processing; it\'s just a marker of when we noticed the `keyDown`, after all. This way, our `guard` statement isn\'t affected either, and we can ignore the inter-`keyDown` interval. Notice that we\'re only using `DispatchTimeInterval` for the hold duration, to play nice with `DispatchQueue.asyncAfter(...)`. Once we enter the hold phase (that is, `keyDown` -> `keyUp` -> `keyDown` within 1sec -> ...), we can defer to the `keyUp()` function.\\n\\n\\n```swift\\n// ...\\n\\tDispatchQueue.main.asyncAfter(deadline: .now() + self.timeInterval) {\\n\\t\\tguard self.inDoubleTap else { return }\\n\\t\\tself.inDoubleTap = false\\n\\t\\tDispatchQueue.main.async(execute: self.handler)\\n\\t}\\n}\\n\\npublic func keyUp() {\\n\\tguard self.inDoubleTap else { return }\\n\\tself.inDoubleTap = false\\n\\tprint(\\"shortcut recognizer failed because hold duration was \\\\(CFAbsoluteTimeGetCurrent() - self.timeReference)s\\")\\n}\\n```\\n\\nFor the hold phase, we essentially race the user input to our designated hold duration: if the user gets there first (pressing the shortcut before the hold duration is up), we unset the double tap flag and bail our handler execution. Our inter-`keyDown` phase waited on the user to fail to `keyUp` so it could invoke the handler when we reached our hold duration. Clever, but there\'s probably a design pattern or something for this.\\n\\n### Binding to a `CGSKeyboardShortcut`\\n\\nIt\'s now pretty simple to create a binder between a recognizer and a `CGSKeyboardShortcut`, by just adding the recognizer as an observer of... two... notifications... that\'s a little bit unwieldy. Instead, we can add a convenience function to add observers for both notifications and then return a single disposable value. If that value is `deinit`\'ed, both observers are invalidated and the recognizer is effectively unbound! It\'s pretty straightforward.\\n\\n```swift\\npublic extension ShortcutRecognizer {\\n    public func bind(to shortcut: CGSKeyboardShortcut) -> Any {\\n        let x = NotificationCenter.default.addObserver(forName: CGSKeyboardShortcut.pressedNotification, object: shortcut, queue: nil) { _ in\\n            self.keyDown()\\n        }\\n        let y = NotificationCenter.default.addObserver(forName: CGSKeyboardShortcut.releasedNotification, object: shortcut, queue: nil) { _ in\\n            self.keyUp()\\n        }\\n        return _Holder([x, y])\\n    }\\n}\\n\\n// Implementation Detail:\\nclass _Holder {\\n    private let observers: [Any]\\n    public init(_ observers: [Any]) {\\n        self.observers = observers\\n    }\\n}\\n```\\n\\n### Sample Usage\\n\\nComplex user shortcut interaction becomes much cleaner now! Here\'s how we can use all of this together:\\n\\n```swift\\nlet hotkey = try CGSKeyboardShortcut(identifier: .myShortcut,\\n                                     keyCode: 0x7E,\\n                                     modifierFlags: [.maskCommand, .maskControl],\\n                                     acquisitionPolicy: .exclusivelyIfPossible)\\nlet tracker = TapHoldShortcutRecognizer {\\n    _ = NSAlert(style: .informational, text: \\"Double tap and hold succeeded!\\").runModal()\\n}\\nself.observer = tracker.bind(to: hotkey)\\n\\n// ... elsewhere ...\\npublic extension CGSKeyboardShortcut.Identifier {\\n    public static let myShortcut = CGSKeyboardShortcut.Identifier(0xBAAAAAAD)\\n}\\n```\\n\\n*(That `NSAlert` initializer is pretty easy to implement and is left as an exercise for the reader.)*\\n\\n![Sample Alert](assets/shortcut-recognizer-action.png)\\n\\n---\\n\\n## Conclusion\\n\\nIn short, there are better ways to do keyboard shortcuts than to resign to Carbon. Unfortunately, for those targeting the Mac App Store, this has just been an exercise in futility. An alternate implementation of `CGSKeyboardShortcut` could probably just wrap `RegisterEventHotKey` but that\'s no fun is it? Might as well just use `MASShortcut` or something else and not deal with writing it yourself. \\n\\nIn the next episode, I\'ll be designing and developing a corresponding view to display and record keyboard shortcuts! If you have any questions, comments, or concerns, contact me on Twitter or Github @avaidyam!"},{"id":"/2018/02/22/","metadata":{"permalink":"/blog/2018/02/22/","source":"@site/blog/2018-02-22.md","title":"The Secret Life of Core Animation","description":"Most developers know of Core Animation through its few key classes, such as CALayer and CAAnimation, and their subclasses. Very few need to venture past this realm to take advantage of this powerful framework. What\'s not very clear to most is how many faces the framework takes on; there are three: CoreAnimation, CoreAnimationCF, and the internal C++ CoreAnimation underpinnings.","date":"2018-02-22T00:00:00.000Z","formattedDate":"February 22, 2018","tags":[],"readingTime":5.38,"truncated":true,"authors":[],"frontMatter":{},"prevItem":{"title":"Building a Better RegisterEventHotKey","permalink":"/blog/2018/03/16/"},"nextItem":{"title":"CAStateController & Friends","permalink":"/blog/2018/02/19/"}},"content":"Most developers know of Core Animation through its few key classes, such as `CALayer` and `CAAnimation`, and their subclasses. Very few need to venture past this realm to take advantage of this powerful framework. What\'s not very clear to most is how many faces the framework takes on; there are three: `CoreAnimation`, `CoreAnimationCF`, and the internal C++ CoreAnimation underpinnings. \\n\\n\x3c!--truncate--\x3e\\n\\nAll three are contained within the single `QuartzCore.framework` - I\'ve managed to recreate a majority (if not all) the private headers for the first two (C++ is a lot harder unfortunately), and I suggest the reader [take a peek at them first over here.](https://github.com/avaidyam/QuartzInternal) For the third facet, I\'ve produced a list of some, but not all, [the packages (namespaces) being used](https://github.com/avaidyam/QuartzInternal/wiki/Private-CoreAnimation-CPP-Packages), and I suggest the reader take a look at those as well.\\n\\nLet\'s start with the first one: the \\"normal\\" `CoreAnimation` - the one that runs atop Objective-C and is the only publicly marked API for any App Store apps. The easiest way to begin using it is to link AppKit or UIKit and `NSView` or `UIView` will take care of the rest for you. You just need to interface your view\'s layer, animate properties as needed, and so on. There is one small indexing trick used internally called `CAAtom` --  using `CAAtomGetString` and `CAInternAtom`, you can convert between a key path (string) and an indexed id used internally. In addition to atoms, the `CAObject_*` family of functions (`attributesForKey/Path`, `valueForKey/Path`, `setValueForKey/Path`, `initWithCoder`, `encodeWithCoder/CAMLWriter`, etc) are used within `CALayer` and friends to keep track of arbitrary values for arbitrary keys. This is why you\'re able to set any layer keyPath and it won\'t throw a `valueForUndefinedKey:` exception. Past this, there\'s not much else to see here that isn\'t public.\\n\\nThe interesting stuff starts with `CoreAnimationCF`: it\'s a barebones version of the above API... all in pure C using the `CoreFoundation` library only. You\'ve got contexts, layers, rendering, and animations. If you haven\'t already, take a look at the source code above. Why does this exist at all? Because Core Animation actually is cross-platform (along a few other Apple libraries, including Core Graphics)! WebKit and iTunes, for example, have existing DLLs for all of these frameworks, but since they don\'t rely on Objective-C, they use the CF flavor of this API. Should a macOS/iOS developer be using this API? Really, probably not - there\'s nothing you can\'t do in the normal API that `CoreAnimationCF` will help you with. You\'ll also notice, some API are missing, like `CATransaction`.\\n\\nThe final facet is the most interesting, and is pretty much a mystery to me (and remains undocumented by anyone else, AFAIK) -- the C++ API. Through one ObjC protocol (`CARenderValue`), all of the ObjC API (that is, the first facet) can be translated into the C++ API by calling `CA_copyRenderValue`). If you haven\'t already, take a look at the list of packages above, because you\'ll notice some striking similarities. My cursory understanding of this API is that, the render server (be it a background thread or a separate process) copies the context and its layer tree\'s render values and can encode/decode them privately, relieving the ObjC/developer-facing API of any misuse or unexpected results. All of the `CA::Render::` packages/classes correspond to an ObjC layer or animation class, and once packaged up and sent over, the render server would directly manipulate these entities using the `CA::OGL::` packages/classes via a `SW` (software) renderer, `OGL` (OpenGL), or `Metal` renderer (which is likely used on all Apple platforms). In the middle, however, is `CA::CG::`, which looks like a lot of drawing routines that resemble Core Graphics (that is, `CGContext`)...\\n\\nThe way `CGContext` works, is that it has an internal `CGGState` stack, and a current `GState` (top of the stack), that all its clients set and manipulate via draw calls, but under the hood, `CGContextDelegate` translates these calls into a specific surface. `CGSWindow` has a `CGContextWindowDelegate` that when a `NSWindow`s (or their non-layer-backed views) need to draw, is passed as the delegate to `CGWindowContextCreate` and handles this translation layer. Similarly, a `CALayer` likely creates its context using the `CA::CG::` packages as a delegate, allowing the draw calls and GState modifications to map into whatever renderer is being currently used. \\n\\nFinally, there\'s one thing about both the internal C++ and public ObjC API that not many folks have documented or picked up on: `CATransaction`\'s commit handlers and `CAContext`. Every process that needs to work with a layer (or more) requires at least one `CAContext` - this is where the root layer is hosted. You can create additional contexts, remote, or local, to allow hosting your layers in another process (a la Safari tabs). The context supports the notion of `slot`s and `fence`s: I presume slots are a way to pass context-related objects around remote contexts, but haven\'t tested the theory. Fences, however, can be used to delay the host app\'s transaction commit cycle until the client app (the one serving a remote layer) is done with its commit - essentially, it\'s used to synchronize rendered frames, and a fence has a natural timeout of about one second (so the remote layer server should finish its commit within this time). This ties into transaction phases: there are a few points in a `CATransaction` that you can inject a handler: pre-layout, pre-commit, and post-commit. Combining fences with commit handlers, you can correctly synchronize remote rendered layers.\\n\\nSome readers may arrive at a question here: if layers require a context, how does the context get rendered? I\'m not too sure. I know there\'s a way to initialize a local render server and a way to hook into a remote render server (that is, on macOS, `windowserver`), but I don\'t know how the contextId makes its way over or how the two link up. However, if you\'re creating a `CGSWindow`, the fast way to get a `CALayer` on-screen is to create a `CGSSurface` and bind a `CAView` to it. The header for `CAView` is incomplete, but it looks trivial to work with, as it then manages the surface for you.\\n\\nSo, in conclusion, there are three different facets of the Core Animation API, intricate links to Core Graphics, via `CGContextDelegate`, and some kind of `CARender` and `CAContext` song-and-dance that allows a layer to be presented on-screen or in a buffer somewhere. I hope that demystifies a lot of the private API here for you. Drop me a line on Twitter if you think anything is incorrect or needs explaining!"},{"id":"/2018/02/19/","metadata":{"permalink":"/blog/2018/02/19/","source":"@site/blog/2018-02-19.md","title":"CAStateController & Friends","description":"CALayer has internal/private support for two pretty cool things: archives and states. We\'ll talk about states first, as they\'re the more complex part of the exercise.","date":"2018-02-19T00:00:00.000Z","formattedDate":"February 19, 2018","tags":[],"readingTime":3.49,"truncated":true,"authors":[],"frontMatter":{},"prevItem":{"title":"The Secret Life of Core Animation","permalink":"/blog/2018/02/22/"},"nextItem":{"title":"CAPortalLayer","permalink":"/blog/2018/02/18/"}},"content":"`CALayer` has internal/private support for two pretty cool things: archives and states. We\'ll talk about states first, as they\'re the more complex part of the exercise. \\n\\n\x3c!--truncate--\x3e\\n\\nA `CALayer` can have any number of `states` which are `CAState` objects containing a number of `CAStateElement`s. The elements configure the state, and can `target` any sublayer of the root layer, and any `keyPath` on `CALayer`. It looks like it can also have a `source` (which is a `CAStateElement` itself) but I\'m not sure what that specifically means. A state can also be `basedOn` another `CAState`, presumably one that preceeds it in the state diagram of the layer; an `initial` state is one that a layer can start off with (and doesn\'t need a `name` to uniquely identify it). On top of that, a `CALayer` may also have a number of `stateTransitions` which are `CAStateTransition` objects (containing `CAStateTransitionElement`s). The typical use case will be to create elements with a `target` and an `animation` representing the `keyPath` that needs to be animated between the two states. Be sure to set the `toState` and `fromState` on your transition to match the unique state `name`s from earlier. If you use the string `\\"*\\"`, I believe it refers to any possible state. Here\'s a code sample:\\n\\n```swift\\nlet s1 = CAState()\\ns1.name = \\"inactive\\"\\ns1.isInitial = true\\nlet e1 = CAStateSetValue()\\ne1.keyPath = \\"backgroundColor\\"\\ne1.value = NSColor.red.cgColor\\ne1.target = layer\\ns1.addElement(e1)\\n\\nlet s2 = CAState()\\ns2.name = \\"active\\"\\nlet e2 = CAStateSetValue()\\ne2.keyPath = \\"backgroundColor\\"\\ne2.value = NSColor.blue.cgColor\\ne2.target = layer\\ns2.addElement(e2)\\n\\nlet t1 = CAStateTransition()\\nt1.fromState = \\"*\\"\\nt1.toState = \\"active\\"\\nlet e3 = CAStateTransitionElement()\\ne3.key = \\"backgroundColor\\"\\ne3.animation = CABasicAnimation(keyPath: \\"backgroundColor\\")\\ne3.target = layer\\ne3.isEnabled = true\\ne3.duration = 2.0\\nt1.elements = [e3]\\n\\nlet t2 = CAStateTransition()\\nt1.fromState = \\"*\\"\\nt1.toState = \\"inactive\\"\\nlet e4 = CAStateTransitionElement()\\ne4.key = \\"backgroundColor\\"\\ne4.animation = CABasicAnimation(keyPath: \\"backgroundColor\\")\\ne4.target = layer\\ne4.isEnabled = true\\ne4.duration = 2.0\\nt2.elements = [e4]\\n\\nlet t3 = CAStateTransition()\\nt3.fromState = \\"inactive\\"\\nt3.toState = \\"active\\"\\nlet e5 = CAStateTransitionElement()\\ne5.key = \\"backgroundColor\\"\\ne5.animation = CABasicAnimation(keyPath: \\"backgroundColor\\")\\ne5.target = layer\\ne5.isEnabled = true\\ne5.duration = 2.0\\nt3.elements = [e5]\\n\\nlet t4 = CAStateTransition()\\nt4.fromState = \\"active\\"\\nt4.toState = \\"inactive\\"\\nlet e6 = CAStateTransitionElement()\\ne6.key = \\"backgroundColor\\"\\ne6.animation = CABasicAnimation(keyPath: \\"backgroundColor\\")\\ne6.target = layer\\ne6.isEnabled = true\\ne6.duration = 2.0\\nt4.elements = [e6]\\n\\nlayer.states = [s1, s2]\\nlayer.stateTransitions = [t1, t2, t3, t4]\\n\\nDispatchQueue.main.asyncAfter(deadline: .now() + .seconds(1)) {\\n    self.ctrl = CAStateController(layer: layer)!\\n    self.ctrl.setInitialStatesOfLayer(layer, transitionSpeed: 0.5)\\n    \\n    DispatchQueue.main.asyncAfter(deadline: .now() + .seconds(1)) {\\n        self.ctrl.setState(s2, ofLayer: layer, transitionSpeed: 0.5)\\n    }\\n}\\n```\\n\\nTo actually apply and modify states on a layer, you\'ll want to create a `CAStateController`. It\'s simple to use, as you initially call `setInitialStatesOfLayer(_:)`  and to change a state, call `setState(ofLayer:)`. If you include the `transitionSpeed` argument, it\'ll set a duration for any possible transitions to occur (independently of the duration of its `element`s).\\n\\nI don\'t recommend using `CAStateController` and `CAState` without having written a good CoreAnimation \\"Interface Builder\\" to help you design states and layers correctly. Since Apple likely has this tool and we don\'t, it\'s probably why the API is private at the moment. A first step towards this, however, is to use `CAML` packages correctly. There is a `CAPackage` class to aid in all of this, but we\'ll use `CAMLWriter` and `CAMLParser` instead, which mirror `NSKeyedArchiver` and `NSKeyedUnarchiver`, but serialize into a \\"core animation archive\\" (caar) which uses a different XML format. Here\'s a code sample:\\n\\n```swift\\n// Write:\\nlet data = NSMutableData()\\nlet writer = CAMLWriter(data: data)\\nwriter?.encode(layer)\\n\\n// Read:\\nlet parser = CAMLParser()\\n_ = parser.parseData(data as Data)\\nlet layer2 = parser.result as! CALayer\\n```\\n\\nPretty simple right!? Now the challenge is to build an interface designer to model `CALayer`s and `CAState`s. Encode it into a `caml` file and decode it at runtime, and you\'re all set. Use a `CAPackage` to neatly wrap the loading logic -- check out `AVMicaPackage` in AVKit, some of the packages in DictationServices (within PrivateFrameworks/SpeechObjects), or PassKitUIFoundation.\\n\\nRegarding `CAState`, I\'m still not sure what `CAState.locked`, `CAStateElement.source`, `CAStateControllerLayer` (which isn\'t even a `CALayer` subclass??) or `CAStateControllerUndo` (and related `undoStack`) do. I\'ll investigate those but if anyone has any idea, drop me a line and let me know!"},{"id":"/2018/02/18/","metadata":{"permalink":"/blog/2018/02/18/","source":"@site/blog/2018-02-18.md","title":"CAPortalLayer","description":"In the macOS 10.13.4 beta, I spotted a new CALayer class called CAPortalLayer being used in AppKit, and apparently also in UIKit. After looking into it a bit more, it turns out it does exactly what CAPluginLayer did for CGSWindow/NSWindow but for CALayers!","date":"2018-02-18T00:00:00.000Z","formattedDate":"February 18, 2018","tags":[],"readingTime":1.385,"truncated":true,"authors":[],"frontMatter":{},"prevItem":{"title":"CAStateController & Friends","permalink":"/blog/2018/02/19/"},"nextItem":{"title":"CAPluginLayer & CABackdropLayer","permalink":"/blog/2018/02/17/"}},"content":"In the macOS 10.13.4 beta, I spotted a new `CALayer` class called `CAPortalLayer` being used in AppKit, and apparently also in UIKit. After looking into it a bit more, it turns out it does exactly what `CAPluginLayer` did for `CGSWindow`/`NSWindow` but for `CALayer`s! \\n\\n\x3c!--truncate--\x3e\\n\\nI\'ve neglected to provide a screenshot because it really doesn\'t look like much (it does update in realtime though).\\n\\n```swift\\nlet layer = CAPortalLayer()\\nlayer.frame = CGRect(x: 10, y: 10, width: 200, height: 200)\\nlayer.sourceLayer = self.view.layer!\\n//layer.sourceContextId = 0\\n//layer.sourceLayerRenderId = 0\\nlayer.hidesSourceLayer = false // try out true as well!\\n//layer.matchesOpacity = true // apparently always true\\n//layer.matchesPosition = false // apparently always true\\n//layer.matchesTransform = true // apparently always true\\nself.parentView.layer?.addSublayer(layer)\\n```\\n\\nNotice in the code sample, all we needed to do was set `sourceLayer` to an existing valid layer and it worked! There are two more interesting properties here as well: `sourceLayerRenderId` and `sourceContextId` -- it appears that you must set `sourceLayerRenderId` for `sourceContextId` to matter to the render server (backboardd on iOS and windowserver on macOS). What these properties allow you to do is \\"portal\\" a layer from **any process whose context you know of** - just like with `CAPluginLayer`.  Just send the `CAContext.contextId` over the wire from a friendly process and it\'ll render. Unlike `CALayerHost` et al. however, the originating layer will **also** render on-screen (unless `hidesSourceLayer` is `true`). How do you get the `sourceLayerRenderId` you might ask? Here\'s the function prototype: `NSUInteger CALayerGetRenderId(CALayer *);` -- it won\'t be hard.\\n\\nP.S. I originally tested this on iOS using the private `_UIPortalView` class. On macOS, AppKit has `NSPortalView` as well as `NSPortalView1` and `NSPortalView2` for some weird reason."},{"id":"/2018/02/17/","metadata":{"permalink":"/blog/2018/02/17/","source":"@site/blog/2018-02-17.md","title":"CAPluginLayer & CABackdropLayer","description":"There\'s a lot of cool CoreAnimation goodies hiding around in the private headers, but there are three private CALayer classes that really caught my eye: CAProxyLayer, CALayerHost, CABackdropLayer, and CAPluginLayer. CALayerHost is similar in design to CARemoteLayerClient/Server, so I\'ll be writing about both of these classes in a later post. I experimented with CAProxyLayer a little bit, as it\'s used for visual effects (think NS/UIVisualEffectView) and either I didn\'t know the right constants or wasn\'t using it correctly, but I couldn\'t get it to work reliably without nuking windowserver. I\'ll talk about the remaining two, using code samples.","date":"2018-02-17T00:00:00.000Z","formattedDate":"February 17, 2018","tags":[],"readingTime":3.78,"truncated":true,"authors":[],"frontMatter":{},"prevItem":{"title":"CAPortalLayer","permalink":"/blog/2018/02/18/"},"nextItem":{"title":"ViewBridge.framework: It works!","permalink":"/blog/2017/10/01/"}},"content":"There\'s a lot of cool CoreAnimation goodies hiding around in the private headers, but there are three private `CALayer` classes that really caught my eye: `CAProxyLayer`, `CALayerHost`, `CABackdropLayer`, and `CAPluginLayer`. `CALayerHost` is similar in design to `CARemoteLayerClient/Server`, so I\'ll be writing about both of these classes in a later post. I experimented with `CAProxyLayer` a little bit, as it\'s used for visual effects (think `NS/UIVisualEffectView`) and either I didn\'t know the right constants or wasn\'t using it correctly, but I couldn\'t get it to work reliably without nuking `windowserver`. I\'ll talk about the remaining two, using code samples.\\n\\n\x3c!--truncate--\x3e\\n\\n# CAPluginLayer\\n\\nThis one is pretty weirdly named, but it looks like it was designed to support `windowserver` plugins - there\'s even a vtable, but as of right now, only `com.apple.WindowServer.CGSWindow` is supported. Here\'s a code sample:\\n\\n```swift\\nlet layer = CAPluginLayer()\\nlayer.frame = CGRect(x: 50, y: 50, width: 200, height: 200)\\nlayer.pluginType = \\"com.apple.WindowServer.CGSWindow\\"\\nlayer.pluginId = UInt64(self.window.windowNumber)\\nlayer.pluginGravity = kCAGravityResizeAspect\\n//layer.pluginFlags = 0x4 // display without a shadow\\n```\\n\\n![CAPluginLayer Sample](assets/plugin-layer.png)\\n\\nSo the big takeaway is, right now you can only use `CAPluginLayer` to mirror a window in real time (all its UI changes and interactions are reflected in the layer contents). You can set a `pluginGravity` similarly to `contentsGravity`, and the only known `pluginFlags` value is `0x4`, used by Dock to display the window without a shadow. \\n\\nThe `pluginId` actually refers to the `windowNumber` (or `_realWindowNumber` depending on your window type, but that\'s usually not a concern) and actually can be **any window available on screen!* That\'s right - you can mirror any window, not just your own app\'s windows. For fun, I used `CGWindowListCopyWindowInfo` to grab the frontmost window (that wasn\'t my own app\'s) and used that id to mirror it into my app\'s layer. One might conclude at this point that it\'s a huge security violation if I can see the contents of ANY application\'s windows, but that\'s not the case. Using the Xcode UI hierarchy capture tool, you won\'t be able to see anything inside the layer, and this is because `CAPluginLayer` renders within the `windowserver` (and thus requires `layerUsesCoreImageFilters` to be `false`).  \\n\\nThe Dock uses this to display minimized windows and AppKit uses it to manage the toolbar in full-screen window transitions (in which the toolbar and titlebar are actually moved into a new window anchored to the screen\'s menubar). In your own app, supposing you\'re using a long-running XPC daemon for something already, you could request the daemon to help you animate your windows seamlessly if you didn\'t want to use `CGSWindow*` functions or make a fake window screenshot layer and animate that instead. You would send your window\'s `windowNumber` over to the daemon which would use a screen-sized `NSWindow` with a `CAPluginLayer` inside (be sure to set `pluginFlags` to `0x0`!) and animate that layer. There\'s a lot of things wrong with this approach, but it\'s fun to try it out!\\n\\n\\n# CABackdropLayer\\n\\nThe `CABackdropLayer` is used to display layer blending on iOS (`UIVisualEffectView`) and within-window-only layer blending on macOS (`NSVisualEffectView`). Here\'s a code sample:\\n\\n\\n```swift\\nlet layer = CABackdropLayer()\\nlayer.frame = CGRect(x: 0, y: 0, width: 200, height: 200)\\nlayer.allowsHitTesting = true\\nlayer.groupName = \\"group_name_here\\"\\nlayer.windowServerAware = true\\nlet blur = CAFilter(type: kCAFilterGaussianBlur)!\\nblur.setValue(true, forKey: \\"inputNormalizeEdges\\")\\nblur.setValue(30.0, forKey: \\"inputRadius\\")\\nlet saturate = CAFilter(type: kCAFilterColorSaturate)!\\nsaturate.setValue(1.8, forKey: \\"inputAmount\\")\\nlayer.filters = [blur, saturate]\\nlayer.name = \\"backdrop\\"\\nlayer.scale = 0.25\\nlayer.bleedAmount = 0.2\\n```\\n\\n![CABackdropLayer Sample](assets/backdrop-layer.png)\\n\\nWhen using `CABackdropLayer`, be sure to set `windowServerAware` to `true`, and set `layerUsesCoreImageFilters` on its parent view to `false`, otherwise the effect won\'t work (as it\'s also rendered in `windowserver`). Any combination of `CAFilter`s will work on the `CABackdropLayer`, as none that I\'ve tried have failed me yet, but in the code sample, I\'ve replicated the macOS Sierra saturated vibrant light appearance (as close as possible). The `scale` is important to set as I believe it\'s the sampling size of the underlying contents, and setting it to `2.0` made rendering quite slow. I\'m also not sure why, but `groupName` is always set on a backdrop layer and it\'s always unique. It has something to do with `windowserver` rendering as there is a property to make it a \\"globally unique\\" name. \\n\\nI would recommend against using `CABackdropLayer` over `NSVisualEffectView` as there are a lot of edge cases that aren\'t correctly handled unless using the AppKit class, but for an educational exercise or a venture into the wilderness with some interesting filter combinations (maybe `vibrantDark` just isn\'t doing it for you?) it could yield some great blending effects."},{"id":"/2017/10/01/","metadata":{"permalink":"/blog/2017/10/01/","source":"@site/blog/2017-10-01.md","title":"ViewBridge.framework: It works!","description":"Around two years ago I began looking into ViewBridge.framework and a bunch of related frameworks as a side-project, mostly for fun. Realizing I had figured out most of it but just hadn\u2019t put it together, I assembled a quick demo project that worked almost instantly with ViewBridge. All I had to do was create an XPC service, add a few Info.plist keys, grab the headers (I cleaned a few up) and I was on the road.","date":"2017-10-01T00:00:00.000Z","formattedDate":"October 1, 2017","tags":[],"readingTime":0.815,"truncated":true,"authors":[],"frontMatter":{},"prevItem":{"title":"CAPluginLayer & CABackdropLayer","permalink":"/blog/2018/02/17/"},"nextItem":{"title":"Picture-in-Picture on macOS Sierra","permalink":"/blog/2016/08/05/"}},"content":"Around two years ago I began looking into ViewBridge.framework and a bunch of related frameworks as a side-project, mostly for fun. Realizing I had figured out most of it but just hadn\u2019t put it together, I assembled a quick demo project that worked almost instantly with ViewBridge. All I had to do was create an XPC service, add a few Info.plist keys, grab the headers (I cleaned a few up) and I was on the road. \\n\\n\x3c!--truncate--\x3e\\n\\n[You can see the results here.](https://github.com/avaidyam/RemoteViewHost)\\nPut simply, it works, and it works great. There are a few event handling blips, but it does the job and loads the service view in less than 300ms on my machine. The next step for me will be to create a new branch in which I define my own NSExtensionSDK with the NSViewService_PKSubsystem and make it all \u201cextensible\u201d like Today Widgets are. I would have had that working, but pkd refuses to learn my NSExtensionSDK for some reason.\\n\\n![Sample](https://raw.githubusercontent.com/avaidyam/RemoteViewHost/master/Sample.png)"},{"id":"/2016/08/05/","metadata":{"permalink":"/blog/2016/08/05/","source":"@site/blog/2016-08-05.md","title":"Picture-in-Picture on macOS Sierra","description":"Similar to iOS, macOS recently gained Picture-In-Picture mode for videos; so far, only Safari seems to support it out of the box. The question remains: why isn\u2019t it a public API? That\u2019s a question we\u2019ll never have an answer for, but as it turns out, PIP.framework does exist in the PrivateFrameworks realm, and a quick job of reverse engineering shows exactly how it works.","date":"2016-08-05T00:00:00.000Z","formattedDate":"August 5, 2016","tags":[],"readingTime":0.825,"truncated":true,"authors":[],"frontMatter":{},"prevItem":{"title":"ViewBridge.framework: It works!","permalink":"/blog/2017/10/01/"},"nextItem":{"title":"NSExtension  & PlugInKit","permalink":"/blog/2016/07/12/"}},"content":"Similar to iOS, macOS recently gained Picture-In-Picture mode for videos; so far, only Safari seems to support it out of the box. The question remains: why isn\u2019t it a public API? That\u2019s a question we\u2019ll never have an answer for, but as it turns out, PIP.framework does exist in the PrivateFrameworks realm, and a quick job of reverse engineering shows exactly how it works.\\n\\n\x3c!--truncate--\x3e\\n\\nPIPViewController is the entry point for the framework, which allows configuration of a single view in PIP mode; when presentViewControllerAsPictureInPicture is called with any view controller, it animates the view out into a PIPPanel. The PIPPanel actually registers and operates inside of NotificationCenter, allowing notifications to display around it. Surprisingly, that\u2019s really all there is to it. PIPViewController tacks on three buttons (play/pause, close, return) and allows delegates to track things.\\nA picture is worth a thousand words (see what I did there), so I\u2019ve put together a quick SPI sample of how to actually use the framework over [here](https://github.com/avaidyam/PIP-Demo/)!"},{"id":"/2016/07/12/","metadata":{"permalink":"/blog/2016/07/12/","source":"@site/blog/2016-07-12.md","title":"NSExtension  & PlugInKit","description":"Recently I\u2019ve been doing a lot of reverse engineering in the PrivateFrameworks department, simply out of curiosity. One thing that really always bothered me was how to insert a view hierarchy across processes\u200a\u2014\u200aand I was interested in seeing how Apple had done it. A few frameworks of note the NSXPCConnection API, which internally wraps the libxpc.dylib library, found in /usr/lib/system.","date":"2016-07-12T00:00:00.000Z","formattedDate":"July 12, 2016","tags":[],"readingTime":9.47,"truncated":true,"authors":[],"frontMatter":{},"prevItem":{"title":"Picture-in-Picture on macOS Sierra","permalink":"/blog/2016/08/05/"}},"content":"Recently I\u2019ve been doing a lot of reverse engineering in the `PrivateFrameworks` department, simply out of curiosity. One thing that really always bothered me was how to insert a view hierarchy across processes\u200a\u2014\u200aand I was interested in seeing how Apple had done it. A few frameworks of note: `ViewBridge.framework`, `PlugInKit.framework`, `LaunchServices.framework`, and finally, `libextension.dylib`. The last one is a bit weird because it\u2019s actually a high level Objective-C framework that\u2019s tied into `AppKit`\u200a\u2014\u200abut for some reason has been relegated to `/usr/lib` (but is now located in `Foundation.framework` in macOS Sierra). All of the frameworks above use a common transmission medium: the `NSXPCConnection` API, which internally wraps the `libxpc.dylib` library, found in `/usr/lib/system`.\\n\\n\x3c!--truncate--\x3e\\n\\nWith the introductions out of the way, I took a quick look into `ViewBridge.framework`, and realized it was the wrong place to start. I had to start off a little bit lower, down in `PlugInKit.framework` and `libextension.dylib`. In my understanding, the `PlugInKit` serves as generic plugin subsystem hub framework which an app can hook into with a custom subsystem and set of protocols of some sort and start using. The `FxPlug` API for writing Final Cut Pro plugins seems to be based atop `PlugInKit`, along with many others, but modern macOS (Yosemite and beyond) extensions use the newer `NSExtension` API, which is a subsystem to the former framework. In addition, `ViewBridge` framework is also a subsystem to the former framework by tying in `NSViewController`s. An `NSViewController` can be discovered as an extension and then vend its view through the `ViewBridge.framework` into a host application.\\n\\n# `PlugInKit` and `LaunchServices`\\n`PlugInKit`\u2019s life begins with plugin discovery\u200a\u2014\u200aif you take a look at Console and search for \u201cpkd\u201d, you\u2019ll see a lot of interesting things going on related to extension installation. This is really just `LaunchServices`\u2019 private API with a little sprinkles on top. `LSApplicationWorkspace` seems to be `NSWorkspace`\u2019s older and more mature cousin, able to query for applications anywhere on disk with certain properties (like settings bundles on iOS, audio components, VPN plugins, user activity handlers, and URL schemes). In addition, it also allows registering for notifications (`LSApplicationWorkspaceObserver`) when an application is installed (which I assume really means copied and then opened at least once). It allows un/installing applications, opening URLs, and most importantly grabbing plugins from applications. The `LSBundleProxy` and its subclasses provide detailed information (mostly through `Info.plist` hunting) about bundles, applications, resources, plugins, and more. In addition, there is a pluginkit tool that allows system-level control of plugins.\\n\\nEssentially, when an application is installed, pkd picks it up and detects all sorts of metadata within it, including any plugins or extensions it may have. From there, things begin to diverge: `PlugInKit` relies on a conventional model of providing explicit protocol information and formal communication with a plugin; `NSExtension`, the new bees\u2019 knees, relies on an informal \u201cgeneric item\u201d based communication model (as seen in `NSExtensionRequestHandling` for Safari Link extensions) and builds on top of `PlugInKit`. This allows the application to be really flexible with extension protocols.\\n\\n# The NSExtension Host\\n\\nThe NSExtension framework doesn\u2019t have its own plugin discovery system; it uses PlugInKit for that. `+[NSExtension beginMatchingExtensionsWithAttributes:completion:]` internally calls through to `-[[PKHost defaultHost] continuouslyDiscoverPlugInsForAttributes:flags:found:]` with a discovery block. This block enumerates each `PKPlugIn` discovered and transforms them into `NSExtension`s by grabbing necessary properties, and holding a strong reference to them, as seen in `-[NSExtension _initWithPKPlugin:]`. When `+[NSExtension endMatchingExtensions:]` is invoked, it calls through to `-[[PKHost defaultHost] cancelPlugInDiscovery:]`. There\u2019re a couple features I don\u2019t fully understand here yet: `-[NSExtension attemptOptIn:]`, `-[NSExtension attemptOptOut:]`, and `-[NSExtension optedIn]`. All of these call into `-[PKPlugIn userElection]`, of which I\u2019m not sure of the purpose.\\n\\nSo once you have all these extensions, how do you begin using them? `-[NSExtension beginExtensionRequestWithInputItems:completion:]`. What this really does is prepare an internal call on the \u201cGlobalStateQueue\u201d to `-[NSExtension _reallyBeginExtensionRequestWithInputItems:listenerEndpoint:completion:]`, I know, very imaginative name. In the process of this call as well as the matching one to end using the plugin, `-[NSExtension _safelyBeginUsing:]` and `-[NSExtension _safelyEndUsing:]` both call into `-[PKPlugIn beginUsing:]` and `-[PKPlugIn endUsing:]` to prepare anything needed.\\n\\nBack to the main hero here: `_reallyBeginExtensionRequest\u2026:` First, it sets up things where necessary (nil checks for extension contexts or service connection dictionaries), and then ensures to load \u201c`NSExtensionContextHostClass`\u201d if it exists in the extension\u2019s Bundle\u2019s Info.plist. It then invokes `-[NSExtensionContext initWithInputItems:]` with the `inputItems` passed in. It stores the extension data by the context\u2019s UUID in the `NSExtension`\u2019s dictionaries. After configuring the invalidation and interruption handlers on its `NSXPCConnection`, it invokes -resume and grabs the connection\u2019s `remoteObjectProxy`. If it was able to obtain the object proxied (a `_NSExtensionContextVendor` object), it then sets it as the `NSExtensionContext`\u2019s `extensionVendorProxy` (by invoking `-[NSExtensionContext _setExtensionVendorProxy:]`). If the `listenerEndpoint` passed in was nil, it assigns it as the value of `-[NSExtensionContext _auxiliaryListener]`\u2019s endpoint.\\nAnd then we go down the rabbit hole of XPC by invoking `-[_NSExtensionContextVendor _beginRequestWithExtensionItems:listenerEndpoint:withContextUUID:completion:]`. It passes the context UUID to match with an `endRequest` call, so the `NSExtension` knows which `NSExtensionContext` was completed or invalidated. Of course, it also provides the listener endpoint, and the input items. If an error occurs at any stage, if the host cancels the request, or if the request completes successfully, everything is torn down by invoking `__NSExtensionTearDownRequestWithIdentifier`.\\n\\n# The Rabbit Hole that is `PlugInKit`\\n\\nLet\u2019s take a step back and take a look at things from the extension vendor\u2019s point of view first. If you begin a new app extension project, you might notice the lack of a main.c or `NSApplicationMain`. That\u2019s because Xcode performs some magic linker voodoo (flag -e) to set the executable EntryPoint to `_NSExtensionMain`. When the extension host begins a connection to the extension, launchd actually executes the extension, where this function begins. Ideally, if you\u2019ve worked with XPC helpers, what happens is the application invokes `-resume` on the `NSXPCListener`, preferably after setting its delegate to to accept any incoming connections. `NSExtensionMain` calls through to `+[PKService _defaultRun:arguments:]` which then calls through to `-[PKService run]` on the `+[PKService defaultService]`. What follows is pretty interesting: it reveals that `PlugInKit` was originally designed to service multiple SDKs in the Mavericks era, possibly initially servicing FxPlug only\u200a\u2014\u200athe `PKService` instance then sets the `NSXPCListener`\u2019s delegate and calls an interesting method `-[PKService discoverSubsystems]`. What it does is enumerate over `-[PKService configuredSubsystemsList]` which currently checks to see if the bundle\u2019s Info.plist has an \u201c`NSExtension`\u201d or \u201c`PlugInKit`\u201d array\u200a\u2014\u200awithin `-[PKService mergeSubsystems:from:]`, it looks for the key \u201c`NSExtensionPointIdentifier`\u201d, and if it doesn\u2019t exist, \u201cSDK\u201d (a Legacy term) and then invokes `+[PKPlugInCore readSDKDictionary:]` to retrieve the entire dictionary information.\\n\\nInterestingly enough, there\u2019s a function `_xpc_copy_extension_sdk_entry` that\u2019s invoked here and there are references to looking for an \u201c`NSExtensionSDK`\u201d key somewhere. Upon taking a peek into `libxpc.dylib`, it\u2019s easy to see that there are a couple provisional functions: `_xpc_connection_is_extension`, `_launch_extension_check_in_live_4UIKit`, and some more internal `_launch_extension*` functions. It\u2019s a little unnerving to see that there\u2019s so much framework bleed, to the point where it enters launchd, xpc, and two whole plugin oriented frameworks. Also, random sidenote: XPC has a number of painful functions to create an XPC object from a Plist file descriptor\u2026 which ultimately ends up parsing the binary format. :( Anyway, after a lot of processing of the SDK dictionaries, `PKService` checks for any Subsystems involved. One of interest being \u201c`NSViewService_PKSubsystem`\u201d, which pops up in `-[PKService _processDefaultSubsystemName:]`. Once the whole subsystem discovery ends, `PlugInKit` knows exactly what SDKs and subsystems it\u2019ll be vending and I assume it knows their definitions for XPC communication as well. After this, it looks for a `PKServiceDelegate` (with the key \u201cDelegate\u201d) set in the `Info.plist`, and attaches it if it can. Once ALL of this is done, the `NSXPCListener` is resumed.\\n\\nWhen a new connection attempts to connect, if it\u2019s from the correct listener, it creates what is called an \u201c`PKServicePersonality`\u201d with that connection which configures the connection. It exports the `PKCorePlugInProtocol` protocol, and expects the remote interface to be a `PKCoreHostProtocol` (which is basically empty\u2026). The idea is that a `PKService` may either have a number of personalities or a `solePersonality` (either the highest priority or the only personality). These objects encompass the plugin SDK and communications channel, and the service keys them according to the host `processIdentifier` (pid) of the NSXPCConnection. To register or unregister a `PKServicePersonality`, `-[PKService registerPersonality:]` and `-[PKService unregisterPersonality:]` both enqueue operations on the internal `_sync` `DispatchQueue`. `PKService` is also a little bit nifty in that it can be scheduled to terminate the XPC transaction using an internal `dispatch_source_timer` `terminationTimer`, which can also be cancelled later. `PKService` has a number of other useful functions too, such as getting a personality\u2019s connection, defaults, `pluginPrincipal`, `hostPrincipal`, and `embeddedPrincipal`; all of these functions call-through to the `PKServicePersonality` with the appropriate name. In addition, it can also launch the containing application, if on the host\u2019s side of things. Both `PKServicePersonality` and `PKHostPlugIn` are subclasses of `PKPlugInCore`, where most of the heavy lifting seems to happen.\\n\\nWhen PKServicePersonality receives a `-[PKCorePlugInProtocol prepareUsing:reply:]` call, it caches the identifier, `hostProtocol`, version, and uuid. Of particular importance is the `hostProtocol`\u200a\u2014\u200aonce the personality invokes `-[PKServicePersonality setupWithIdentifier:]`, it tries to find the protocol if there is one using `_pkFindProtocol()`. Within that setup method, the personality first invokes `resolveSDK`, then `registerPersonality` with the `PKService`\u2019s `defaultService`. In addition, it prepares a `PKServiceDefaults` for itself and calls `-[PKServicePersonality checkEnvironment:]`. There\u2019s another \u201cprepareUsing\u201d call, `-[PKServicePersonality prepareUsingPlugIn:hostProtocol:reply:]`, but that appears to just call into the former method, and is designated as legacy. This is where things get interesting: the personality enumerates over all subsystems and invokes `-[PKModularService beginUsing:withBundle:]`. This essentially implies that all subsystems conform to `PKModularService`\u2026 and this checks out, as both NSExtension and NSViewService_PKSubsystem and do. When the `PKServicePersonality` receives a `-[PKCorePlugInProtocol shutdownPlugIn]` call, it basically does the opposite: it unregisters itself, invokes `-[PKModularService endUsing:]` on all of the service\u2019s subsystems, and finally calls `-[PKService scheduleTermination:]` on the service. Side note: `PKCorePlugInProtocol` has two preferences methods which simply call down to the `PKServiceDefaults` for the personality.\\n\\n> Well that was fun.\u200a \u2014 \u200aNo one ever.\\n# Where are we really going with this?\\n\\nUltimately, the paragraphs above were just an interactive disassembly of what the system is really doing with extensions. We\u2019ve learned a bit about how tightly integrated they are with the system, to the point where launchd and XPC are getting slightly involved (does no one know the meaning of separation of tasks?) and how `PlugInKit` uses `LaunchServices` through pkd to auto-magically register and unregister plugin bundles. From there, we went through the bootstrap procedure of PlugInKit on the vendor (plugin) side, and how `PlugInKit` is designed around modular services called subsystems. In fact, grab a copy of the system\u2019s runtime headers and grep for `PKModularService`\u200a\u2014\u200athere\u2019s plenty of them. We also covered how `NSExtension` requests can be started and how they snake down the PlugInKit lifeline to reach the vendor. There\u2019s so much more. In fact, this is quite literally the tip of the iceberg; I know there could be facts I may have gotten wrong about this whole shpeel, but it was a fun trip.\\n\\nA fun side project would be to use the extension framework to allow your app to interface with plugins, or even create your own `PlugInKit` modular subsystem (which actually doesn\u2019t seem to be that much of a challenge)! Or perhaps, use the ideas here on a smaller scale (`NSWorkspace` instead of `LaunchServices`, perhaps?) to create your very own `PlugInKit`! In reality, a clone might just be `Info.plist` checking and some XPC magic."}]}')}}]);