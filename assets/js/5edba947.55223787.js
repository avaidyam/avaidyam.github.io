"use strict";(self.webpackChunkAditya_Vaidyam=self.webpackChunkAditya_Vaidyam||[]).push([[222],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=i.createContext({}),d=function(e){var t=i.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},c=function(e){var t=d(e.components);return i.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},u=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),u=d(n),h=a,m=u["".concat(s,".").concat(h)]||u[h]||p[h]||o;return n?i.createElement(m,r(r({ref:t},c),{},{components:n})):i.createElement(m,r({ref:t},c))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,r=new Array(o);r[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,r[1]=l;for(var d=2;d<o;d++)r[d]=n[d];return i.createElement.apply(null,r)}return i.createElement.apply(null,n)}u.displayName="MDXCreateElement"},5736:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>p,frontMatter:()=>o,metadata:()=>l,toc:()=>d});var i=n(7462),a=(n(7294),n(3905));const o={},r="Building a Better RegisterEventHotKey",l={permalink:"/blog/2018/03/16/",source:"@site/blog/2018-03-16.md",title:"Building a Better RegisterEventHotKey",description:"Okay, well, maybe not better, but at least, not under imminent threat of deprecation - and even that is questionable, because we'll be using [Private SPI] (I mean, would you really be here reading this if it didn't? At least I've marked it all so you can cut it out for MAS apps.)",date:"2018-03-16T00:00:00.000Z",formattedDate:"March 16, 2018",tags:[],readingTime:16.195,truncated:!0,authors:[],frontMatter:{},prevItem:{title:"An Exercise in Modern Cocoa Views",permalink:"/blog/2018/03/22/"},nextItem:{title:"The Secret Life of Core Animation",permalink:"/blog/2018/02/22/"}},s={authorsImageUrls:[]},d=[{value:"How does <code>RegisterEventHotKey</code> work?",id:"how-does-registereventhotkey-work",level:2},{value:"Disassembly &amp; Reverse Engineering",id:"disassembly--reverse-engineering",level:3},{value:"CGSHotKey Symbols",id:"cgshotkey-symbols",level:3},{value:"Building a replacement: <code>CGSKeyboardShortcut</code>!",id:"building-a-replacement-cgskeyboardshortcut",level:2},{value:"Properties &amp; Acquisition Policy",id:"properties--acquisition-policy",level:3},{value:"Resource Management",id:"resource-management",level:3},{value:"WindowServer Acquisition &amp; Invalidation",id:"windowserver-acquisition--invalidation",level:3},{value:"Local Event Handling",id:"local-event-handling",level:3},{value:"The Magic Within <code>RegisterEventHotKey</code>",id:"the-magic-within-registereventhotkey",level:3},{value:"Frozen Representations",id:"frozen-representations",level:3},{value:"CGKeyCode &amp; CGEventFlags Supplements",id:"cgkeycode--cgeventflags-supplements",level:3},{value:"Building Higher-Order Recognizers",id:"building-higher-order-recognizers",level:2},{value:"Why?",id:"why",level:3},{value:"How?",id:"how",level:3},{value:"Binding to a <code>CGSKeyboardShortcut</code>",id:"binding-to-a-cgskeyboardshortcut",level:3},{value:"Sample Usage",id:"sample-usage",level:3},{value:"Conclusion",id:"conclusion",level:2}],c={toc:d};function p(e){let{components:t,...o}=e;return(0,a.kt)("wrapper",(0,i.Z)({},c,o,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Okay, well, maybe not better, but at least, not under imminent threat of deprecation - and even that is questionable, because we'll be using ",(0,a.kt)("inlineCode",{parentName:"p"},"[Private SPI]")," (I mean, would you really be here reading this if it didn't? At least I've marked it all so you can cut it out for MAS apps.)"),(0,a.kt)("p",null,"Recently, I've wanted to get around to adding \"hot key\" support for Parrot, and realized I didn't like any of the existing solutions:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Use ",(0,a.kt)("inlineCode",{parentName:"li"},"MASShortcut")," or ",(0,a.kt)("inlineCode",{parentName:"li"},"ShortcutRecorder")," which are tried and proven to work in ObjC-land."),(0,a.kt)("li",{parentName:"ol"},"Use a new but not proven Swift hotkey recorder (there's a few out there)."),(0,a.kt)("li",{parentName:"ol"},"Roll my own using dangerous private SPI and not test it at all! ")),(0,a.kt)("p",null,(0,a.kt)("em",{parentName:"p"},"Obviously I went with option #3.")," "),(0,a.kt)("p",null,'I ended up building a \xb5Framework (everything these days is one, right?) that handles hotkeys, provides a user input and display for hotkeys, and a small high-level recognizer platform to handle them with ease. I\'ll walk you, the reader, through each step! But first, I want to clarify something: the terms "hot key", "key equivalent", "keyboard shortcut", and "mnemonic" are not the same things, on the same or different (i.e. macOS vs Windows) platforms, and so here, I\'ve chosen "keyboard shortcut" as the most descriptive term. '),(0,a.kt)("p",null,"Before we get into the nitty gritty hand-holding pair-programming stuff, if you'd like to jump straight to the comment-annotated final source code, ",(0,a.kt)("a",{parentName:"p",href:"https://gist.github.com/avaidyam/32975976c23dd3b38336f22d971f5eaa"},"I've included a snapshot here."),' It\'s the whole final product, exactly 1500 LOC, including the code from the next "episode" - a corresponding keyboard shortcut recording control! If you think this should be a formal repository and whatnot, contact me on Twitter or Github @avaidyam!'),(0,a.kt)("hr",null),(0,a.kt)("h2",{id:"how-does-registereventhotkey-work"},"How does ",(0,a.kt)("inlineCode",{parentName:"h2"},"RegisterEventHotKey")," work?"),(0,a.kt)("h3",{id:"disassembly--reverse-engineering"},"Disassembly & Reverse Engineering"),(0,a.kt)("p",null,"The first step to designing a better ",(0,a.kt)("inlineCode",{parentName:"p"},"X")," is to understand how ",(0,a.kt)("inlineCode",{parentName:"p"},"X")," works. To do that, whip out ",(0,a.kt)("inlineCode",{parentName:"p"},"Hopper")," (I'm not paid to say this but if you don't have this app yet, you definitely need it!) and disassemble ",(0,a.kt)("inlineCode",{parentName:"p"},"/System/Library/Carbon.framework/Frameworks/HIToolbox.framework"),". Locate the function and take a peek -- or, if you'd like, ",(0,a.kt)("a",{parentName:"p",href:"https://gist.github.com/avaidyam/18b7c3d0a15afade931d10a27ed53872"},"just take a look at my cleaned up version of the function here.")," I also added a similar function from ",(0,a.kt)("inlineCode",{parentName:"p"},"ScreenReader.framework")," to cross-reference with."),(0,a.kt)("p",null,"All the function basically does is wrap its parameters into an internal data type and call through to ",(0,a.kt)("inlineCode",{parentName:"p"},"SkyLight.framework")," (you may know it as ",(0,a.kt)("inlineCode",{parentName:"p"},"CoreGraphicsServices"),", from ",(0,a.kt)("inlineCode",{parentName:"p"},"CoreGraphics.framework")," on pre-macOS 12) while keeping track of the hotkey registration in a static var dictionary. I'll come back to the CoreGraphics call in a little bit, because this function does something very interesting... we'll also ignore the ",(0,a.kt)("inlineCode",{parentName:"p"},"CGSSetHotButtonWithExclusion")," call, which is actually an alias for the function ",(0,a.kt)("inlineCode",{parentName:"p"},"CGSSetHotKeyRepresentationWithOptions"),", because that's not what we want right now. We'll instead be using ",(0,a.kt)("inlineCode",{parentName:"p"},"CGSSetHotKeyWithExclusion"),". "),(0,a.kt)("h3",{id:"cgshotkey-symbols"},"CGSHotKey Symbols"),(0,a.kt)("p",null,"Here's a complete list of ",(0,a.kt)("inlineCode",{parentName:"p"},"CGSHot*")," symbols:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"CGSGetHotButton")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"CGSGetHotKeyRepresentation")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"CGSGetHotKeyType")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"CGSGetHotModifier")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"CGSSetHotButtonWithExclusion")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"CGSSetHotKeyEnabled")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"CGSSetHotKeyRepresentation")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"CGSSetHotKeyRepresentationWithOptions")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"CGSSetHotKeyType")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"CGSSetHotKeyWithExclusion")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"CGSSetHotKeyWithOptions")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"CGSSetHotModifierWithExclusion")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"CGSSetHotModifierWithOptions")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"CGSGetSymbolicHotKeyButtonValue")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"CGSGetSymbolicHotKeyRepresentation")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"CGSGetSymbolicHotKeyRepresentationList")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"CGSGetSymbolicHotKeyValuesAndStates")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"CGSGetSymbolicHotModifierValue")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"CGSSetSymbolicHotKey")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"CGSSetSymbolicHotKeyButtonValue")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"CGSSetSymbolicHotKeyEnabledForConnection")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"CGSSetSymbolicHotKeyRepresentation")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"CGSSetSymbolicHotKeyValue")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"CGSSetSymbolicHotKeyWithExclusion")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"CGSSetSymbolicHotKeyWithOptions")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"CGSSetSymbolicHotModifierValue")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"CGSIsSymbolicHotKeyEnabledForConnection"))),(0,a.kt)("p",null,'I\'ll demystify some of these symbols: there are two types of "hot" events: ',(0,a.kt)("strong",{parentName:"p"},"regular"),", and ",(0,a.kt)("strong",{parentName:"p"},"symbolic"),". Symbolic hot events are those that the ",(0,a.kt)("inlineCode",{parentName:"p"},"WindowServer")," has designated and named. ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/NUIKit/CGSInternal/blob/master/CGSHotKeys.h#L38"},"You can find a near-full list of symbolic identifiers here."),' These include things like Expos\xe9 or Screenshot keys, basically those that are defined in the "System Preferences > Keyboard > Shortcut" pane. '),(0,a.kt)("p",null,"Now, within these types, there are subtypes: ",(0,a.kt)("inlineCode",{parentName:"p"},"HotKey"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"HotButton"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"HotModifier"),", and ",(0,a.kt)("inlineCode",{parentName:"p"},"HotKeyRepresentation"),". ",(0,a.kt)("inlineCode",{parentName:"p"},"HotButton")," is actually just an alias for ",(0,a.kt)("inlineCode",{parentName:"p"},"HotKeyRepresentation"),", which I'll admit, I'm not savvy to the reason behind its specific distinction. ",(0,a.kt)("inlineCode",{parentName:"p"},"HotModifier")," is just that -- a modifier press that activates an event, like Siri or Dictation shortcuts. Finally, what we want, is the ",(0,a.kt)("inlineCode",{parentName:"p"},"HotKey")," facility, which is a plain old keyboard shortcut, with a virtual key code, and a modifier list. "),(0,a.kt)("p",null,"There is a special ",(0,a.kt)("inlineCode",{parentName:"p"},"WithExclusion")," function, which calls through to ",(0,a.kt)("inlineCode",{parentName:"p"},"WithOptions")," (presumably, there are more options, but I doubt any are used right now): setting a hot key with exclusion implies that no other application (including the calling one) may register this same hot key again, and if it was already acquired by another application, the call fails. As far as I'm able to tell, this is the behavior, but I can't be sure since I haven't dug deeper into this option."),(0,a.kt)("hr",null),(0,a.kt)("h2",{id:"building-a-replacement-cgskeyboardshortcut"},"Building a replacement: ",(0,a.kt)("inlineCode",{parentName:"h2"},"CGSKeyboardShortcut"),"!"),(0,a.kt)("p",null,"Since we've got a cursory understanding of how the existing Carbon facility works, and what hot events facilities Window Server offers, we can architect our own version. "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-swift"},"public final class CGSKeyboardShortcut: Hashable {\n    // ...\n}\n")),(0,a.kt)("h3",{id:"properties--acquisition-policy"},"Properties & Acquisition Policy"),(0,a.kt)("p",null,"A keyboard shortcut needs a virtual key code (",(0,a.kt)("inlineCode",{parentName:"p"},"CGKeyCode"),"), modifier flags (",(0,a.kt)("inlineCode",{parentName:"p"},"CGEventFlags"),", instead of ",(0,a.kt)("inlineCode",{parentName:"p"},"NSEvent.ModifierFlags"),"), and an identifier (we'll create a intly-typed wrapper, for better developer&user-side management), at the very least."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-swift"},"public struct Identifier: RawRepresentable, Hashable, Codable {\n    public typealias RawValue = Int\n    public let rawValue: Identifier.RawValue\n    public init(rawValue: Identifier.RawValue) {\n        self.rawValue = rawValue\n    }\n    public init(_ rawValue: Identifier.RawValue) {\n        self.rawValue = rawValue\n    }\n}\n\npublic let identifier: CGSKeyboardShortcut.Identifier\npublic let keyCode: CGKeyCode\npublic let modifierFlags: CGEventFlags\n")),(0,a.kt)("p",null,"Now, returning to the issue of ",(0,a.kt)("inlineCode",{parentName:"p"},"WithExclusion"),", we'll also add an ",(0,a.kt)("inlineCode",{parentName:"p"},"AcquisitionPolicy")," to handle that:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-swift"},"public enum AcquisitionPolicy: Int, Codable {\n    case none\n    case exclusively\n    case exclusivelyIfPossible\n}\npublic let acquisitionPolicy: AcquisitionPolicy\n\npublic init(identifier: CGSKeyboardShortcut.Identifier, keyCode: CGKeyCode,\n       modifierFlags: CGEventFlags, acquisitionPolicy: AcquisitionPolicy = .none) throws\n{\n    // ...\n    self.identifier = identifier\n    self.keyCode = keyCode\n    self.modifierFlags = modifierFlags\n    self.acquisitionPolicy = acquisitionPolicy\n    // ...\n}\n")),(0,a.kt)("p",null,"Essentially, this will be the policy to use when initializing a new ",(0,a.kt)("inlineCode",{parentName:"p"},"CGSKeyboardShortcut")," - do we want to do so ",(0,a.kt)("inlineCode",{parentName:"p"},"exclusively"),", not (",(0,a.kt)("inlineCode",{parentName:"p"},"none"),") at all, or maybe ",(0,a.kt)("inlineCode",{parentName:"p"},"exclusivelyIfPossible"),"? The final option is a special case where we'll attempt to be exclusive, but if someone else got to the shortcut first, we still do want a shortcut event delivered to our handler. (Note that we shouldn't be considering this value in equality between two ",(0,a.kt)("inlineCode",{parentName:"p"},"CGSKeyboardShortcut"),"s.)"),(0,a.kt)("h3",{id:"resource-management"},"Resource Management"),(0,a.kt)("p",null,"Since keyboard shortcuts are something of a finite resource (there are only so many key combinations viable for user input) and application or component acquisition matters, we'll keep a ",(0,a.kt)("inlineCode",{parentName:"p"},"Set")," of registered keyboard shortcuts at all times, but note that we can only keep track of the shortcuts tracked through our new facility, and not those by ",(0,a.kt)("inlineCode",{parentName:"p"},"CGS")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"HIToolbox")," facilities, unfortunately."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-swift"},"public private(set) static var all: Set<CGSKeyboardShortcut> = []\n\npublic init(...) {\n    guard CGSKeyboardShortcut.all.filter({ $0.identifier == identifier }).count == 0 else {\n        throw CGError.cannotComplete\n    }\n    // ...\n    CGSKeyboardShortcut.all.insert(self)\n}\n\ndeinit {\n    CGSKeyboardShortcut.all.remove(self)\n}\n")),(0,a.kt)("p",null,"There is an issue with this mechanism as it stands, though. If we'd like to invalidate a keyboard shortcut, we have no way of ",(0,a.kt)("inlineCode",{parentName:"p"},"deinit"),"ing it without removing it from the ",(0,a.kt)("inlineCode",{parentName:"p"},"Set"),", which only happens upon ",(0,a.kt)("inlineCode",{parentName:"p"},"deinit"),"! That's a problem, so we'll add an explicit ",(0,a.kt)("inlineCode",{parentName:"p"},"invalidate")," method (or two)."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-swift"},"\ndeinit {\n    self.invalidate()\n}\npublic func invalidate() {\n    // ...\n    CGSKeyboardShortcut.all.remove(self)\n}\npublic static func invalidateAll() {\n    CGSKeyboardShortcut.all = []\n}\n")),(0,a.kt)("p",null,"There, that's a little better. Now, we don't need to hold an explicit reference to a shortcut to keep it valid, and we'll need this ",(0,a.kt)("inlineCode",{parentName:"p"},"Set")," for actually handling shortcuts soon anyway. "),(0,a.kt)("h3",{id:"windowserver-acquisition--invalidation"},"WindowServer Acquisition & Invalidation"),(0,a.kt)("p",null,"Now that we've defined our shortcut class and its containment/usage policies, how do we actually... you know, make it do stuff? For that, we'll need to add a suffix to our file here:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-swift"},'// Here lie dragons!\nfileprivate typealias CGSConnectionID = UInt\n@_silgen_name("CGSMainConnectionID")\nfileprivate func CGSMainConnectionID() -> CGSConnectionID\n@_silgen_name("CGSSetHotKeyWithExclusion")\nfileprivate func CGSSetHotKeyWithExclusion(_ connection: CGSConnectionID,\n                                           _ hotKeyID: Int,\n                                           _ hotKeyMask: UInt16, // always 0xffff\n                                           _ keyCode: UInt16,\n                                           _ modifierFlags: UInt64,\n                                           _ options: Int8) -> CGError\n@_silgen_name("CGSSetHotKeyType")\nfileprivate func CGSSetHotKeyType(_ connection: CGSConnectionID,\n                                  _ hotKeyID: Int,\n                                  _ options: Int8) -> CGError\n@_silgen_name("CGSSetHotKeyEnabled")\nfileprivate func CGSSetHotKeyEnabled(_ connection: CGSConnectionID,\n                                     _ hotKeyID: Int,\n                                     _ enabled: Bool) -> CGError\n@_silgen_name("CGSIsHotKeyEnabled")\nfileprivate func CGSIsHotKeyEnabled(_ connection: CGSConnectionID,\n                                    _ hotKeyID: Int) -> Bool\n@_silgen_name("CGSRemoveHotKey")\nfileprivate func CGSRemoveHotKey(_ connection: CGSConnectionID,\n                                 _ hotKeyID: Int) -> CGError\n')),(0,a.kt)("p",null,"This is a horrible terrible idea. But then again, you've read this much already, so you're probably okay with this sick twisted kind of stuff. :)  After elucidating the function arguments, we're using ",(0,a.kt)("inlineCode",{parentName:"p"},"@_silgen_name"),' to tell the Swift compiler that "hey, these functions exist somewhere, so just go along with my devious plans". Obviously, if anything goes wrong, you\'re on your own. Be careful with this block of code. '),(0,a.kt)("p",null,"Now we'll register and unregister the shortcut where necessary, and add a way to enable or disable the shortcut (since ",(0,a.kt)("inlineCode",{parentName:"p"},"WindowServer")," allows us this functionality)."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-swift"},"\npublic var isEnabled: Bool {\n    get { return CGSIsHotKeyEnabled(CGSMainConnectionID(), self.identifier.rawValue) }\n    set { _ = CGSSetHotKeyEnabled(CGSMainConnectionID(), self.identifier.rawValue, newValue) }\n}\n\npublic init(...) {\n    // ...\n\n    var error: CGError = .success\n    error = CGSSetHotKeyWithExclusion(CGSMainConnectionID(), self.identifier.rawValue,\n                                      0xffff, self.keyCode, self.modifierFlags.rawValue,\n                                      self.acquisitionPolicy == .none ? 0x0 : 0x1)\n    \n    // If our acquisition policy can fallback, register non-exclusively.\n    if error == .noneAvailable && self.acquisitionPolicy == .exclusivelyIfPossible {\n        error = CGSSetHotKeyWithExclusion(CGSMainConnectionID(), self.identifier.rawValue,\n                                          0xffff, self.keyCode, self.modifierFlags.rawValue, 0x0)\n    }\n    guard error == .success else { throw error }\n    \n    error = CGSSetHotKeyType(CGSMainConnectionID(), self.identifier.rawValue, 0x1)\n    guard error == .success else { throw error }\n\n    // ...\n}\n\npublic func invalidate() {\n    _ = CGSRemoveHotKey(CGSMainConnectionID(), self.identifier.rawValue)\n    // ...\n}\n")),(0,a.kt)("h3",{id:"local-event-handling"},"Local Event Handling"),(0,a.kt)("p",null,"Alright, now we've got a functioning shortcut right? Not yet! We actually need to get ",(0,a.kt)("inlineCode",{parentName:"p"},"WindowServer")," to send ",(0,a.kt)("strong",{parentName:"p"},"us")," specifically the event for the shortcut! However, (it turns out, in macOS 6+) ",(0,a.kt)("inlineCode",{parentName:"p"},"NSApplication")," actually handles these kinds of events in ",(0,a.kt)("inlineCode",{parentName:"p"},"-sendEvent:"),", but we need to register an event monitor to be notified of them. Let's use a local ",(0,a.kt)("inlineCode",{parentName:"p"},"NSEvent")," monitor to trampoline notifications into ",(0,a.kt)("inlineCode",{parentName:"p"},"NotificationCenter"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-swift"},'public static let pressedNotification = Notification.Name("CGSKeyboardShortcut.pressedNotification")\npublic static let releasedNotification = Notification.Name("CGSKeyboardShortcut.releasedNotification")\n\nprivate static var monitor = NSEvent.addLocalMonitorForEvents(matching: .systemDefined) { event in\n    if [6, 9].contains(event.subtype.rawValue) {\n        CGSKeyboardShortcut.all.filter { $0.identifier.rawValue == event.data1 }.forEach { obj in\n            let name: Notification.Name = event.subtype.rawValue == 6\n                ? CGSKeyboardShortcut.pressedNotification /* 6 */\n                : CGSKeyboardShortcut.releasedNotification /* 9 */\n            NotificationCenter.default.post(name: name, object: obj)\n        }\n        return nil // consumed\n    }\n    return event\n}\n\npublic init(...) {\n    _ = CGSKeyboardShortcut.monitor // bootstrap!\n    // ...\n}\n')),(0,a.kt)("p",null,"All we've done here is grab the shortcut identifier from the ",(0,a.kt)("inlineCode",{parentName:"p"},"data1")," field of the ",(0,a.kt)("inlineCode",{parentName:"p"},".systemDefined")," event if it's of ",(0,a.kt)("inlineCode",{parentName:"p"},"subtype")," ",(0,a.kt)("inlineCode",{parentName:"p"},"6")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"9"),", which are the ",(0,a.kt)("inlineCode",{parentName:"p"},"-keyDown:")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"-keyUp:"),' event subtypes, respectively. Once we\'ve done so, and our facility registered the shortcut (that is, not Carbon or another CGS client), bounce the event into a notification. Be sure to "bootstrap" the event monitor in your ',(0,a.kt)("inlineCode",{parentName:"p"},"init"),", otherwise it'll never be initialized and trampoline shortcut events."),(0,a.kt)("p",null,"Here, I've explicitly chosen to use ",(0,a.kt)("inlineCode",{parentName:"p"},"NotificationCenter")," over a delegation or target-action/handler pattern, because it turns a single-producer (the user input) single-consumer (portions of our app) model into a single-producer multiple-consumer pattern. With a single shortcut registration, multiple components can share event information. If we wanted a shortcut to be exclusive to the app, but multiple components acted on it, we would either end up in a hairy mess or end up using ",(0,a.kt)("inlineCode",{parentName:"p"},"NotificationCenter")," anyway. "),(0,a.kt)("h3",{id:"the-magic-within-registereventhotkey"},"The Magic Within ",(0,a.kt)("inlineCode",{parentName:"h3"},"RegisterEventHotKey")),(0,a.kt)("p",null,"Remember how earlier, I said ",(0,a.kt)("inlineCode",{parentName:"p"},"RegisterEventHotKey")," was doing something interesting? It ",(0,a.kt)("inlineCode",{parentName:"p"},"malloc"),"'s what I'm dubbing a ",(0,a.kt)("inlineCode",{parentName:"p"},"HotButtonData")," to hold hot key parameters (presumably) and uses its pointer as the hot key identifier! Holy carp, that's insanely bad practice! It is, however, an extremely intelligent alternative to our global ",(0,a.kt)("inlineCode",{parentName:"p"},"Set"),". That was really it. I found it pretty interesting, and I'm not even really sure if that was developer-intended or a compiler optimization/mangling of some sort. :)"),(0,a.kt)("h3",{id:"frozen-representations"},"Frozen Representations"),(0,a.kt)("p",null,"While we've now built a complete and functional shortcut facility, we have no way of storing a shortcut in a non-live, or frozen, way. We could make our class ",(0,a.kt)("inlineCode",{parentName:"p"},"Codable"),", our initializer is where shortcut registration occurs, and invoking a ",(0,a.kt)("inlineCode",{parentName:"p"},"Codable")," initializer should not have any side effects. Instead, I've opted for a design that mirrors only the internal properties of the shortcut class but with no activity of its own, called ",(0,a.kt)("inlineCode",{parentName:"p"},"CGSKeyboardShortcut.Definition"),". It's effectively a frozen version of a ",(0,a.kt)("inlineCode",{parentName:"p"},"CGSKeyboardShortcut"),", and we can use this type to inform the client of our class that explicit initialization is required. While there may be better approaches to this problem, I feel that this solution separates the notion of a live shortcut and a frozen one pretty cleanly."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-swift"},"public struct Definition: Hashable, Codable {\n    public let identifier: CGSKeyboardShortcut.Identifier\n    public let keyCode: CGKeyCode\n    public let modifierFlags: CGEventFlags\n    public let acquisitionPolicy: AcquisitionPolicy\n    \n    public init(identifier: CGSKeyboardShortcut.Identifier, keyCode: CGKeyCode, modifierFlags: CGEventFlags, acquisitionPolicy: AcquisitionPolicy) {\n        self.identifier = identifier\n        self.keyCode = keyCode\n        self.modifierFlags = modifierFlags\n        self.acquisitionPolicy = acquisitionPolicy\n    }\n}\n\npublic convenience init(definition: Definition) throws {\n    try self.init(identifier: definition.identifier, keyCode: definition.keyCode,\n                  modifierFlags: definition.modifierFlags,\n                  acquisitionPolicy: definition.acquisitionPolicy)\n}\n\npublic var definition: Definition {\n    return Definition(identifier: self.identifier, keyCode: self.keyCode,\n                      modifierFlags: self.modifierFlags,\n                      acquisitionPolicy: self.acquisitionPolicy)\n}\n")),(0,a.kt)("h3",{id:"cgkeycode--cgeventflags-supplements"},"CGKeyCode & CGEventFlags Supplements"),(0,a.kt)("p",null,"Finally, we're not out of the woods yet. There's a slight issue with registering a shortcut with any old ",(0,a.kt)("inlineCode",{parentName:"p"},"NSEvent"),"-provided modifier flags - only a few flag bits are allowed (the physical key modifer ones)! Modify the line in ",(0,a.kt)("inlineCode",{parentName:"p"},"init(...) { ... }")," that reads ",(0,a.kt)("inlineCode",{parentName:"p"},"self.modifierFlags = modifierFlags")," to ",(0,a.kt)("inlineCode",{parentName:"p"},"self.modifierFlags = modifierFlags.intersection(.maskShortcutFlags)"),". We'll define a few extensions to ",(0,a.kt)("inlineCode",{parentName:"p"},"CGEventFlags")," to support this, and to allow conversion between ",(0,a.kt)("inlineCode",{parentName:"p"},"NSEvent.ModifierFlags"),". In addition, we'll conform ",(0,a.kt)("inlineCode",{parentName:"p"},"CGError")," to ",(0,a.kt)("inlineCode",{parentName:"p"},"Error")," since it's not already for some reason..."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-swift"},"extension CGError: Error {}\n\nextension CGEventFlags: Hashable, Codable {\n    public var hashValue: Int { return self.rawValue.hashValue }\n}\n\npublic extension CGEventFlags {\n    public init(_ flags: NSEvent.ModifierFlags) {\n        self.init(rawValue: UInt64(flags.rawValue))\n    }\n    \n    public static let maskDeviceIndependentFlags = CGEventFlags(rawValue: 0x00000000ffff0000)\n    public static let maskShortcutFlags = CGEventFlags(rawValue: 0x0000000000ff0000)\n    public static let maskUserFlags: CGEventFlags = [.maskCommand, .maskControl, .maskShift, .maskAlternate]\n}\n\npublic extension NSEvent.ModifierFlags {\n    public init(_ flags: CGEventFlags) {\n        self.init(rawValue: UInt(flags.rawValue))\n    }\n}\n")),(0,a.kt)("hr",null),(0,a.kt)("h2",{id:"building-higher-order-recognizers"},"Building Higher-Order Recognizers"),(0,a.kt)("h3",{id:"why"},"Why?"),(0,a.kt)("p",null,"Realistically, a developer could use the ",(0,a.kt)("inlineCode",{parentName:"p"},"CGSKeyboardShortcut")," class as is and be perfectly fine! It does everything, after all, from maintaining the shortcut list, to trampolining events into notifications, and more. However, building \"higher-order\" facilities to handle complex interactions is well worth it, even if it means a little more code to accomplish the simple use-case (because remember, we're not removing the original facility, only building atop it). Let's define a ",(0,a.kt)("inlineCode",{parentName:"p"},"ShortcutRecognizer")," protocol that takes two inputs: ",(0,a.kt)("inlineCode",{parentName:"p"},"keyDown")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"keyUp"),", but does not provide a standard output. It'll be up to our implementing classes to do that."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-swift"},"public protocol ShortcutRecognizer: class {\n    func keyDown()\n    func keyUp()\n}\n")),(0,a.kt)("p",null,"So what would handling a shortcut, the normal way, look like with this protocol?"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-swift"},"public final class PressShortcutRecognizer: ShortcutRecognizer {\n    public let handler: () -> ()\n    public init(_ handler: @escaping () -> ()) {\n        self.handler = handler\n    }\n    \n    public func keyDown() {\n        /// ignored!\n    }\n    \n    public func keyUp() {\n        self.handler()\n    }\n}\n")),(0,a.kt)("p",null,"Ugh, that's like, 10 extra lines of code and another class to deal with! But that's not the point! We've written something that doesn't actually rely on ",(0,a.kt)("inlineCode",{parentName:"p"},"CGS")," facilities or even our ",(0,a.kt)("inlineCode",{parentName:"p"},"CGSKeyboardShortcut")," facility! We don't even need to use this for shortcuts! It can do anything! (Maybe limiting its scope is a good thing to do though...) "),(0,a.kt)("h3",{id:"how"},"How?"),(0,a.kt)("p",null,"Okay, but the whole point of a recognizer type was to be able to simplify complex interactions, so how about this, an action in my app requires the user to do this exact sequence:  ",(0,a.kt)("inlineCode",{parentName:"p"},"keyDown")," -> ",(0,a.kt)("inlineCode",{parentName:"p"},"keyUp")," -> ",(0,a.kt)("inlineCode",{parentName:"p"},"keyDown")," within 1sec -> ",(0,a.kt)("inlineCode",{parentName:"p"},"keyUp")," after 2sec. "),(0,a.kt)("p",null,"It'll be a ",(0,a.kt)("inlineCode",{parentName:"p"},"TapHoldShortcutRecognizer")," with a variable hold duration:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-swift"},"public final class TapHoldShortcutRecognizer: ShortcutRecognizer {\n    private var timeInterval = DispatchTimeInterval.seconds(0)\n    \n    public let handler: () -> ()\n    public init(for t: DispatchTimeInterval = .seconds(2), _ handler: @escaping () -> ()) {\n        self.timeInterval = t\n        self.handler = handler\n    }\n    \n    public func keyDown() {\n        // ...\n    }\n    \n    public func keyUp() {\n        // ...\n    }\n}\n")),(0,a.kt)("p",null,"Since we actually never need to handle the first ",(0,a.kt)("inlineCode",{parentName:"p"},"keyUp"),", let's handle the double ",(0,a.kt)("inlineCode",{parentName:"p"},"keyDown")," first, using a bool as well as a time marker, to maintain the inter-",(0,a.kt)("inlineCode",{parentName:"p"},"keyDown")," and hold durations. "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-swift"},"private var timeReference: CFAbsoluteTime = 0.0\nprivate var inDoubleTap = false\n\npublic func keyDown() {\n    defer { self.timeReference = CFAbsoluteTimeGetCurrent() }\n    guard CFAbsoluteTimeGetCurrent() - self.timeReference < 1.0 else { return } // double-tapped\n\n    self.inDoubleTap = true\n    DispatchQueue.main.asyncAfter(deadline: .now() + self.timeInterval) {\n        // ...\n    }\n}\n")),(0,a.kt)("p",null,"We've put the time tracking in a ",(0,a.kt)("inlineCode",{parentName:"p"},"defer { ... }")," statement because we want it execute only after the method has finished processing; it's just a marker of when we noticed the ",(0,a.kt)("inlineCode",{parentName:"p"},"keyDown"),", after all. This way, our ",(0,a.kt)("inlineCode",{parentName:"p"},"guard")," statement isn't affected either, and we can ignore the inter-",(0,a.kt)("inlineCode",{parentName:"p"},"keyDown")," interval. Notice that we're only using ",(0,a.kt)("inlineCode",{parentName:"p"},"DispatchTimeInterval")," for the hold duration, to play nice with ",(0,a.kt)("inlineCode",{parentName:"p"},"DispatchQueue.asyncAfter(...)"),". Once we enter the hold phase (that is, ",(0,a.kt)("inlineCode",{parentName:"p"},"keyDown")," -> ",(0,a.kt)("inlineCode",{parentName:"p"},"keyUp")," -> ",(0,a.kt)("inlineCode",{parentName:"p"},"keyDown")," within 1sec -> ...), we can defer to the ",(0,a.kt)("inlineCode",{parentName:"p"},"keyUp()")," function."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-swift"},'// ...\n    DispatchQueue.main.asyncAfter(deadline: .now() + self.timeInterval) {\n        guard self.inDoubleTap else { return }\n        self.inDoubleTap = false\n        DispatchQueue.main.async(execute: self.handler)\n    }\n}\n\npublic func keyUp() {\n    guard self.inDoubleTap else { return }\n    self.inDoubleTap = false\n    print("shortcut recognizer failed because hold duration was \\(CFAbsoluteTimeGetCurrent() - self.timeReference)s")\n}\n')),(0,a.kt)("p",null,"For the hold phase, we essentially race the user input to our designated hold duration: if the user gets there first (pressing the shortcut before the hold duration is up), we unset the double tap flag and bail our handler execution. Our inter-",(0,a.kt)("inlineCode",{parentName:"p"},"keyDown")," phase waited on the user to fail to ",(0,a.kt)("inlineCode",{parentName:"p"},"keyUp")," so it could invoke the handler when we reached our hold duration. Clever, but there's probably a design pattern or something for this."),(0,a.kt)("h3",{id:"binding-to-a-cgskeyboardshortcut"},"Binding to a ",(0,a.kt)("inlineCode",{parentName:"h3"},"CGSKeyboardShortcut")),(0,a.kt)("p",null,"It's now pretty simple to create a binder between a recognizer and a ",(0,a.kt)("inlineCode",{parentName:"p"},"CGSKeyboardShortcut"),", by just adding the recognizer as an observer of... two... notifications... that's a little bit unwieldy. Instead, we can add a convenience function to add observers for both notifications and then return a single disposable value. If that value is ",(0,a.kt)("inlineCode",{parentName:"p"},"deinit"),"'ed, both observers are invalidated and the recognizer is effectively unbound! It's pretty straightforward."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-swift"},"public extension ShortcutRecognizer {\n    public func bind(to shortcut: CGSKeyboardShortcut) -> Any {\n        let x = NotificationCenter.default.addObserver(forName: CGSKeyboardShortcut.pressedNotification, object: shortcut, queue: nil) { _ in\n            self.keyDown()\n        }\n        let y = NotificationCenter.default.addObserver(forName: CGSKeyboardShortcut.releasedNotification, object: shortcut, queue: nil) { _ in\n            self.keyUp()\n        }\n        return _Holder([x, y])\n    }\n}\n\n// Implementation Detail:\nclass _Holder {\n    private let observers: [Any]\n    public init(_ observers: [Any]) {\n        self.observers = observers\n    }\n}\n")),(0,a.kt)("h3",{id:"sample-usage"},"Sample Usage"),(0,a.kt)("p",null,"Complex user shortcut interaction becomes much cleaner now! Here's how we can use all of this together:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-swift"},'let hotkey = try CGSKeyboardShortcut(identifier: .myShortcut,\n                                     keyCode: 0x7E,\n                                     modifierFlags: [.maskCommand, .maskControl],\n                                     acquisitionPolicy: .exclusivelyIfPossible)\nlet tracker = TapHoldShortcutRecognizer {\n    _ = NSAlert(style: .informational, text: "Double tap and hold succeeded!").runModal()\n}\nself.observer = tracker.bind(to: hotkey)\n\n// ... elsewhere ...\npublic extension CGSKeyboardShortcut.Identifier {\n    public static let myShortcut = CGSKeyboardShortcut.Identifier(0xBAAAAAAD)\n}\n')),(0,a.kt)("p",null,(0,a.kt)("em",{parentName:"p"},"(That ",(0,a.kt)("inlineCode",{parentName:"em"},"NSAlert")," initializer is pretty easy to implement and is left as an exercise for the reader.)")),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"Sample Alert",src:n(4536).Z,width:"1064",height:"526"})),(0,a.kt)("hr",null),(0,a.kt)("h2",{id:"conclusion"},"Conclusion"),(0,a.kt)("p",null,"In short, there are better ways to do keyboard shortcuts than to resign to Carbon. Unfortunately, for those targeting the Mac App Store, this has just been an exercise in futility. An alternate implementation of ",(0,a.kt)("inlineCode",{parentName:"p"},"CGSKeyboardShortcut")," could probably just wrap ",(0,a.kt)("inlineCode",{parentName:"p"},"RegisterEventHotKey")," but that's no fun is it? Might as well just use ",(0,a.kt)("inlineCode",{parentName:"p"},"MASShortcut")," or something else and not deal with writing it yourself. "),(0,a.kt)("p",null,"In the next episode, I'll be designing and developing a corresponding view to display and record keyboard shortcuts! If you have any questions, comments, or concerns, contact me on Twitter or Github @avaidyam!"))}p.isMDXComponent=!0},4536:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/shortcut-recognizer-action-f45fcc8970120ce12943725d24f79007.png"}}]);