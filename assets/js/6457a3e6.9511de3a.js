"use strict";(self.webpackChunkAditya_Vaidyam=self.webpackChunkAditya_Vaidyam||[]).push([[496],{4609:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>p});var i=t(8168),o=(t(6540),t(5680));const a={},r="NSExtension  & PlugInKit",s={permalink:"/blog/2016/07/12/",source:"@site/blog/2016-07-12.md",title:"NSExtension  & PlugInKit",description:"Recently I\u2019ve been doing a lot of reverse engineering in the PrivateFrameworks department, simply out of curiosity. One thing that really always bothered me was how to insert a view hierarchy across processes\u200a\u2014\u200aand I was interested in seeing how Apple had done it. A few frameworks of note the NSXPCConnection API, which internally wraps the libxpc.dylib library, found in /usr/lib/system.",date:"2016-07-12T00:00:00.000Z",formattedDate:"July 12, 2016",tags:[],readingTime:9.47,hasTruncateMarker:!0,authors:[],frontMatter:{},prevItem:{title:"Picture-in-Picture on macOS Sierra",permalink:"/blog/2016/08/05/"}},l={authorsImageUrls:[]},p=[],d={toc:p},c="wrapper";function h(e){let{components:n,...t}=e;return(0,o.yg)(c,(0,i.A)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,o.yg)("p",null,"Recently I\u2019ve been doing a lot of reverse engineering in the ",(0,o.yg)("inlineCode",{parentName:"p"},"PrivateFrameworks")," department, simply out of curiosity. One thing that really always bothered me was how to insert a view hierarchy across processes\u200a\u2014\u200aand I was interested in seeing how Apple had done it. A few frameworks of note: ",(0,o.yg)("inlineCode",{parentName:"p"},"ViewBridge.framework"),", ",(0,o.yg)("inlineCode",{parentName:"p"},"PlugInKit.framework"),", ",(0,o.yg)("inlineCode",{parentName:"p"},"LaunchServices.framework"),", and finally, ",(0,o.yg)("inlineCode",{parentName:"p"},"libextension.dylib"),". The last one is a bit weird because it\u2019s actually a high level Objective-C framework that\u2019s tied into ",(0,o.yg)("inlineCode",{parentName:"p"},"AppKit"),"\u200a\u2014\u200abut for some reason has been relegated to ",(0,o.yg)("inlineCode",{parentName:"p"},"/usr/lib")," (but is now located in ",(0,o.yg)("inlineCode",{parentName:"p"},"Foundation.framework")," in macOS Sierra). All of the frameworks above use a common transmission medium: the ",(0,o.yg)("inlineCode",{parentName:"p"},"NSXPCConnection")," API, which internally wraps the ",(0,o.yg)("inlineCode",{parentName:"p"},"libxpc.dylib")," library, found in ",(0,o.yg)("inlineCode",{parentName:"p"},"/usr/lib/system"),"."),(0,o.yg)("p",null,"With the introductions out of the way, I took a quick look into ",(0,o.yg)("inlineCode",{parentName:"p"},"ViewBridge.framework"),", and realized it was the wrong place to start. I had to start off a little bit lower, down in ",(0,o.yg)("inlineCode",{parentName:"p"},"PlugInKit.framework")," and ",(0,o.yg)("inlineCode",{parentName:"p"},"libextension.dylib"),". In my understanding, the ",(0,o.yg)("inlineCode",{parentName:"p"},"PlugInKit")," serves as generic plugin subsystem hub framework which an app can hook into with a custom subsystem and set of protocols of some sort and start using. The ",(0,o.yg)("inlineCode",{parentName:"p"},"FxPlug")," API for writing Final Cut Pro plugins seems to be based atop ",(0,o.yg)("inlineCode",{parentName:"p"},"PlugInKit"),", along with many others, but modern macOS (Yosemite and beyond) extensions use the newer ",(0,o.yg)("inlineCode",{parentName:"p"},"NSExtension")," API, which is a subsystem to the former framework. In addition, ",(0,o.yg)("inlineCode",{parentName:"p"},"ViewBridge")," framework is also a subsystem to the former framework by tying in ",(0,o.yg)("inlineCode",{parentName:"p"},"NSViewController"),"s. An ",(0,o.yg)("inlineCode",{parentName:"p"},"NSViewController")," can be discovered as an extension and then vend its view through the ",(0,o.yg)("inlineCode",{parentName:"p"},"ViewBridge.framework")," into a host application."),(0,o.yg)("h1",{id:"pluginkit-and-launchservices"},(0,o.yg)("inlineCode",{parentName:"h1"},"PlugInKit")," and ",(0,o.yg)("inlineCode",{parentName:"h1"},"LaunchServices")),(0,o.yg)("p",null,(0,o.yg)("inlineCode",{parentName:"p"},"PlugInKit"),"\u2019s life begins with plugin discovery\u200a\u2014\u200aif you take a look at Console and search for \u201cpkd\u201d, you\u2019ll see a lot of interesting things going on related to extension installation. This is really just ",(0,o.yg)("inlineCode",{parentName:"p"},"LaunchServices"),"\u2019 private API with a little sprinkles on top. ",(0,o.yg)("inlineCode",{parentName:"p"},"LSApplicationWorkspace")," seems to be ",(0,o.yg)("inlineCode",{parentName:"p"},"NSWorkspace"),"\u2019s older and more mature cousin, able to query for applications anywhere on disk with certain properties (like settings bundles on iOS, audio components, VPN plugins, user activity handlers, and URL schemes). In addition, it also allows registering for notifications (",(0,o.yg)("inlineCode",{parentName:"p"},"LSApplicationWorkspaceObserver"),") when an application is installed (which I assume really means copied and then opened at least once). It allows un/installing applications, opening URLs, and most importantly grabbing plugins from applications. The ",(0,o.yg)("inlineCode",{parentName:"p"},"LSBundleProxy")," and its subclasses provide detailed information (mostly through ",(0,o.yg)("inlineCode",{parentName:"p"},"Info.plist")," hunting) about bundles, applications, resources, plugins, and more. In addition, there is a pluginkit tool that allows system-level control of plugins."),(0,o.yg)("p",null,"Essentially, when an application is installed, pkd picks it up and detects all sorts of metadata within it, including any plugins or extensions it may have. From there, things begin to diverge: ",(0,o.yg)("inlineCode",{parentName:"p"},"PlugInKit")," relies on a conventional model of providing explicit protocol information and formal communication with a plugin; ",(0,o.yg)("inlineCode",{parentName:"p"},"NSExtension"),", the new bees\u2019 knees, relies on an informal \u201cgeneric item\u201d based communication model (as seen in ",(0,o.yg)("inlineCode",{parentName:"p"},"NSExtensionRequestHandling")," for Safari Link extensions) and builds on top of ",(0,o.yg)("inlineCode",{parentName:"p"},"PlugInKit"),". This allows the application to be really flexible with extension protocols."),(0,o.yg)("h1",{id:"the-nsextension-host"},"The NSExtension Host"),(0,o.yg)("p",null,"The NSExtension framework doesn\u2019t have its own plugin discovery system; it uses PlugInKit for that. ",(0,o.yg)("inlineCode",{parentName:"p"},"+[NSExtension beginMatchingExtensionsWithAttributes:completion:]")," internally calls through to ",(0,o.yg)("inlineCode",{parentName:"p"},"-[[PKHost defaultHost] continuouslyDiscoverPlugInsForAttributes:flags:found:]")," with a discovery block. This block enumerates each ",(0,o.yg)("inlineCode",{parentName:"p"},"PKPlugIn")," discovered and transforms them into ",(0,o.yg)("inlineCode",{parentName:"p"},"NSExtension"),"s by grabbing necessary properties, and holding a strong reference to them, as seen in ",(0,o.yg)("inlineCode",{parentName:"p"},"-[NSExtension _initWithPKPlugin:]"),". When ",(0,o.yg)("inlineCode",{parentName:"p"},"+[NSExtension endMatchingExtensions:]")," is invoked, it calls through to ",(0,o.yg)("inlineCode",{parentName:"p"},"-[[PKHost defaultHost] cancelPlugInDiscovery:]"),". There\u2019re a couple features I don\u2019t fully understand here yet: ",(0,o.yg)("inlineCode",{parentName:"p"},"-[NSExtension attemptOptIn:]"),", ",(0,o.yg)("inlineCode",{parentName:"p"},"-[NSExtension attemptOptOut:]"),", and ",(0,o.yg)("inlineCode",{parentName:"p"},"-[NSExtension optedIn]"),". All of these call into ",(0,o.yg)("inlineCode",{parentName:"p"},"-[PKPlugIn userElection]"),", of which I\u2019m not sure of the purpose."),(0,o.yg)("p",null,"So once you have all these extensions, how do you begin using them? ",(0,o.yg)("inlineCode",{parentName:"p"},"-[NSExtension beginExtensionRequestWithInputItems:completion:]"),". What this really does is prepare an internal call on the \u201cGlobalStateQueue\u201d to ",(0,o.yg)("inlineCode",{parentName:"p"},"-[NSExtension _reallyBeginExtensionRequestWithInputItems:listenerEndpoint:completion:]"),", I know, very imaginative name. In the process of this call as well as the matching one to end using the plugin, ",(0,o.yg)("inlineCode",{parentName:"p"},"-[NSExtension _safelyBeginUsing:]")," and ",(0,o.yg)("inlineCode",{parentName:"p"},"-[NSExtension _safelyEndUsing:]")," both call into ",(0,o.yg)("inlineCode",{parentName:"p"},"-[PKPlugIn beginUsing:]")," and ",(0,o.yg)("inlineCode",{parentName:"p"},"-[PKPlugIn endUsing:]")," to prepare anything needed."),(0,o.yg)("p",null,"Back to the main hero here: ",(0,o.yg)("inlineCode",{parentName:"p"},"_reallyBeginExtensionRequest\u2026:")," First, it sets up things where necessary (nil checks for extension contexts or service connection dictionaries), and then ensures to load \u201c",(0,o.yg)("inlineCode",{parentName:"p"},"NSExtensionContextHostClass"),"\u201d if it exists in the extension\u2019s Bundle\u2019s Info.plist. It then invokes ",(0,o.yg)("inlineCode",{parentName:"p"},"-[NSExtensionContext initWithInputItems:]")," with the ",(0,o.yg)("inlineCode",{parentName:"p"},"inputItems")," passed in. It stores the extension data by the context\u2019s UUID in the ",(0,o.yg)("inlineCode",{parentName:"p"},"NSExtension"),"\u2019s dictionaries. After configuring the invalidation and interruption handlers on its ",(0,o.yg)("inlineCode",{parentName:"p"},"NSXPCConnection"),", it invokes -resume and grabs the connection\u2019s ",(0,o.yg)("inlineCode",{parentName:"p"},"remoteObjectProxy"),". If it was able to obtain the object proxied (a ",(0,o.yg)("inlineCode",{parentName:"p"},"_NSExtensionContextVendor")," object), it then sets it as the ",(0,o.yg)("inlineCode",{parentName:"p"},"NSExtensionContext"),"\u2019s ",(0,o.yg)("inlineCode",{parentName:"p"},"extensionVendorProxy")," (by invoking ",(0,o.yg)("inlineCode",{parentName:"p"},"-[NSExtensionContext _setExtensionVendorProxy:]"),"). If the ",(0,o.yg)("inlineCode",{parentName:"p"},"listenerEndpoint")," passed in was nil, it assigns it as the value of ",(0,o.yg)("inlineCode",{parentName:"p"},"-[NSExtensionContext _auxiliaryListener]"),"\u2019s endpoint.\nAnd then we go down the rabbit hole of XPC by invoking ",(0,o.yg)("inlineCode",{parentName:"p"},"-[_NSExtensionContextVendor _beginRequestWithExtensionItems:listenerEndpoint:withContextUUID:completion:]"),". It passes the context UUID to match with an ",(0,o.yg)("inlineCode",{parentName:"p"},"endRequest")," call, so the ",(0,o.yg)("inlineCode",{parentName:"p"},"NSExtension")," knows which ",(0,o.yg)("inlineCode",{parentName:"p"},"NSExtensionContext")," was completed or invalidated. Of course, it also provides the listener endpoint, and the input items. If an error occurs at any stage, if the host cancels the request, or if the request completes successfully, everything is torn down by invoking ",(0,o.yg)("inlineCode",{parentName:"p"},"__NSExtensionTearDownRequestWithIdentifier"),"."),(0,o.yg)("h1",{id:"the-rabbit-hole-that-is-pluginkit"},"The Rabbit Hole that is ",(0,o.yg)("inlineCode",{parentName:"h1"},"PlugInKit")),(0,o.yg)("p",null,"Let\u2019s take a step back and take a look at things from the extension vendor\u2019s point of view first. If you begin a new app extension project, you might notice the lack of a main.c or ",(0,o.yg)("inlineCode",{parentName:"p"},"NSApplicationMain"),". That\u2019s because Xcode performs some magic linker voodoo (flag -e) to set the executable EntryPoint to ",(0,o.yg)("inlineCode",{parentName:"p"},"_NSExtensionMain"),". When the extension host begins a connection to the extension, launchd actually executes the extension, where this function begins. Ideally, if you\u2019ve worked with XPC helpers, what happens is the application invokes ",(0,o.yg)("inlineCode",{parentName:"p"},"-resume")," on the ",(0,o.yg)("inlineCode",{parentName:"p"},"NSXPCListener"),", preferably after setting its delegate to to accept any incoming connections. ",(0,o.yg)("inlineCode",{parentName:"p"},"NSExtensionMain")," calls through to ",(0,o.yg)("inlineCode",{parentName:"p"},"+[PKService _defaultRun:arguments:]")," which then calls through to ",(0,o.yg)("inlineCode",{parentName:"p"},"-[PKService run]")," on the ",(0,o.yg)("inlineCode",{parentName:"p"},"+[PKService defaultService]"),". What follows is pretty interesting: it reveals that ",(0,o.yg)("inlineCode",{parentName:"p"},"PlugInKit")," was originally designed to service multiple SDKs in the Mavericks era, possibly initially servicing FxPlug only\u200a\u2014\u200athe ",(0,o.yg)("inlineCode",{parentName:"p"},"PKService")," instance then sets the ",(0,o.yg)("inlineCode",{parentName:"p"},"NSXPCListener"),"\u2019s delegate and calls an interesting method ",(0,o.yg)("inlineCode",{parentName:"p"},"-[PKService discoverSubsystems]"),". What it does is enumerate over ",(0,o.yg)("inlineCode",{parentName:"p"},"-[PKService configuredSubsystemsList]")," which currently checks to see if the bundle\u2019s Info.plist has an \u201c",(0,o.yg)("inlineCode",{parentName:"p"},"NSExtension"),"\u201d or \u201c",(0,o.yg)("inlineCode",{parentName:"p"},"PlugInKit"),"\u201d array\u200a\u2014\u200awithin ",(0,o.yg)("inlineCode",{parentName:"p"},"-[PKService mergeSubsystems:from:]"),", it looks for the key \u201c",(0,o.yg)("inlineCode",{parentName:"p"},"NSExtensionPointIdentifier"),"\u201d, and if it doesn\u2019t exist, \u201cSDK\u201d (a Legacy term) and then invokes ",(0,o.yg)("inlineCode",{parentName:"p"},"+[PKPlugInCore readSDKDictionary:]")," to retrieve the entire dictionary information."),(0,o.yg)("p",null,"Interestingly enough, there\u2019s a function ",(0,o.yg)("inlineCode",{parentName:"p"},"_xpc_copy_extension_sdk_entry")," that\u2019s invoked here and there are references to looking for an \u201c",(0,o.yg)("inlineCode",{parentName:"p"},"NSExtensionSDK"),"\u201d key somewhere. Upon taking a peek into ",(0,o.yg)("inlineCode",{parentName:"p"},"libxpc.dylib"),", it\u2019s easy to see that there are a couple provisional functions: ",(0,o.yg)("inlineCode",{parentName:"p"},"_xpc_connection_is_extension"),", ",(0,o.yg)("inlineCode",{parentName:"p"},"_launch_extension_check_in_live_4UIKit"),", and some more internal ",(0,o.yg)("inlineCode",{parentName:"p"},"_launch_extension*")," functions. It\u2019s a little unnerving to see that there\u2019s so much framework bleed, to the point where it enters launchd, xpc, and two whole plugin oriented frameworks. Also, random sidenote: XPC has a number of painful functions to create an XPC object from a Plist file descriptor\u2026 which ultimately ends up parsing the binary format. :( Anyway, after a lot of processing of the SDK dictionaries, ",(0,o.yg)("inlineCode",{parentName:"p"},"PKService")," checks for any Subsystems involved. One of interest being \u201c",(0,o.yg)("inlineCode",{parentName:"p"},"NSViewService_PKSubsystem"),"\u201d, which pops up in ",(0,o.yg)("inlineCode",{parentName:"p"},"-[PKService _processDefaultSubsystemName:]"),". Once the whole subsystem discovery ends, ",(0,o.yg)("inlineCode",{parentName:"p"},"PlugInKit")," knows exactly what SDKs and subsystems it\u2019ll be vending and I assume it knows their definitions for XPC communication as well. After this, it looks for a ",(0,o.yg)("inlineCode",{parentName:"p"},"PKServiceDelegate")," (with the key \u201cDelegate\u201d) set in the ",(0,o.yg)("inlineCode",{parentName:"p"},"Info.plist"),", and attaches it if it can. Once ALL of this is done, the ",(0,o.yg)("inlineCode",{parentName:"p"},"NSXPCListener")," is resumed."),(0,o.yg)("p",null,"When a new connection attempts to connect, if it\u2019s from the correct listener, it creates what is called an \u201c",(0,o.yg)("inlineCode",{parentName:"p"},"PKServicePersonality"),"\u201d with that connection which configures the connection. It exports the ",(0,o.yg)("inlineCode",{parentName:"p"},"PKCorePlugInProtocol")," protocol, and expects the remote interface to be a ",(0,o.yg)("inlineCode",{parentName:"p"},"PKCoreHostProtocol")," (which is basically empty\u2026). The idea is that a ",(0,o.yg)("inlineCode",{parentName:"p"},"PKService")," may either have a number of personalities or a ",(0,o.yg)("inlineCode",{parentName:"p"},"solePersonality")," (either the highest priority or the only personality). These objects encompass the plugin SDK and communications channel, and the service keys them according to the host ",(0,o.yg)("inlineCode",{parentName:"p"},"processIdentifier")," (pid) of the NSXPCConnection. To register or unregister a ",(0,o.yg)("inlineCode",{parentName:"p"},"PKServicePersonality"),", ",(0,o.yg)("inlineCode",{parentName:"p"},"-[PKService registerPersonality:]")," and ",(0,o.yg)("inlineCode",{parentName:"p"},"-[PKService unregisterPersonality:]")," both enqueue operations on the internal ",(0,o.yg)("inlineCode",{parentName:"p"},"_sync")," ",(0,o.yg)("inlineCode",{parentName:"p"},"DispatchQueue"),". ",(0,o.yg)("inlineCode",{parentName:"p"},"PKService")," is also a little bit nifty in that it can be scheduled to terminate the XPC transaction using an internal ",(0,o.yg)("inlineCode",{parentName:"p"},"dispatch_source_timer")," ",(0,o.yg)("inlineCode",{parentName:"p"},"terminationTimer"),", which can also be cancelled later. ",(0,o.yg)("inlineCode",{parentName:"p"},"PKService")," has a number of other useful functions too, such as getting a personality\u2019s connection, defaults, ",(0,o.yg)("inlineCode",{parentName:"p"},"pluginPrincipal"),", ",(0,o.yg)("inlineCode",{parentName:"p"},"hostPrincipal"),", and ",(0,o.yg)("inlineCode",{parentName:"p"},"embeddedPrincipal"),"; all of these functions call-through to the ",(0,o.yg)("inlineCode",{parentName:"p"},"PKServicePersonality")," with the appropriate name. In addition, it can also launch the containing application, if on the host\u2019s side of things. Both ",(0,o.yg)("inlineCode",{parentName:"p"},"PKServicePersonality")," and ",(0,o.yg)("inlineCode",{parentName:"p"},"PKHostPlugIn")," are subclasses of ",(0,o.yg)("inlineCode",{parentName:"p"},"PKPlugInCore"),", where most of the heavy lifting seems to happen."),(0,o.yg)("p",null,"When PKServicePersonality receives a ",(0,o.yg)("inlineCode",{parentName:"p"},"-[PKCorePlugInProtocol prepareUsing:reply:]")," call, it caches the identifier, ",(0,o.yg)("inlineCode",{parentName:"p"},"hostProtocol"),", version, and uuid. Of particular importance is the ",(0,o.yg)("inlineCode",{parentName:"p"},"hostProtocol"),"\u200a\u2014\u200aonce the personality invokes ",(0,o.yg)("inlineCode",{parentName:"p"},"-[PKServicePersonality setupWithIdentifier:]"),", it tries to find the protocol if there is one using ",(0,o.yg)("inlineCode",{parentName:"p"},"_pkFindProtocol()"),". Within that setup method, the personality first invokes ",(0,o.yg)("inlineCode",{parentName:"p"},"resolveSDK"),", then ",(0,o.yg)("inlineCode",{parentName:"p"},"registerPersonality")," with the ",(0,o.yg)("inlineCode",{parentName:"p"},"PKService"),"\u2019s ",(0,o.yg)("inlineCode",{parentName:"p"},"defaultService"),". In addition, it prepares a ",(0,o.yg)("inlineCode",{parentName:"p"},"PKServiceDefaults")," for itself and calls ",(0,o.yg)("inlineCode",{parentName:"p"},"-[PKServicePersonality checkEnvironment:]"),". There\u2019s another \u201cprepareUsing\u201d call, ",(0,o.yg)("inlineCode",{parentName:"p"},"-[PKServicePersonality prepareUsingPlugIn:hostProtocol:reply:]"),", but that appears to just call into the former method, and is designated as legacy. This is where things get interesting: the personality enumerates over all subsystems and invokes ",(0,o.yg)("inlineCode",{parentName:"p"},"-[PKModularService beginUsing:withBundle:]"),". This essentially implies that all subsystems conform to ",(0,o.yg)("inlineCode",{parentName:"p"},"PKModularService"),"\u2026 and this checks out, as both NSExtension and NSViewService_PKSubsystem and do. When the ",(0,o.yg)("inlineCode",{parentName:"p"},"PKServicePersonality")," receives a ",(0,o.yg)("inlineCode",{parentName:"p"},"-[PKCorePlugInProtocol shutdownPlugIn]")," call, it basically does the opposite: it unregisters itself, invokes ",(0,o.yg)("inlineCode",{parentName:"p"},"-[PKModularService endUsing:]")," on all of the service\u2019s subsystems, and finally calls ",(0,o.yg)("inlineCode",{parentName:"p"},"-[PKService scheduleTermination:]")," on the service. Side note: ",(0,o.yg)("inlineCode",{parentName:"p"},"PKCorePlugInProtocol")," has two preferences methods which simply call down to the ",(0,o.yg)("inlineCode",{parentName:"p"},"PKServiceDefaults")," for the personality."),(0,o.yg)("blockquote",null,(0,o.yg)("p",{parentName:"blockquote"},"Well that was fun.\u200a \u2014 \u200aNo one ever."),(0,o.yg)("h1",{parentName:"blockquote",id:"where-are-we-really-going-with-this"},"Where are we really going with this?")),(0,o.yg)("p",null,"Ultimately, the paragraphs above were just an interactive disassembly of what the system is really doing with extensions. We\u2019ve learned a bit about how tightly integrated they are with the system, to the point where launchd and XPC are getting slightly involved (does no one know the meaning of separation of tasks?) and how ",(0,o.yg)("inlineCode",{parentName:"p"},"PlugInKit")," uses ",(0,o.yg)("inlineCode",{parentName:"p"},"LaunchServices")," through pkd to auto-magically register and unregister plugin bundles. From there, we went through the bootstrap procedure of PlugInKit on the vendor (plugin) side, and how ",(0,o.yg)("inlineCode",{parentName:"p"},"PlugInKit")," is designed around modular services called subsystems. In fact, grab a copy of the system\u2019s runtime headers and grep for ",(0,o.yg)("inlineCode",{parentName:"p"},"PKModularService"),"\u200a\u2014\u200athere\u2019s plenty of them. We also covered how ",(0,o.yg)("inlineCode",{parentName:"p"},"NSExtension")," requests can be started and how they snake down the PlugInKit lifeline to reach the vendor. There\u2019s so much more. In fact, this is quite literally the tip of the iceberg; I know there could be facts I may have gotten wrong about this whole shpeel, but it was a fun trip."),(0,o.yg)("p",null,"A fun side project would be to use the extension framework to allow your app to interface with plugins, or even create your own ",(0,o.yg)("inlineCode",{parentName:"p"},"PlugInKit")," modular subsystem (which actually doesn\u2019t seem to be that much of a challenge)! Or perhaps, use the ideas here on a smaller scale (",(0,o.yg)("inlineCode",{parentName:"p"},"NSWorkspace")," instead of ",(0,o.yg)("inlineCode",{parentName:"p"},"LaunchServices"),", perhaps?) to create your very own ",(0,o.yg)("inlineCode",{parentName:"p"},"PlugInKit"),"! In reality, a clone might just be ",(0,o.yg)("inlineCode",{parentName:"p"},"Info.plist")," checking and some XPC magic."))}h.isMDXComponent=!0},5680:(e,n,t)=>{t.d(n,{xA:()=>d,yg:()=>y});var i=t(6540);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,i,o=function(e,n){if(null==e)return{};var t,i,o={},a=Object.keys(e);for(i=0;i<a.length;i++)t=a[i],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)t=a[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var l=i.createContext({}),p=function(e){var n=i.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},d=function(e){var n=p(e.components);return i.createElement(l.Provider,{value:n},e.children)},c="mdxType",h={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},g=i.forwardRef((function(e,n){var t=e.components,o=e.mdxType,a=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),c=p(t),g=o,y=c["".concat(l,".").concat(g)]||c[g]||h[g]||a;return t?i.createElement(y,r(r({ref:n},d),{},{components:t})):i.createElement(y,r({ref:n},d))}));function y(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var a=t.length,r=new Array(a);r[0]=g;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[c]="string"==typeof e?e:o,r[1]=s;for(var p=2;p<a;p++)r[p]=t[p];return i.createElement.apply(null,r)}return i.createElement.apply(null,t)}g.displayName="MDXCreateElement"}}]);