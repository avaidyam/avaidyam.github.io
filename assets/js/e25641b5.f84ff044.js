"use strict";(self.webpackChunkAditya_Vaidyam=self.webpackChunkAditya_Vaidyam||[]).push([[632],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>m});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),c=p(n),m=r,u=c["".concat(l,".").concat(m)]||c[m]||h[m]||o;return n?a.createElement(u,i(i({ref:t},d),{},{components:n})):a.createElement(u,i({ref:t},d))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=c;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var p=2;p<o;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},3364:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var a=n(7462),r=(n(7294),n(3905));const o={},i="The Secret Life of Core Animation",s={permalink:"/blog/2018/02/22/",source:"@site/blog/2018-02-22.md",title:"The Secret Life of Core Animation",description:"Most developers know of Core Animation through its few key classes, such as CALayer and CAAnimation, and their subclasses. Very few need to venture past this realm to take advantage of this powerful framework. What's not very clear to most is how many faces the framework takes on; there are three: CoreAnimation, CoreAnimationCF, and the internal C++ CoreAnimation underpinnings.",date:"2018-02-22T00:00:00.000Z",formattedDate:"February 22, 2018",tags:[],readingTime:5.38,truncated:!0,authors:[],frontMatter:{},prevItem:{title:"Building a Better RegisterEventHotKey",permalink:"/blog/2018/03/16/"},nextItem:{title:"CAStateController & Friends",permalink:"/blog/2018/02/19/"}},l={authorsImageUrls:[]},p=[],d={toc:p};function h(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Most developers know of Core Animation through its few key classes, such as ",(0,r.kt)("inlineCode",{parentName:"p"},"CALayer")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"CAAnimation"),", and their subclasses. Very few need to venture past this realm to take advantage of this powerful framework. What's not very clear to most is how many faces the framework takes on; there are three: ",(0,r.kt)("inlineCode",{parentName:"p"},"CoreAnimation"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"CoreAnimationCF"),", and the internal C++ CoreAnimation underpinnings. "),(0,r.kt)("p",null,"All three are contained within the single ",(0,r.kt)("inlineCode",{parentName:"p"},"QuartzCore.framework")," - I've managed to recreate a majority (if not all) the private headers for the first two (C++ is a lot harder unfortunately), and I suggest the reader ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/avaidyam/QuartzInternal"},"take a peek at them first over here.")," For the third facet, I've produced a list of some, but not all, ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/avaidyam/QuartzInternal/wiki/Private-CoreAnimation-CPP-Packages"},"the packages (namespaces) being used"),", and I suggest the reader take a look at those as well."),(0,r.kt)("p",null,'Let\'s start with the first one: the "normal" ',(0,r.kt)("inlineCode",{parentName:"p"},"CoreAnimation")," - the one that runs atop Objective-C and is the only publicly marked API for any App Store apps. The easiest way to begin using it is to link AppKit or UIKit and ",(0,r.kt)("inlineCode",{parentName:"p"},"NSView")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"UIView")," will take care of the rest for you. You just need to interface your view's layer, animate properties as needed, and so on. There is one small indexing trick used internally called ",(0,r.kt)("inlineCode",{parentName:"p"},"CAAtom")," --  using ",(0,r.kt)("inlineCode",{parentName:"p"},"CAAtomGetString")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"CAInternAtom"),", you can convert between a key path (string) and an indexed id used internally. In addition to atoms, the ",(0,r.kt)("inlineCode",{parentName:"p"},"CAObject_*")," family of functions (",(0,r.kt)("inlineCode",{parentName:"p"},"attributesForKey/Path"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"valueForKey/Path"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"setValueForKey/Path"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"initWithCoder"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"encodeWithCoder/CAMLWriter"),", etc) are used within ",(0,r.kt)("inlineCode",{parentName:"p"},"CALayer")," and friends to keep track of arbitrary values for arbitrary keys. This is why you're able to set any layer keyPath and it won't throw a ",(0,r.kt)("inlineCode",{parentName:"p"},"valueForUndefinedKey:")," exception. Past this, there's not much else to see here that isn't public."),(0,r.kt)("p",null,"The interesting stuff starts with ",(0,r.kt)("inlineCode",{parentName:"p"},"CoreAnimationCF"),": it's a barebones version of the above API... all in pure C using the ",(0,r.kt)("inlineCode",{parentName:"p"},"CoreFoundation")," library only. You've got contexts, layers, rendering, and animations. If you haven't already, take a look at the source code above. Why does this exist at all? Because Core Animation actually is cross-platform (along a few other Apple libraries, including Core Graphics)! WebKit and iTunes, for example, have existing DLLs for all of these frameworks, but since they don't rely on Objective-C, they use the CF flavor of this API. Should a macOS/iOS developer be using this API? Really, probably not - there's nothing you can't do in the normal API that ",(0,r.kt)("inlineCode",{parentName:"p"},"CoreAnimationCF")," will help you with. You'll also notice, some API are missing, like ",(0,r.kt)("inlineCode",{parentName:"p"},"CATransaction"),"."),(0,r.kt)("p",null,"The final facet is the most interesting, and is pretty much a mystery to me (and remains undocumented by anyone else, AFAIK) -- the C++ API. Through one ObjC protocol (",(0,r.kt)("inlineCode",{parentName:"p"},"CARenderValue"),"), all of the ObjC API (that is, the first facet) can be translated into the C++ API by calling ",(0,r.kt)("inlineCode",{parentName:"p"},"CA_copyRenderValue"),"). If you haven't already, take a look at the list of packages above, because you'll notice some striking similarities. My cursory understanding of this API is that, the render server (be it a background thread or a separate process) copies the context and its layer tree's render values and can encode/decode them privately, relieving the ObjC/developer-facing API of any misuse or unexpected results. All of the ",(0,r.kt)("inlineCode",{parentName:"p"},"CA::Render::")," packages/classes correspond to an ObjC layer or animation class, and once packaged up and sent over, the render server would directly manipulate these entities using the ",(0,r.kt)("inlineCode",{parentName:"p"},"CA::OGL::")," packages/classes via a ",(0,r.kt)("inlineCode",{parentName:"p"},"SW")," (software) renderer, ",(0,r.kt)("inlineCode",{parentName:"p"},"OGL")," (OpenGL), or ",(0,r.kt)("inlineCode",{parentName:"p"},"Metal")," renderer (which is likely used on all Apple platforms). In the middle, however, is ",(0,r.kt)("inlineCode",{parentName:"p"},"CA::CG::"),", which looks like a lot of drawing routines that resemble Core Graphics (that is, ",(0,r.kt)("inlineCode",{parentName:"p"},"CGContext"),")..."),(0,r.kt)("p",null,"The way ",(0,r.kt)("inlineCode",{parentName:"p"},"CGContext")," works, is that it has an internal ",(0,r.kt)("inlineCode",{parentName:"p"},"CGGState")," stack, and a current ",(0,r.kt)("inlineCode",{parentName:"p"},"GState")," (top of the stack), that all its clients set and manipulate via draw calls, but under the hood, ",(0,r.kt)("inlineCode",{parentName:"p"},"CGContextDelegate")," translates these calls into a specific surface. ",(0,r.kt)("inlineCode",{parentName:"p"},"CGSWindow")," has a ",(0,r.kt)("inlineCode",{parentName:"p"},"CGContextWindowDelegate")," that when a ",(0,r.kt)("inlineCode",{parentName:"p"},"NSWindow"),"s (or their non-layer-backed views) need to draw, is passed as the delegate to ",(0,r.kt)("inlineCode",{parentName:"p"},"CGWindowContextCreate")," and handles this translation layer. Similarly, a ",(0,r.kt)("inlineCode",{parentName:"p"},"CALayer")," likely creates its context using the ",(0,r.kt)("inlineCode",{parentName:"p"},"CA::CG::")," packages as a delegate, allowing the draw calls and GState modifications to map into whatever renderer is being currently used. "),(0,r.kt)("p",null,"Finally, there's one thing about both the internal C++ and public ObjC API that not many folks have documented or picked up on: ",(0,r.kt)("inlineCode",{parentName:"p"},"CATransaction"),"'s commit handlers and ",(0,r.kt)("inlineCode",{parentName:"p"},"CAContext"),". Every process that needs to work with a layer (or more) requires at least one ",(0,r.kt)("inlineCode",{parentName:"p"},"CAContext")," - this is where the root layer is hosted. You can create additional contexts, remote, or local, to allow hosting your layers in another process (a la Safari tabs). The context supports the notion of ",(0,r.kt)("inlineCode",{parentName:"p"},"slot"),"s and ",(0,r.kt)("inlineCode",{parentName:"p"},"fence"),"s: I presume slots are a way to pass context-related objects around remote contexts, but haven't tested the theory. Fences, however, can be used to delay the host app's transaction commit cycle until the client app (the one serving a remote layer) is done with its commit - essentially, it's used to synchronize rendered frames, and a fence has a natural timeout of about one second (so the remote layer server should finish its commit within this time). This ties into transaction phases: there are a few points in a ",(0,r.kt)("inlineCode",{parentName:"p"},"CATransaction")," that you can inject a handler: pre-layout, pre-commit, and post-commit. Combining fences with commit handlers, you can correctly synchronize remote rendered layers."),(0,r.kt)("p",null,"Some readers may arrive at a question here: if layers require a context, how does the context get rendered? I'm not too sure. I know there's a way to initialize a local render server and a way to hook into a remote render server (that is, on macOS, ",(0,r.kt)("inlineCode",{parentName:"p"},"windowserver"),"), but I don't know how the contextId makes its way over or how the two link up. However, if you're creating a ",(0,r.kt)("inlineCode",{parentName:"p"},"CGSWindow"),", the fast way to get a ",(0,r.kt)("inlineCode",{parentName:"p"},"CALayer")," on-screen is to create a ",(0,r.kt)("inlineCode",{parentName:"p"},"CGSSurface")," and bind a ",(0,r.kt)("inlineCode",{parentName:"p"},"CAView")," to it. The header for ",(0,r.kt)("inlineCode",{parentName:"p"},"CAView")," is incomplete, but it looks trivial to work with, as it then manages the surface for you."),(0,r.kt)("p",null,"So, in conclusion, there are three different facets of the Core Animation API, intricate links to Core Graphics, via ",(0,r.kt)("inlineCode",{parentName:"p"},"CGContextDelegate"),", and some kind of ",(0,r.kt)("inlineCode",{parentName:"p"},"CARender")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"CAContext")," song-and-dance that allows a layer to be presented on-screen or in a buffer somewhere. I hope that demystifies a lot of the private API here for you. Drop me a line on Twitter if you think anything is incorrect or needs explaining!"))}h.isMDXComponent=!0}}]);