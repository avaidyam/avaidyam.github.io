<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://aditya.vaidyam.me/blog</id>
    <title>Aditya Vaidyam Blog</title>
    <updated>2019-06-02T00:00:00.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://aditya.vaidyam.me/blog"/>
    <subtitle>Aditya Vaidyam Blog</subtitle>
    <icon>https://aditya.vaidyam.me/photo.png</icon>
    <rights>© 2022 Aditya Vaidyam</rights>
    <entry>
        <title type="html"><![CDATA[On the debate of iOS vs. macOS]]></title>
        <id>https://aditya.vaidyam.me/blog/2019/06/02/</id>
        <link href="https://aditya.vaidyam.me/blog/2019/06/02/"/>
        <updated>2019-06-02T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[I've been seeing a lot of opinions on this topic and decided to articulate some of my own after having spent a month primarily using an iPad for nearly everything. I've closely monitored the few cases where I've needed to use my MacBook Pro and effectively made a list of things iOS should implement for feature parity with macOS.]]></summary>
        <content type="html"><![CDATA[<p>I've been seeing a lot of opinions on this topic and decided to articulate some of my own after having spent a month primarily using an iPad for nearly everything. I've closely monitored the few cases where I've needed to use my MacBook Pro and effectively made a list of things iOS should implement for feature parity with macOS.  </p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="first-a-summary-macos-takes-the-old-approach-everything-is-a-file-a-la-unix-and-apps-are-tools-to-manipulate-files-ios-takes-a-new-approach-everything-is-an-app-and-files-are-byproducts-of-the-apps-furthermore-macos-offers-to-its-apps-the-organization-paradigms-of-spaces-virtual-desktops-windows-tabs-and-menus-the-vertical-variety">First, a summary. <strong>macOS takes the old approach: everything is a file (a la UNIX) and apps are tools to manipulate files. iOS takes a new approach: everything is an app and files are byproducts of the apps.</strong> Furthermore, macOS offers to its apps the organization paradigms of spaces (virtual desktops), windows, tabs, and menus (the vertical variety).<a href="#first-a-summary-macos-takes-the-old-approach-everything-is-a-file-a-la-unix-and-apps-are-tools-to-manipulate-files-ios-takes-a-new-approach-everything-is-an-app-and-files-are-byproducts-of-the-apps-furthermore-macos-offers-to-its-apps-the-organization-paradigms-of-spaces-virtual-desktops-windows-tabs-and-menus-the-vertical-variety" class="hash-link" aria-label="Direct link to first-a-summary-macos-takes-the-old-approach-everything-is-a-file-a-la-unix-and-apps-are-tools-to-manipulate-files-ios-takes-a-new-approach-everything-is-an-app-and-files-are-byproducts-of-the-apps-furthermore-macos-offers-to-its-apps-the-organization-paradigms-of-spaces-virtual-desktops-windows-tabs-and-menus-the-vertical-variety" title="Direct link to first-a-summary-macos-takes-the-old-approach-everything-is-a-file-a-la-unix-and-apps-are-tools-to-manipulate-files-ios-takes-a-new-approach-everything-is-an-app-and-files-are-byproducts-of-the-apps-furthermore-macos-offers-to-its-apps-the-organization-paradigms-of-spaces-virtual-desktops-windows-tabs-and-menus-the-vertical-variety">​</a></h4><p>The biggest confusion I had was thinking about where my files would go in iOS. The <code>~/Desktop</code> on macOS would just be the <code>Files</code> app's local app container. <code>~/Documents</code> would be the set of ALL app containers on the device. (Side note: this is actually how the <code>iCloud Drive</code> folder works.) <code>/Applications</code> isn't a folder at all in this case, obviously. <code>~/Music</code>, <code>~/Photos</code>, <code>~/Videos</code>, and so on are just the app containers for those apps. Because there's only one user account on iOS there's no <code>/Users</code> folder (or <code>~/Applications</code> folder, for that matter). Likewise, there's no need for UNIX chmod permissions or the <code>~/Public</code> folder anymore because of the single-user model. <code>~/Library</code>, <code>/Library</code>, and <code>/System/Library</code> are basically all merged into a new <strong>"System" app</strong> container, if such a thing were to exist. This model, however, doesn't account for any loose files in the home directory or system directories, though they might hypothetically be merged into the <code>Files</code> or <code>System</code> app container. </p><p>The <code>System</code> app should basically be responsible for the app launcher, dock, gesture navigation, notification center, and the lock screen. These are actually all things that the <code>Dock</code> app on macOS handles with <code>NotificationCenter</code>. The macOS login window is also basically the lock screen as well. The <code>System</code> app should also offer extension points (how about letting third-party apps define extension points?) for the control center actions, notifications, today widgets, and lock screen quick-launch (instead of just the <code>Camera</code>). <code>Spotlight</code> and <code>Siri</code> should be merged as a system feature into <code>System</code> instead of standalone apps. While I mention this, why are <code>Mission Control</code>, <code>Dashboard</code>, <code>Launchpad</code>, <code>Siri</code> and other system features their own "apps" on macOS? They shouldn't be (and <code>Dashboard</code> is long dead anyway). </p><p>Instead of multitasking showing <strong>all</strong> recent apps, it work like <code>Mission Control</code> on macOS - if enabled and supported by the device. Currently on iPads, Split View app pairs are remembered in the multitasking view, and if you open an app that was placed in Split View, iOS will bring you to the Split View instead of re-opening the app on its own. This effectively is the same idea as Spaces on macOS, which further remembers and separates multiple windows from a single app. </p><p>macOS is already much closer to the iOS model than I had previously thought: I've always ran <code>defaults write com.apple.Finder CreateDesktop -bool NO</code> to disable <code>Desktop</code> icons as soon as I've set up a new Mac. Using the five-finger pinch, I'd be able to see all my apps in <code>Launchpad</code> (though I stick to using Spotlight with <code>CMD-Space</code> instead). If you've enabled iCloud Drive, nearly every app that supports it will open with a document picker as well... I could full-screen every app I use on a Mac and completely avoid using <code>Finder</code> if I really wanted to replicate iOS. One incongruency in <code>Launchpad</code> is actually that it doesn't hide apps that you've already pinned to the Dock because the <code>Dock</code> also serves as a "recent apps" view, and you can't add the virtual (as opposed to actually putting apps in sub-folders) <code>Launchpad</code> folders to the <code>Dock</code>.</p><p>And now for an unpopular opinion: the Touch Bar's Control Strip is the macOS replacement for the Control Center on iOS. It serves exactly every same purpose, but does lack the action buttons to create a new note or voice memo, shortcuts for timers/alarms/stopwatch, and HomeKit toggles. However, macOS basically just got the half-baked <code>Voice Memo</code> and <code>Home</code> apps, and still lacks a <code>Clock</code> app so I think just the Notes action would be nice for now... The Touch Bar on macOS however lacks discoverability: just like the trackpad, it needs force touch to mimic physical keys. When you "touch" or "scan" your fingers across, you should feel the haptics of keys, dials, or sliders - but only when you deep press, should you "activate" the button or control, mimicking a physical keyboard press. Also, why doesn't every single Mac come with it? By fragmenting features like 3D Touch or the Touch Bar to just a few devices, only a few good developers support those features, and most people dismiss it as a gimmick because it's not fleshed out or integrated into every single app. </p><p>The <code>Files</code> app is also missing Quick Look extensions, system-wide <code>Spotlight</code>, filtered-and-sorted search, smart folders (which rely on the two before), customized folder views with background images, aliases, jumping to a location by tying it like "Go To Folder", a built-in <code>Archive Utility</code> for folder compression, and support for DMGs, external drives, or remote servers. When selecting multiple files, the app no longer offers you a tap-and-hold menu which is very inconsistent design, but further doesn't support multi-rename, multi-copy, or multi-quick-look (but multi-get-info on macOS is a terrifying experience if you've accidentally done that for 1000+ files so maybe this is a good exception). The most heinous crime is actually that "Open With" isn't possible, thanks to the lack of File and URL associations; this way you'd be able to go from file <strong>TO</strong> app instead of vice versa, like with macOS. It's very clear that on iOS, the <code>Files</code> app is a majority of the bottleneck in the experience of interoperability.</p><p><code>Folder Actions</code> however could instead be integrated into <code>Shortcuts</code> or <code>Automator</code> (one of which should be renamed to match the other...). Also, Apple should commit to either dropping AppleScript/Apple Events on macOS and implementing Intents-based automation as with iOS, <strong>OR</strong> bring AppleScript support to iOS apps. Chances are the former is more likely, which means I'd like to see AppleScript or JSX transition to become a textual language for <code>Shortcuts</code> workflows. Also, global keyboard shortcuts aren't even supported on iOS - I can't quickly switch to an app or invoke some action when I'm within a different app. </p><p>In apps like <code>Notes</code>, I'd like to see the addition of physical files that I could move around to represent the notes being taken in the app. One might claim the <code>Notes</code> app then couldn't keep track of all its generated notes and that might confuse the user... but that's the indexing job of <code>Spotlight</code> at the end of the day. Speaking of <code>Notes</code>, I'd like to see on both iOS and macOS, the integration of <code>TextEdit</code> for basic RTF editing and the features of the <code>Stickies</code> app. <code>Notes</code> on macOS already supports floating notes, it just has a massive title bar and can't shrink to a smaller size. Furthermore, why can't they just add a Today Widget on <code>macOS</code>?</p><p>There's a long list of apps I think iOS needs from macOS: <code>Activity Monitor</code>, <code>Terminal</code>, <code>Console</code>, <code>Disk Utility</code>, <code>Dictionary</code>, <code>Image Capture</code> built-into <code>Camera</code>, <code>Grapher</code> and <code>Calculator</code> merged, and <code>Keychain</code>, <code>Audio/MIDI Setup</code>, <code>Font Book</code> and <code>ColorSync</code> in Settings. macOS however definitely needs a <code>Clock</code> app. There's also some hidden core apps on macOS like <code>Directory Utility</code>, <code>Network Utility</code>, <code>RAID Utility</code>, <code>System Image Utility</code>, <code>Wireless Diagnostics</code>, <code>Certificate Assistant</code> <code>Screen Sharing</code>, <code>Storage Management</code>, and some others probably not mentioned that could be useful on iOS someday, even if only managing a macOS network remotely.</p><p>At the end of the day, I can have 5 to 10 different documents from 3 or 4 apps on say, 4 spaces, between two displays. iOS just doesn't support that. If it added support for multiple windows and opening different apps on the external display when attached, I could then see this becoming much much closer to reality, but I'm doubtful. A user shouldn't be forced into picking sides, especially when both iOS and macOS have pretty much all the same capabilities. iOS apps and Mac apps aren't even all that different most of the time and what framework or language is used to make an app is probably the least of anyone's concern if the app does what it's supposed to do well enough for most users.</p><p>The convergence of iOS and macOS features isn't a limitation but a blessing to users who can now pick and choose to build their own unique workflows. Not everyone uses full screen apps, not everyone likes using tabs for web pages, and that's fine. The goal should be to empower users with choice, not make their decisions for them and tell them to look elsewhere, if they can't fit in.</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[DIY: Core Animation]]></title>
        <id>https://aditya.vaidyam.me/blog/2019/02/19/</id>
        <link href="https://aditya.vaidyam.me/blog/2019/02/19/"/>
        <updated>2019-02-19T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[(Check out the project over here.)]]></summary>
        <content type="html"><![CDATA[<p><a href="https://github.com/avaidyam/DIYAnimation" target="_blank" rel="noopener noreferrer">(Check out the project over here.)</a></p><p>After having been a consumer of the <strong>Core Animation</strong> (originally <strong>LayerKit</strong>) framework for about a decade now, I began to wonder how it was designed and implemented under the hood. Not simply the surface details such as "it's rendered out of process" or "it handles the animation interpolation for you" or whatnot, but more specifically, <strong>HOW</strong> all of its beautiful bells and whistles translate into nitty gritty graphics ideas and associated draw calls. I figured the best way was to try to build it myself from scratch!</p><p>So I took iron to the anvil and decided to reimplement <strong>Core Animation</strong> in near-pure Swift -- that is, avoiding <code>NSObject</code>/Cocoa wherever possible. I didn't attempt to implement the entire API surface, such as <code>CAAtom</code>, or the layout managers API (for that matter, layout managers have been remarked by Core Animation engineers as a bad idea anyways). I chose to design a closely matched, but overall Swift-ier API, such as <code>Render.Value</code>. I haven't yet, however, implemented wrappers for all <code>Codable</code> types, partially because <strong>Core Animation</strong> is implemented in C++ and some internal types such as <code>CA::Render::Vector</code> are actually wrappers around <code>float[]</code>, for example. Implementing serialization for a <code>[Float]</code> in Swift is free, so we don't necessarily need these wrapper types. Some facilities like <code>fence</code>s to synchronize rendering between threads or processes, or <code>slot</code>s to share drawable items (if I recall correctly), aren't implemented yet simply because they're not required in <strong>DIYAnimation</strong> yet. Ultimately, only the Objective-C <code>CA*</code> and the internal <code>CA::Render::*</code> API surfaces are the same, as I've reimplemented the actual rendering (<code>CA::OGL::*</code>) in an entirely different way atop <code>Metal</code>.</p><p>Another major departure from the C++ implementation is the use of <code>XPC</code> serialization and transport over raw <code>mach_msg</code> types and calls. While <code>XPC</code> is best known for its service and connection facilities, <strong>DIYAnimation</strong> uses the <code>xpc_pipe_t</code> object atop raw mach ports, a transport medium for serialized <code>XPC</code> objects to be passed between threads and processes which underlies <code>xpc_connection_t</code>. After writing an <code>XPC</code> encoder and decoder pair in Swift, the <code>XPCPipe</code> wrapper works with any <code>Codable</code> with some notable exceptions involving patched implementations. Though I've got a mach shared memory object in Swift matching the original implementation, I'm instead using <code>IOSurface</code> in a few places simply because it's easier to work with at the moment. I'll talk a bit more about the <code>XPC</code> internals later, but for now I'll share a few tidbits I came across while implementing parts of <strong>DIYAnimation</strong>.</p><p>Since <strong>Core Animation</strong> doesn't deal with accelerated 2D graphics (i.e. the now-defunct <code>QuartzGL</code> from <strong>Core Graphics</strong>), text rendering, for example, is CPU-bound -- it's implemented in an identical manner in <strong>DIYAnimation</strong>. However, while <code>QuartzGL</code> is indeed defunct, <strong>Core Animation</strong> does actually indirectly support accelerated drawing! To make a very long story short, non-accelerated/CPU-bound drawing is performed through <code>CGContext</code> from <code>Core Graphics</code>, which is actually just a wrapper around <code>CGGState</code>, which manages the transparency layers and graphics state stack, and <code>CGContextDelegate</code>, which handles conversion of Quartz draw calls into actual rasterization. (As a side-side-note, <code>CGLayers</code> and transparency layers are essentially identical, but capture context state at different points in the drawing lifecycle.) <code>CAWindowContextDelegate</code> is the delegate used by all <code>CGContext</code>s drawing to a Cocoa window, and <code>CAIOSurfaceContextDelegate</code> is the delegate used by all <code>CGContext</code>s attached to a <code>CALayer</code> that's currently accelerating drawing within <code>-drawInContext:</code>. It accelerates drawing by buffering its queued draw calls until its associated layer needs to draw to screen, and subsequently thereafter, its associated <code>IOSurface</code> needs to draw to screen. </p><p>I've attempted to replicate window server functionality as seen in <code>CAWindowServer</code> and <code>CADisplay</code>, using <code>CGS</code> windows (<code>CoreGraphicsServices</code>, now known as <code>SkyLight</code> in macOS 11+), though it's done somewhat strangely at the moment. Not only does <code>SkyLight</code> on macOS handle event routing and layer compositing like <strong>Core Animation</strong> on iOS, but also desktop management, spaces, the menu bar, cursors, and controlling the dock, and more on macOS. That's a lot of additional functionality that I'll be ignoring. In <code>AppKit</code>, for example, invoking the modern drag and drop API eventually calls into <code>HIServices</code>, the vestigial <code>Carbon.framework</code> remnant underlying most of <code>AppKit</code>, which then calls into the <code>CoreDrag.framework</code>, which then creates a new <code>CGSWindow</code> with the <strong>SkyLight</strong> window server, a new <code>CAContext</code> to go with it (therefore enabling <strong>Core Animation</strong> embedding in that window), and a new root <code>CALayer</code>. That layer is then what you see while dragging a file or anything else. The actual movement of data between one process to another (<code>NSPasteboard</code> in <code>AppKit</code>) is actually implemented using <code>CFMessagePort</code> in <code>HIServices</code> - every AppKit-linked process has this port pair allocated for drag-and-drop or other pasteboard synchronization. </p><p>Speaking of <code>CGSWindow</code> and <code>CAContext</code>, by the way, these two API are actually somewhat identical in some ways. <code>AppKit</code>'s <code>NSWindow</code> wraps a <code>CGSWindow</code>, and supports on-screen drawing through providing a <code>CGContext</code> to its children <code>NSView</code>s. System events are passed from the <code>SkyLight</code> window server to the most appropriate <code>CGSWindow</code> (through a callback into the application's run loop) which then is translated and passed to the appropriate <code>NSView</code> by that <code>NSWindow</code>. The connection to the window server, <code>CGSConnection</code> is actually explicit in all these API, and must be created by <code>AppKit</code> for each thread that wants to manage on-screen elements. Each connection is recorded by the server in an identifier-based lookup table, and upon each call to the server, its originating connection's rights are validated for each resource modified or accessed by that call. <code>SkyLight</code> actually uses <strong>Mach Interface Generator (MIG)</strong> to marshall these calls, and connections are actually just composed of a server request mach port and an on-demand client notification/event port. In <strong>Core Animation</strong>, however, <code>CAContext</code> doesn't handle any drawing or rendering control itself, instead delegating this to its root <code>CALayer</code>. It does control inter-context ordering (i.e. ordering root layers relative to all other on-screen root layers) and event routing when initialized connected to a remote window server instead of initialized as a local rendering context. So, CA windows (contexts) are equivalent to SkyLight windows, but while one SkyLight connection can control many windows, one CA connection may only control one CA window (context). In a way though, for quite some time now, <code>AppKit</code> internal/private API has slowly been modernized to match <strong>Core Animation</strong>, with functions like <code>NSWindowMark</code> mimicking <code>CALayerMark</code> along with the recent addition of transactions. (With <code>CGPixelAccess</code> and direct <code>CGContext</code> drawing, <code>SkyLight</code> actually has an analogous concept to <code>CABackingStore</code>; <code>CA::Shape</code> too is essentially the same as <code>CGSRegionObj</code>/<code>CGRegion</code>.)</p><p>Anyways, the next steps for this project include adding <code>CADynamicsBehavior</code> (probably hard, requiring <code>box2d</code> or <code>PhysicsKit</code> integration), <code>CAStateController</code> (likely easy), <code>CAPresentationModifier</code> (likely easy), and <code>CAML</code> and <code>CAPackage</code> support (likely easy... if using <code>NSXMLParser</code>). Though they've since been removed from <strong>Core Animation</strong>, <code>CALight</code> and related lighting filters did used to exist, roughly matching SVG's <code>feDiffuseLighting</code> and <code>feSpecularLighting</code>, for example. They were meant to be used with <code>CAMeshTransform</code>, which is also currently unimplemented. In summary, as you can see, there's a lot of private and some public API that are yet unimplemented, even though the groundwork has been laid. Take a look at the implementation details -- I'm sure you'll find them interesting, as they're mostly faithful to the original (decompiled) C++ implementation!</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[An Exercise in Modern Cocoa Views]]></title>
        <id>https://aditya.vaidyam.me/blog/2018/03/22/</id>
        <link href="https://aditya.vaidyam.me/blog/2018/03/22/"/>
        <updated>2018-03-22T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Like I said in the previous "episode", recently, I've wanted to get around to adding "hot key" support for Parrot, and realized I didn't like any of the existing solutions:]]></summary>
        <content type="html"><![CDATA[<p>Like I said in the previous "episode", recently, I've wanted to get around to adding "hot key" support for Parrot, and realized I didn't like any of the existing solutions:</p><ol><li>Use <code>MASShortcut</code> or <code>ShortcutRecorder</code> which are tried and proven to work in ObjC-land.</li><li>Use a new but not proven Swift hotkey recorder (there's a few out there).</li><li>Roll my own (probably somehow using dangerous private SPI) and not test it at all! </li></ol><p><em>Obviously I went with option #3.</em> </p><p>And here we are now, onto part two of the thrilling saga in which you witness me breaking AppKit and WindowServer and inviting the wrath and fury of the engineers that work on said components. I hope you brought your popcorn. </p><p>I'd like to clarify that we'll only be building a single self-contained control that manages a single shortcut. I expect Parrot, like most apps, will not need a Command Editor like Final Cut Pro, which is purpose-built for video editors with more than two keyboards and more than two hands to match, clearly.</p><p><img loading="lazy" alt="Final Cut Pro Command Editor" src="/assets/images/finalcut-keyboard-a42ab2a630db0d4127a3b1e7072d6545.jpg" width="1800" height="1220" class="img_ev3q"></p><p>Our end result will look, sound, and feel something like this, instead:</p><p><img loading="lazy" alt="KeyboardShortcutView" src="/assets/images/shortcut-recorder-b7f561211d859622dbfe5614b14170fc.gif" width="398" height="340" class="img_ev3q"></p><p>Before we get into the nitty gritty hand-holding pair-programming stuff, if you'd like to jump straight to the comment-annotated final source code, <a href="https://gist.github.com/avaidyam/32975976c23dd3b38336f22d971f5eaa" target="_blank" rel="noopener noreferrer">I've included a snapshot here.</a> It's the whole final product, exactly 1500 LOC, including the code from the previous "episode" - the corresponding keyboard shortcut facility! If you think this should be a formal repository and whatnot, contact me on Twitter or Github @avaidyam!</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="principles-of-modern-views">Principles of Modern Views<a href="#principles-of-modern-views" class="hash-link" aria-label="Direct link to Principles of Modern Views" title="Direct link to Principles of Modern Views">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="subclassing-a-view-or-a-viewcontroller">Subclassing a <code>View</code> or a <code>ViewController</code><a href="#subclassing-a-view-or-a-viewcontroller" class="hash-link" aria-label="Direct link to subclassing-a-view-or-a-viewcontroller" title="Direct link to subclassing-a-view-or-a-viewcontroller">​</a></h3><p>The first question we should answer is, what kind of component are we building? The answer to this question is what determines what kind of a subclass we are, as well as the interaction model we have with other components in our app. </p><p>When you're building a discrete component that takes a program input and presents a display to the user, and in the case of a control, receives user input and presents a program output, you should be subclassing a <code>View</code>. Anything beyond that should be a subclass of a <code>ViewController</code>, a component that mediates interactions between other components, or a component that handles model/database objects, or really just anything else. A <code>View</code> should be easily reusable in other contexts outside of the one you're building in immediately, but a <code>ViewController</code> is not necessarily capable of fulfilling this contract. </p><p>For example, a contact avatar would best be a <code>View</code> subclass, but a contact avatar <strong>picker</strong> should be a <code>ViewController</code>, as it not only displays an avatar image, but it also allows the user to select an image, and might handle the synchronization with the contact store (maybe it's a JSON file, maybe it's a remote API, or maybe it's a <code>CNContact</code>). </p><p>On macOS, you should also consider subclassing an <code>WindowController</code> if the component you're building both composes other components (like a <code>ViewController</code>) and is self-contained in a <code>Window</code> -- a contact avatar picker may not fit this criteria, but a contact <strong>editor panel</strong> would, where the contact avatar picker would be a <code>ViewController</code> nested within, alongside name, phone, email, and other editable fields.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="layers">Layers<a href="#layers" class="hash-link" aria-label="Direct link to Layers" title="Direct link to Layers">​</a></h3><p>While <code>AppKit</code> is often seen as a dinosaur compared to its younger sibling, <code>UIKit</code>, it's important to know that nearly all the design patterns that <code>UIKit</code> sports came from <code>AppKit</code>, and if not, they eventually make their way back into <code>AppKit</code>, with the exception of a very limited few. For example, the concept of a <code>UIView</code> being backed by an underlying <code>CALayer</code> type is very similar to how <code>NSControl</code> is (rather, used to be?) backed by <code>NSCell</code>. The differences being that the <code>CALayer</code> is actually driving the rendering of display content instead of the <code>UIView</code>, and that <code>NSCell</code> acts as a "rubber stamp" for specific event handling and drawing. </p><p>When it comes to layer-backed views, <code>AppKit</code> actually has several modes by which to achieve this: </p><ol><li><strong>Layer-hosting:</strong> <ul><li><code>self.layer = CALayer(); self.wantsLayer = true</code></li><li>The <code>NSView</code> owns the <code>CALayer</code> and is responsible for creating and managing it; <code>NSView</code> does nothing except create its rendering surface.</li></ul></li><li><strong>Implicit Layer-backed and drawn:</strong> <ul><li><code>superview.wantsLayer = true</code></li><li>The <code>NSView</code> has an explicitly layer-backed parent and will grant itself a private <code>CALayer</code> to draw into, using the rendering surface of the layer-backed parent's <code>CALayer</code>.</li></ul></li><li><strong>Implicit Superview Layer-drawn:</strong> <ul><li><code>superview.wantsLayer = true; superview.canDrawSubviewsIntoLayer = true</code></li><li><strong>If you expect to use animations or any layer-related properties, you must opt out of this!</strong></li><li>The <code>NSView</code> has an explicitly layer-backed parent whose <code>canDrawSubviewsIntoLayer</code> is true, and thus, will not grant itself a <code>CALayer</code>, and instead draw directly into the layer-backed parent's <code>CALayer</code>. </li></ul></li><li><strong>Explicit Layer-backed and drawn:</strong> <ul><li><code>self.wantsLayer = true</code></li><li>The <code>NSView</code> has explicitly declared itself as layer-backed and will set its layer's <code>contents</code> with the result of its <code>drawRect:</code> call (that is, drawing directly into the layer).</li><li>If this view declares that it <code>canDrawSubviewsIntoLayer</code>, its subviews are rendered into this view's <code>layer</code>. </li></ul></li><li><strong>Explicit Layer-backed:</strong> <ul><li><code>self.wantsLayer = true; self.wantsUpdateLayer = true; self.layerContentsRedrawPolicy = .onSetNeedsDisplay</code></li><li><em>Note: you must actually override the <code>wantsUpdateLayer</code> function in your custom <code>NSView</code> subclass to achieve this, as there is no setter for the property. This property is queried at each view update cycle, if the view is marked dirty - don't attempt any complex computations here.</em></li><li>The <code>NSView</code> has explicitly declared itself as layer-backed and that it will not <code>drawRect:</code> into the layer. Instead, the layer is manually managed, <strong>but not owned by the subview</strong>, during the <code>updateLayer</code> method.</li><li>It's important to set <code>layerContentsRedrawPolicy</code> to <code>.onSetNeedsDisplay</code> here, since the <code>layer.contents</code> are no longer dependent on your <code>drawRect:</code>.</li></ul></li></ol><p><em>Note: where I say "rendering surface", the underlying type is either a <code>CAContext</code>, which is used by the WindowServer to render your layers out-of-process, <strong>or</strong> by <code>CAViewRef</code> which can be thought of as a wrapper around `CA::Render::</em>`, which is rendered in-process but likely off the main thread.*</p><p>Personally, I think the <code>NSView.layer</code> property should never have been public; instead, if layer-hosting, it's the view's responsibility to keep a strong reference to its layer, and in explicit <code>updateLayer</code> views, the <code>updateLayer</code> method signature should have been <code>- (void)updateLayer:(CALayer *)layer</code>, so as to pass in the <code>AppKit</code>-owned layer for the view to update. Too many iOS developers mistake <code>NSView</code> for being identical to <code>UIView</code>, where it's almost even orthogonal to it depending on the scenario. <code>UIView</code>'s layer ownership model is most closely represented by layer-hosting, but in AppKit, this means layer hierarchies and other view facilities are not managed for you, and so, the closest to it would be explicit layer-backed. This is the approach we'll be taking. It may appear that you won't be able to use <code>drawRect:</code>, but there are ways to work around that, as we'll see soon.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="nscontrol"><code>NSControl</code>?<a href="#nscontrol" class="hash-link" aria-label="Direct link to nscontrol" title="Direct link to nscontrol">​</a></h3><p>The next question we need to tackle is, should we design a subclass of <code>NSControl</code> or <code>NSView</code>? In this specific instance, the answer is pretty straight forward, as we're designing a control, it makes the most sense to take advantage of <code>NSControl</code>... it's in the name, after all. </p><p>However, here's a few things you'll want to consider:</p><ul><li><strong><code>NSCell</code>:</strong> Because this class has been soft-deprecated, it's pretty safe to assume <code>NSControl</code>s can be written without a corresponding cell (spoiler alert: yep).</li><li><strong>Polymorphic <code>*Value</code> Properties:</strong> <code>NSControl</code> has several <code>*Value</code> properties, like <code>objectValue</code>, and <code>take*ValueFrom(_:)</code> methods to go along with them, for use in Interface Builder and Cocoa Bindings. These aren't really that helpful, from my experience, and if they were, re-implementing them for <code>NSView</code> classes isn't that hard.</li><li><strong>Field Editors:</strong> This is another of those <code>NeXT</code>-era ideas, where instead of loading say, a hundred, heavyweight <code>NSTextView</code>s into a window, which would kill performance and memory, you would only load one, and share it across a hundred lightweight <code>NSTextFieldCell</code>s. It doesn't make much of a difference in 2018, especially since your memory and performance competition are Electron apps: <strong>as long as you don't use Electron (or develop in JS for Desktop apps), you're winning.</strong></li><li><strong>Target/Action Model:</strong> This is what we know and love <code>NSControl</code> (and <code>UIControl</code>) for! A control has a target, and an action that fires on that target, when the control has been activated somehow. <code>UIControl</code> goes a step further, allowing you to register different targets for different event types, but <code>NSControl</code> offers a single condition-setting <code>sendAction(on:)</code> version. It's arguable which is more convenient.</li></ul><p>In summary, there's a few reasons to use or not use <code>NSControl</code>, but after weighing out the options, a standard of conformity in being a "control," and just having the target/action model already implemented for you is pretty helpful, so we'll go with that.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="working-with-cgskeyboardshortcut">Working With <code>CGSKeyboardShortcut</code><a href="#working-with-cgskeyboardshortcut" class="hash-link" aria-label="Direct link to working-with-cgskeyboardshortcut" title="Direct link to working-with-cgskeyboardshortcut">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="human-readable-string-representation">Human-Readable String Representation<a href="#human-readable-string-representation" class="hash-link" aria-label="Direct link to Human-Readable String Representation" title="Direct link to Human-Readable String Representation">​</a></h3><p>Before we begin building a user-facing control, we need to make sure <code>CGSKeyboardShortcut</code> and friends can be translated to a human-readable string representation. This is because modifiers and virtual key codes that compose a shortcut like <code>⌘D</code> are device-independent mechanism, and when registering a shortcut, we can't use a string containing the shortcut. It's important to note that virtual key codes are not ASCII-ordered (that is, sequential in the ASCII table), and may not always have a corresponding glyph to match the key. To determine what the virtual key code points to on the current keyboard, we unfortunately have to return to <code>Carbon.framework</code> for <em>Text Input Services</em> (<code>TIS</code>) and <em>Unicode Utilities</em> (<code>UC</code>). To translate the key code, we grab the current input source's keyboard layout, and use the <code>UCKeyTranslate</code> facility to determine what the unicode character resulting from pressing this key in the current layout will be. There are a few special cases like Fn keys that print <code>F13</code>, for example, or the spacebar, which we want to print <code>Space</code>.</p><p><em>Cocoa key equivalents, used by <code>NSMenu</code> and <code>NSButton</code>, for example, internally translate a string containg <code>"x"</code> into the right virtual key code; this is left as an exercise for the reader. Hint: just create a reverse mapping table and look it up!</em></p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">public extension CGKeyCode {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public var isFunctionKey: Bool {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        switch Int(self) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        case kVK_F1, kVK_F2, kVK_F3, kVK_F4, kVK_F5, kVK_F6, kVK_F7, kVK_F8,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">             kVK_F9, kVK_F10, kVK_F11, kVK_F12, kVK_F13, kVK_F14, kVK_F15,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">             kVK_F16, kVK_F17, kVK_F18, kVK_F19, kVK_F20:</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            return true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        default:</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            return false</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public var characters: String {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        if let special = CGKeyCode._special[Int(self)] { return special }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        let source = TISCopyCurrentASCIICapableKeyboardLayoutInputSource().takeUnretainedValue()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        let layoutData = TISGetInputSourceProperty(source, kTISPropertyUnicodeKeyLayoutData)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        let dataRef = unsafeBitCast(layoutData, to: CFData.self)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        let keyLayout = unsafeBitCast(CFDataGetBytePtr(dataRef), to: UnsafePointer&lt;CoreServices.UCKeyboardLayout&gt;.self)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        let keyTranslateOptions = OptionBits(CoreServices.kUCKeyTranslateNoDeadKeysBit)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        var deadKeyState: UInt32 = 0</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        let maxChars = 256</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        var chars = [UniChar](repeating: 0, count: maxChars)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        var length = 0</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        let error = CoreServices.UCKeyTranslate(keyLayout, self,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                                                UInt16(CoreServices.kUCKeyActionDisplay),</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                                                0, UInt32(LMGetKbdType()),</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                                                keyTranslateOptions, &amp;deadKeyState,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                                                maxChars, &amp;length, &amp;chars)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        if error != noErr { return "" }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        return NSString(characters: &amp;chars, length: length).uppercased</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    private static var _special: [Int: String] = [...]</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public extension CGEventFlags {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public var characters: String {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        var string = ""</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        if self.contains(.maskAlphaShift) { string.append("⇪") }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        if self.contains(.maskHelp) { string.append("?⃝") }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        if self.contains(.maskControl) { string.append("⌃") }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        if self.contains(.maskAlternate) { string.append("⌥") }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        if self.contains(.maskShift) { string.append("⇧") }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        if self.contains(.maskCommand) { string.append("⌘") }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        return string</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public extension NSEvent.ModifierFlags {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public var characters: String {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        return CGEventFlags(self).characters</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><em>Portions of this code are copyright © 2016 Shunsuke Furubayashi, author of the <code>Magnet</code> library.</em></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="a-simpler-shortcut-representation">A Simpler Shortcut Representation<a href="#a-simpler-shortcut-representation" class="hash-link" aria-label="Direct link to A Simpler Shortcut Representation" title="Direct link to A Simpler Shortcut Representation">​</a></h3><p>Because we don't want to lock ourselves into <code>CGSKeyboardShortcut</code>, and we don't exactly manage state like <code>identifier</code> or <code>acquisitionPolicy</code>, which are more within-app intrinsics, we'll define a new, simpler type: <code>KeyboardShortcutView.Pair = (CGKeyCode, CGEventFlags)</code>, and create two wrapper functions to transform it to and from an <code>NSDictionary</code>. This is important because we'll need to be able to encode and decode it for state restoration and <code>NSCoding</code>.</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">open class KeyboardShortcutView: NSControl, ... {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public typealias Pair = (keyCode: CGKeyCode, modifierFlags: CGEventFlags)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public func representation(of pair: KeyboardShortcutView.Pair?) -&gt; NSDictionary? {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    guard let pair = pair else { return nil }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return [</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        "keyCode": pair.keyCode,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        "modifierFlags": pair.modifierFlags.rawValue</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    ] as NSDictionary</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public func representation(of dict: NSDictionary?) -&gt; KeyboardShortcutView.Pair? {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    guard let dict = dict as? [String: Any],</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        let kc = dict["keyCode"] as? CGKeyCode,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        let mf = dict["modifierFlags"] as? CGEventFlags.RawValue</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        else { return nil }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return (kc, CGEventFlags(rawValue: mf))</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>With that, we have a facility to converse with other keyboard shortcut libraries or non-Swift objects, like <code>UserDefaults</code>. <em>(Recall that tuples cannot conform to <code>Codable</code>!)</em></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="being-a-good-citizen">Being A Good Citizen<a href="#being-a-good-citizen" class="hash-link" aria-label="Direct link to Being A Good Citizen" title="Direct link to Being A Good Citizen">​</a></h2><p>We'll have our recorder control compose a label (<code>NSTextField</code>) and a record/stop button (<code>NSButton</code>):</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">open class KeyboardShortcutView: NSControl, ... {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    /*@objc*/ open weak var delegate: KeyboardShortcutViewDelegate? {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        willSet { self.willChangeValue(forKey: #function) }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        didSet { self.didChangeValue(forKey: #function) }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    @objc open override var alignment: NSTextAlignment {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        get { return self.textLabel.alignment }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        set { self.textLabel.alignment = newValue }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    @objc open var tintColor: NSColor = .keyboardFocusIndicatorColor {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        didSet { /* ... */ }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    @objc open var placeholderString: String? {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        get { return self.textLabel.placeholderAttributedString?.string }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        set {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            let style = NSMutableParagraphStyle()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            style.alignment = self.alignment</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            let attr = NSAttributedString(string: newValue ?? "", attributes: [</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                .foregroundColor: NSColor.secondaryLabelColor,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                .paragraphStyle: style</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            ])</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            self.textLabel.placeholderAttributedString = attr</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    @objc open override var isEnabled: Bool {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        didSet { /* .. */ }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    open override var isHighlighted: Bool {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    private lazy var clearButton: NSButton = {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        let button = NSButton()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        button.wantsLayer = true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        button.translatesAutoresizingMaskIntoConstraints = false</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        button.image = NSImage(named: .stopProgressTemplate)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        button.bezelStyle = .texturedRounded // for template image rendering</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        button.setButtonType(.momentaryChange)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        button.isBordered = false</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        button.title = ""</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        button.target = self</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        button.action = #selector(self.buttonAction(_:))</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        return button</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    private lazy var textLabel: NSTextField = {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        let label = NSTextField()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        label.wantsLayer = true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        label.translatesAutoresizingMaskIntoConstraints = false</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        label.isEditable = false</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        label.isSelectable = false</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        label.isContinuous = false</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        label.isEnabled = true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        label.textColor = self.tintColor</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        label.backgroundColor = .clear</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        label.refusesFirstResponder = true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        label.drawsBackground = false</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        label.isBezeled = false</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        label.lineBreakMode = .byClipping</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        label.setValue(true, forKey: "ignoreHitTest")</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        return label</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public override init(frame frameRect: NSRect) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        super.init(frame: frameRect)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.commonInit()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public required init?(coder: NSCoder) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        super.init(coder: coder)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.commonInit()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    private func commonInit() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.wantsLayer = true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.layerContentsRedrawPolicy = .onSetNeedsDisplay</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.translatesAutoresizingMaskIntoConstraints = false</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.addSubview(self.clearButton)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.addSubview(self.textLabel)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.isEnabled = true // NSControl.isEnabled is false by default.</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.alignment = .center</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This bit of code is pretty basic subview setup, and we're using lazy initialization for our views, but it's not necessary to do so. In addition, we've added or overridden some properties that forward into our <code>subviews</code> or to our <code>superclass</code>. Remember to always set <code>wantsLayer</code>, <code>layerContentsRedrawPolicy</code> <strong>and definitely never forget <code>translatesAutoresizingMaskIntoConstraints</code> or you will cry.</strong> Notice that we didn't touch constraints in our <code>commonInit()</code>, and I'll explain why soon.</p><p>Speaking of that, there's a particular side effect of invoking setters in <code>commonInit()</code> versus in the initializer itself: it allows us to call the <code>didSet</code> on the property! Just be aware of that, and double check that there are no unintended side effects in your <code>didSet</code>s. Note the <code>will/didChangeValue</code> in our properties, though - we used <code>#function</code> as the key path, but these aren't the magical Swift <code>KeyPath</code>s (like <code>\.isRecording</code>) we got in Swift 4.1! What gives? It actually is because we aren't able to mark our properties as <code>@objc</code> because they aren't able to be represented in ObjC. As a workaround, we're able to get the ObjC <code>KeyPath</code> stuff working, but it's by no means a good solution. If you have a better solution, let me know!</p><p>Take note that we have to wrap the <code>placeholderString</code> in an <code>NSAttributedString</code> because the default label color is way too dim/translucent and therefore hard to read. This causes an unintended non-updating effect: <code>alignment</code> should be set before setting <code>placeholderString</code>, because we're not updating the <code>placeholderString</code>'s <code>paragraphStyle</code>'s <code>alignment</code> in <code>updateLayer</code>, and so <code>placeholderString</code>, if set only once, uses the exact value given to it at that time.</p><p>A few more notes about the subviews:</p><ul><li><code>ignoreHitTest</code> is a <strong>Private SPI</strong>! We need it though, because without this flag, the label steals our firstMouse/responder status. If you would rather <em>not</em> do this, subclass <code>NSTextField</code> and override <code>hitTest:</code> to return <code>nil</code>. It has the same effect.</li><li>To render template images (that is, <code>NSImage</code>s whose <code>isTemplate</code> is <code>true</code>, or their name ends with <code>Template</code>) in the current <code>NSAppearance</code>, <code>NSButton</code> has to be a textured style. This adds a little bit of padding around the button, so we'll take that into account when working with constraints.</li></ul><p>Since we'll also be using the <code>NSControl</code> target/action model, our <code>delegate</code> should primarily be for decision-making. If we wanted to focus on notification of control state, it's better to use <code>NSNotificationCenter</code>, which some Cocoa text classes do.</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">public protocol KeyboardShortcutViewDelegate: class {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    func keyboardShortcutViewShouldBeginRecording(_ keyboardShortcutView: KeyboardShortcutView) -&gt; Bool</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    func keyboardShortcutView(_ keyboardShortcutView: KeyboardShortcutView,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                              canRecordShortcut shortcut: KeyboardShortcutView.Pair) -&gt; Bool</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    func keyboardShortcutViewDidEndRecording(_ keyboardShortcutView: KeyboardShortcutView)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>There - now we have a pretty effective API client interface to determine what the control should do in a given situation, along with a visual foundation.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="accepting-key-view">Accepting Key View<a href="#accepting-key-view" class="hash-link" aria-label="Direct link to Accepting Key View" title="Direct link to Accepting Key View">​</a></h3><p>The important part of a control is to allow the user to activate and deactivate it, which we'll do by just clicking within or outside of the control bounds. It's very easy to allow becoming the key view or first responder:</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override var acceptsFirstResponder: Bool {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return self.isEnabled</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override var canBecomeKeyView: Bool {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return super.canBecomeKeyView &amp;&amp; NSApp.isFullKeyboardAccessEnabled</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override var needsPanelToBecomeKey: Bool {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override func acceptsFirstMouse(for event: NSEvent?) -&gt; Bool {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override func performClick(_ sender: Any?) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.window?.makeFirstResponder(self)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>That's all you need to do! Now, clicking inside the control will give us key input, which we'll focus on in the next section. </p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="responding-to-user-input">Responding to User Input<a href="#responding-to-user-input" class="hash-link" aria-label="Direct link to Responding to User Input" title="Direct link to Responding to User Input">​</a></h3><p>This is the meat of the control: actually recording the shortcut. The first thing we should do is get our <code>isEnabled</code>, <code>isHighlighted</code>, <code>isRecording</code> properties correctly wired together. We shouldn't be able to set our highlight state because that's for the user to do; instead, wire its getter through to <code>isRecording</code>. The two main properties are <code>shortcut</code> and <code>inputModifiers</code>, the latter of which we'll use to track which modifier flags are set when the user is entering the shortcut. When setting the <code>shortcut</code>, we'll use the <code>NSControl</code> target/action mechanism to send our <code>action</code> to our <code>target</code>. If we don't have a defined <code>target</code> (that is, it's <code>nil</code>), the message travels up the responder chain automatically! If the client (instead of the user) sets the <code>shortcut</code> directly, it'll still trigger the action, so keep that in mind - the solution to this is to wrap it in an <code>if self.isRecording</code>, but in this case, it's the behavior we might want.</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">@objc open override var isEnabled: Bool {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    didSet {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        if !self.isEnabled { self.endRecording() }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override var isHighlighted: Bool {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    get { return self.isRecording }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    set { }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">@objc open private(set) var isRecording = false {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    willSet { self.willChangeValue(forKey: #function) }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    didSet { self.didChangeValue(forKey: #function) }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">/*@objc*/ open var shortcut: KeyboardShortcutView.Pair? {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    willSet {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        guard self.shortcut?.keyCode != newValue?.keyCode &amp;&amp;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            self.shortcut?.modifierFlags != newValue?.modifierFlags else { return }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.willChangeValue(forKey: #function)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    didSet {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        guard self.shortcut?.keyCode != oldValue?.keyCode &amp;&amp;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            self.shortcut?.modifierFlags != oldValue?.modifierFlags else { return }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        _ = self.sendAction(self.action, to: self.target)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.didChangeValue(forKey: #function)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">private var inputModifiers: NSEvent.ModifierFlags = [] {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    didSet {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Now we'll have to actually handle mouse activation and keyboard events:</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override func mouseDown(with event: NSEvent) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    guard self.isEnabled else {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        super.mouseDown(with: event); return</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    let locationInView = self.convert(event.locationInWindow, from: nil)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    if self.mouse(locationInView, in: self.bounds) &amp;&amp; !self.isRecording {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.inputModifiers = []</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        _ = self.beginRecording()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        super.mouseDown(with: event)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>If we're enabled, and the mouse press was within our bounds, reset our recording state and begin recording. Next, if our <code>flagsChanged(with:)</code> is called, change our input modifiers state (and we'll cover soon how that reflects in the UI). The easy thing about writing a shortcut recorder is that we can use <code>performKeyEquivalent(with:)</code>! It's called when a "key equivalent" <em>(read: "keyboard shortcut")</em> is pressed and we're first responder. This basically has already taken care of all the work for us, and we just need to validate the new shortcut with the delegate and end recording.</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override func performKeyEquivalent(with event: NSEvent) -&gt; Bool {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    if !self.isEnabled || !self.isRecording { return false }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    if self.window?.firstResponder != self { return false }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    let shortcut = (keyCode: CGKeyCode(event.keyCode),</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                    modifierFlags: CGEventFlags(event.modifierFlags))</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // inline validation func if we have no delegate response:</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    func validate() -&gt; Bool {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        guard !shortcut.keyCode.isFunctionKey else { return true }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        return !shortcut.modifierFlags.intersection(.maskUserFlags).isEmpty</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    let del = (self.delegate ?? self.target as? KeyboardShortcutViewDelegate)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    if del?.keyboardShortcutView(self, canRecordShortcut: shortcut) ?? validate() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.shortcut = shortcut</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.endRecording()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        return true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return false</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override func flagsChanged(with event: NSEvent) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.inputModifiers = self.isRecording ? event.modifierFlags : []</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    super.flagsChanged(with: event)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>If we don't have a <code>delegate</code>, we'll check if our <code>target</code> is <em>also</em> capable of being our <code>delegate</code> -- this is mostly convenience, kinda like how you have a <code>delegate</code> and a <code>dataSource</code> for a collection or table view, but usually it's one view controller implementing both. If neither the <code>delegate</code> or <code>target</code> can help us validate the input, we'll just allow it to go through as long as it's not a single non-Fn key (that is, you shouldn't allow just <code>Q</code> as a hot key: that would lead to a lot of problems!).</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override func keyDown(with event: NSEvent) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    guard !self.performKeyEquivalent(with: event) else { return }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    super.keyDown(with: event)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override func resignFirstResponder() -&gt; Bool {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.endRecording()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>And with that, we've completed handling our event handling: if we get a stray <code>keyDown(with:)</code> message, just invoke <code>performKeyEquivalent(with:)</code>, as this can occur in the case described before, where a single non-Fn key is pressed. Again, <strong>allowing this is bad practice and interferes with system keyboard input!</strong> But who are we to judge, right? </p><p>The recording actions take place primarily in <code>beginRecording()</code> and <code>endRecording()</code>; we could have just placed the body of these methods in <code>isRecording.didSet</code> but that would be very very bloated and inappropriate code style. Be sure to handle state correctly and guard against out-of-place calls to these methods, as that can lead to unexpected user-visible state leakage. </p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">public func beginRecording() -&gt; Bool {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    if !self.isEnabled { return false }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    if self.isRecording { return true }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    let del = (self.delegate ?? self.target as? KeyboardShortcutViewDelegate)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    guard del?.keyboardShortcutViewShouldBeginRecording(self) ?? true else {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        NSSound.beep(); return false</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.isRecording = true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public func endRecording() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    if !self.isRecording { return }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.inputModifiers = []</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.isRecording = false</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    if self.window?.firstResponder == self &amp;&amp; !self.canBecomeKeyView {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.window?.makeFirstResponder(nil)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    let del = (self.delegate ?? self.target as? KeyboardShortcutViewDelegate)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    del?.keyboardShortcutViewDidEndRecording(self)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>It's pretty self-explanatory, as all we do is consult (or notify) the <code>delegate</code>/<code>target</code>, and fallback to the assumption that we are allowed to record, if none are available. When we <code>resignFirstResponder()</code> or <code>endRecording()</code>, we end up calling the opposite method, but these calls aren't re-entrant as <code>NSWindow.makeFirstResponder(_:)</code> does the verification for us. Finally, we just need to wire up the <code>clearButton</code> action to perform the context-specific thing: if we're not recording but we don't have a set <code>shortcut</code>, <code>beginRecording()</code>; if we <strong>do</strong> have a set <code>shortcut</code>, clear it and end recording. Otherwise, we're already recording - <code>endRecording()</code> without losing the previously set <code>shortcut</code>, if any.</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">@objc private func buttonAction(_ button: NSButton) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    if !self.isRecording &amp;&amp; self.shortcut == nil { // cleared state</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.window?.makeFirstResponder(self)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        _ = self.beginRecording()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    } else if self.isRecording &amp;&amp; self.shortcut != nil { // cleared state</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.endRecording()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        if self.shortcut != nil { self.shortcut = nil }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.endRecording()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="updatelayer"><code>updateLayer</code><a href="#updatelayer" class="hash-link" aria-label="Direct link to updatelayer" title="Direct link to updatelayer">​</a></h3><p>Let's take a brief moment to provide a convenience function for visually representing the whole shortcut to the user: </p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">private var stringRepresentation: String {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    var modifiers: NSEvent.ModifierFlags = self.inputModifiers</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    if self.isRecording {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        return modifiers.characters</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        if let shortcut = self.shortcut {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            modifiers.formUnion(NSEvent.ModifierFlags(shortcut.modifierFlags))</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        return modifiers.characters + (self.shortcut?.keyCode.characters ?? "")</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>It's not too much: if we're recording, return the input modifers as a string, but if we're not, use the <code>shortcut</code>'s <code>modifier.characters</code> <strong>and</strong> the input modifier's, together, along with the <code>keyCode</code> as a string at the very end. This will match the canonical string representation seen in <code>NSMenuItem</code>s. Since we're explicitly layer-backed and requesting <code>updateLayer</code>, we should definitely control our visual appearance here:</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override var allowsVibrancy: Bool {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return false</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override var wantsUpdateLayer: Bool {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override func updateLayer() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.textLabel.textColor = self.isEnabled ? self.tintColor : .disabledControlTextColor</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    let str = self.stringRepresentation</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.textLabel.stringValue = str</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.toolTip = Localized.tooltipPrefix + ": " + (str.isEmpty ? Localized.noShortcut : str)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                    + "\n\n" + Localized.help</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.clearButton.isEnabled = self.isEnabled</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    let canStop = self.isRecording || self.shortcut != nil</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.clearButton.image = NSImage(named: canStop ? .stopProgressFreestandingTemplate</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                                                    : .statusUnavailable)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>You'll notice we set the <code>tooltip</code> here as well. It's important to do so per-view, or if we're drawing specific regions with different tooltips, we can use <code>addToolTipRect...</code> and friends; these are hover-based context clues as to what the view under the mouse provides, and there's no iOS equivalent. For now, ignore the <code>Localized...</code> values, as we'll talk about that later.</p><p>Add a <code>self.needsDisplay = true</code> call to the <code>didSet</code> of the properties: <code>tintColor</code>, <code>shortcut</code>, <code>isEnabled</code>, and <code>inputModifers</code>. This will mark the view as needing <code>updateLayer()</code> called, which we can then update visual appearances in.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="drawing-a-button-without-being-one">Drawing a Button Without Being One<a href="#drawing-a-button-without-being-one" class="hash-link" aria-label="Direct link to Drawing a Button Without Being One" title="Direct link to Drawing a Button Without Being One">​</a></h3><p>An important thing to do in designing and implementing a new control is to <strong>always look and feel like a system control!</strong> It's very obvious to a user when an app doesn't do this and it provides the perception of a cheap or poorly designed app, leading to possible user dissatisfaction. For this control, let's act like a mix between a button and text input, because we act like a mix between the two. A good example of a control that already has this appearance is an <code>NSSearchField</code> in an <code>NSToolbar</code> (in a regular <code>NSView</code>, it looks recessed, but in the toolbar it has a button-like appearance). Instead, however, we'll steal the appearance of an <code>NSButton</code> directly using an <code>NSButtonCell</code>. Like I said much earlier in the article, <code>NSCell</code>s encapsulate both event-handling <em>and</em> visual appearance, without being an actual view! We can quite simply share a button cell between all instances of our control and draw it into a sublayer in <code>updateLayer()</code>, using the <code>drawBezel(withFrame:in:)</code> method. Be sure to add the sublayer to our hierarchy and set the correct <code>bezelStyle</code>.</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">private static var stampCell: NSButtonCell = {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    let c = NSButtonCell()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    c.bezelStyle = .texturedRounded</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return c</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">private lazy var underlayer = CALayer()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">private func commonInit() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.layer?.addSublayer(self.underlayer)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override func updateLayer() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    var b = self.bounds.size; b.height = 22</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    let img = NSImage(size: b, flipped: false) { r in</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        KeyboardShortcutView.stampCell.drawBezel(withFrame: r, in: self)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        return true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    CATransaction.begin()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    CATransaction.setDisableActions(true)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.underlayer.contents = img</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.underlayer.contentsScale = self.layer!.contentsScale // inherit</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.underlayer.contentsCenter = CGRect(x: 0.25, y: 0.25, width: 0.5, height: 0.5)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    CATransaction.commit()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override func layout() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    super.layout()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    CATransaction.begin()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    CATransaction.setDisableActions(true)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.underlayer.frame = self.layer!.bounds</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    CATransaction.commit()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><em><code>-[NSButtonCell updateLayerWithFrame:inView:]</code> actually uses a private <code>NSLayerContentsFacet</code> and CoreUI to optimize drawing <code>CALayer</code> contents, but it's a non-issue for us.</em></p><p>If we could use <code>drawRect:</code> it might be more straight forward, but we lose the ability to set the <code>CALayer.contentsCenter</code> which automatically does 9-part image slicing for us, if the <code>underlayer</code> frame and the <code>content</code> size don't match up. You might notice that if you just set <code>layer.frame</code>, it'll animate and look weird as it snaps into a new frame, where we don't expect this to occur. To fix this, we just open an explicit sub-transaction, which disables <code>CALayer</code> actions. Another possible approach to avoid <code>frame</code> implicit animations is to modify the layer's <code>actions</code> dictionary:</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">var implicits = layer.actions</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">implicits["position"] = NSNull()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">implicits["bounds"] = NSNull()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">layer.actions = implicits</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Another small visual issue is that the <code>NSCell</code> we're drawing has no understanding of the control's <code>effectiveAppearance</code>, unless we tell it using <code>NSAppearance.current</code>:</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override func updateLayer() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    let img = NSImage(size: b, flipped: false) { r in</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.effectiveAppearance.using {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            KeyboardShortcutView.stampCell.drawBezel(withFrame: r, in: self)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        return true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">// ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public extension NSAppearance {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public func using(_ handler: () -&gt; ()) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        let x = NSAppearance.current</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        NSAppearance.current = self</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        handler()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        NSAppearance.current = x</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Now, if you set the whole <code>window</code>'s <code>appearance</code> to, say, <code>vibrantDark</code>, the control will render perfectly no matter what size, in that appearance! (It's a little baffling to me that <code>NSButton</code>s don't stretch their drawing, but oh well.)</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="focus-rings">Focus Rings<a href="#focus-rings" class="hash-link" aria-label="Direct link to Focus Rings" title="Direct link to Focus Rings">​</a></h3><p>Now, as a control that can become key and first responder in its <code>window</code>, we should inform the user that we have done so using a focus ring. After macOS Lion, we no longer need to draw them ourselves, but instead provide their bounds and a mask to match our view's shape. Let's just ask our layer to render itself <em>as</em> a mask, since only the alpha channel is used for masking!</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override var focusRingMaskBounds: NSRect {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return (self.isEnabled &amp;&amp; self.window?.firstResponder == self) ? self.bounds : .zero</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override func drawFocusRingMask() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    guard self.isEnabled &amp;&amp; window?.firstResponder == self else { return }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.underlayer.render(in: NSGraphicsContext.current!.cgContext)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Now we just need to add a <code>self.noteFocusRingMaskChanged()</code> call to <code>isEnabled.didSet</code>, so we can show and hide the focus ring automatically. <code>CALayer.render(in:)</code> isn't a great idea in most cases because it actually uses the <code>CG</code> rendering path, instead of the <code>OGL</code> or <code>Metal</code> rendering paths that Core Animation can use to accelerate layers on the GPU, and so it's actually a visual approximation to what the layer actually looks like. This doesn't really bother us because we only need the shape to be correct, though, but it's something to keep in mind in general when designing a view with sublayers.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="layout-updateconstraints--intrinsiccontentsize"><code>layout</code>, <code>updateConstraints</code>, &amp; <code>intrinsicContentSize</code><a href="#layout-updateconstraints--intrinsiccontentsize" class="hash-link" aria-label="Direct link to layout-updateconstraints--intrinsiccontentsize" title="Direct link to layout-updateconstraints--intrinsiccontentsize">​</a></h3><p>Because we have sublayers and subviews, we should adjust their layout here. We've already taken care of <code>underlayer</code>, so now let's dynamically resize our <code>font</code> to match our control's height. It's surprisingly not straightforward, because the facility to do so is found on <code>NSFontManager</code> and not <code>NSFont</code>, but using the facility is pretty easy.</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override func layout() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    if let font = self.font {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.textLabel.font = NSFontManager.shared.convert(font, toSize: self.bounds.height / 1.7)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.textLabel.font = NSFont.systemFont(ofSize: self.bounds.height / 1.7)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Here's where we finally set up and handle constraints! We'll use constraints to handle our subviews, because our sublayer just needs to match our frame. We could, however, add an <code>NSLayoutGuide</code> to our control, set up constraints on that guide, and then synchronize its frame to the sublayer frame, but it's not worth the trouble.</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override class var requiresConstraintBasedLayout: Bool {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">private var childConstraints: [NSLayoutConstraint] = []</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override func updateConstraints() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    if self.childConstraints.count == 0 {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.childConstraints = [</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            self.textLabel.leadingAnchor.constraint(equalTo: self.leadingAnchor, constant: 4.0),</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            self.textLabel.trailingAnchor.constraint(equalTo: self.clearButton.leadingAnchor, constant: 0.0),</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            self.clearButton.trailingAnchor.constraint(equalTo: self.trailingAnchor, constant: 0.0),</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            self.clearButton.heightAnchor.constraint(equalTo: self.heightAnchor, multiplier: 1.0),</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            self.clearButton.widthAnchor.constraint(equalTo: self.clearButton.heightAnchor, multiplier: 1.0),</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            self.textLabel.centerYAnchor.constraint(equalTo: self.centerYAnchor, constant: -1.0),</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            self.clearButton.centerYAnchor.constraint(equalTo: self.centerYAnchor),</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        ]</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        NSLayoutConstraint.activate(self.childConstraints)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    super.updateConstraints()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The gist of it is, <code>updateConstraints()</code> is called post-initialization, and whenever we set <code>self.needsUpdateConstraints = true</code>, and if we haven't configured any constraints, we'll cache our constraints and activate them. It's helpful to do so in this method because we may, in the future, want to dynamically adjust our constraints, and we can do that in order with the layout and display cycle here.</p><p>The last thing we should do as a good citizen control, is provide an <code>intrinsicContentSize</code>: this is the size that our control will take up if we don't add any size constraints to it. Usually, it's just the smallest bounding box of the control's contents, which we can sum the <code>intrinsicContentSize</code>s of our <code>textLabel</code> and <code>clearButton</code> to find. Since there's a chance that they might provide a <code>.noIntrinsicMetric</code>, and our control <em>does</em> have intrinsic metrics for width (both <code>textLabel</code> and <code>clearButton</code> do, in fact), we should be cautious of that case. We'll factor in our padding from the constraints above as well.</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override var intrinsicContentSize: NSSize {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    var _t = self.textLabel.intrinsicContentSize</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    var _b = self.clearButton.intrinsicContentSize</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    if _t.width == NSView.noIntrinsicMetric { _t.width = 0.0 }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    if _b.width == NSView.noIntrinsicMetric { _b.width = 0.0 }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // Compute the sum/max of the intrinsicContentSizes of our subviews.</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return NSSize(width: _t.width + _b.width + 12.0 /* padding */,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                  height: max(_t.height, _b.height) /* 22.0? */)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>We could also take the approach that <code>NSButton</code> and similar controls take, which is to clamp the intrinsic size to <code>22px</code> in height. For a platform with a cursor, <code>22px</code> is the "right height" for a clickable control that contains a label, and for a platform that relies on touch input, it's between <code>32px</code> and <code>44px</code>. <em>(That's from the Apple HIG somewhere.)</em></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="hover--cursors">Hover &amp; Cursors<a href="#hover--cursors" class="hash-link" aria-label="Direct link to Hover &amp; Cursors" title="Direct link to Hover &amp; Cursors">​</a></h3><p>To support any kind of cursor change or mouse hovering, we need to use <code>NSTrackingArea</code> and the related methods on <code>NSView</code> used to add and remove them. It's not recommended to use any of the methods with the phrase <code>TrackingRect</code> or <code>CursorRect</code> in them - they've been superseded since Leopard by <code>NSTrackingArea</code>.</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">private func commonInit() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.addTrackingArea(NSTrackingArea(rect: .zero,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                                        options: [.activeInKeyWindow, .inVisibleRect, .cursorUpdate],</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                                        owner: self, userInfo: nil))</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override func cursorUpdate(with event: NSEvent) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    NSCursor.pointingHand.set()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>We don't even have to implement <code>updateTrackingAreas()</code> to handle changing frames or anything. The <code>NSTrackingArea</code> makes sure that <code>cursorUpdate(with:)</code> is only called with the visible frame of the view, when the window containing the view is key. It's dead simple; if we wanted to support mouse hovering, to perhaps display suggestions or change our drawing in some way, we would just change <code>.cursorUpdate</code> to <code>.mouseEnteredAndExited</code> or <code>.mouseMoved</code>. Maybe we just want to change our drawing or cursor when we're the first responder? Just change <code>.activeInKeyWindow</code> to <code>.activeWhenFirstResponder</code> -- be mindful that the <code>options</code> are three individual option sets masked together. You can't use <code>.activeInKeyWindow</code> and <code>.activeWhenFirstResponder</code> simultaneously for example.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="haptic--audio-feedback">Haptic &amp; Audio Feedback<a href="#haptic--audio-feedback" class="hash-link" aria-label="Direct link to Haptic &amp; Audio Feedback" title="Direct link to Haptic &amp; Audio Feedback">​</a></h3><p>Some controls may want to add audio feedback support, like <code>NSButton.sound</code>, but in my opinion, this makes assumptions on the availability and implementation of the audo feedback (what if the client wishes to use <code>AVAudioPlayer</code>?); instead, it's probably a better idea to play the sound in our delegate or target/action methods. If we did want to support audio feedback with <code>NSSound</code>, however, it's quite simple:</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">@objc open var sound: NSSound? = nil</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">// ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">open func doSomething() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.sound?.play()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Likewise, some controls may want to add haptic feedback, but those controls <em>(should)</em> primarily rely on <em>(specifically)</em> force touch interaction, like dragging or deep pressing, and our shortcut recording control relies primarily on keyboard input. If we were to, adding simple haptic responses is just as simple, albeit a little more wordy:</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">@objc open var hapticPerformer: NSHapticFeedbackPerformer? = NSHapticFeedbackManager.defaultPerformer</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">// ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">open func doSomething() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.hapticPerformer?.perform(.levelChange, performanceTime: .drawCompleted)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>In this specific case, while currently on macOS, there is only a <code>defaultPerformer</code>, we can expect that there may be more in the future, perhaps one for the touch bar, as an example. In anticipating such changes, it might be a good idea to allow our client to set the desired <code>hapticPerformer</code> - if it's set to <code>nil</code>, it acts as if we've disabled haptic feedback.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="window-keyedness">Window Keyedness<a href="#window-keyedness" class="hash-link" aria-label="Direct link to Window Keyedness" title="Direct link to Window Keyedness">​</a></h3><p><img loading="lazy" alt="NSWindow State" src="/assets/images/window-state-ccecc78070390cf7b33c68fa20484132.png" width="608" height="417" class="img_ev3q"></p><p>An important concept on macOS is that of window "keyedness" and "main-ness", as you can see above. Controls are expected to draw accordingly to visually explain to the user if they're able to be interacted with or not. We can monitor our parent <code>window</code>'s state without any strong reference to the <code>window</code> by using the <code>viewWillMove(toWindow:)</code> method, and then trampoline that using <code>NSNotificationCenter</code>.</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">@objc private func windowKeyednessChanged(_ note: Notification) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    guard let window = self.window, (note.object as? NSWindow) == window else { return }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // do nothing for now</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override func viewWillMove(toWindow newWindow: NSWindow?) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    let n = NotificationCenter.default // shorthand</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    if let oldWindow = self.window {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        n.removeObserver(self, name: NSWindow.didBecomeKeyNotification,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                         object: oldWindow)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        n.removeObserver(self, name: NSWindow.didResignKeyNotification,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                         object: oldWindow)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    if let newWindow = newWindow {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        n.addObserver(self, selector: #selector(self.windowKeyednessChanged(_:)),</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                      name: NSWindow.didBecomeKeyNotification, object: newWindow)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        n.addObserver(self, selector: #selector(self.windowKeyednessChanged(_:)),</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                      name: NSWindow.didResignKeyNotification, object: newWindow)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">deinit {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    NotificationCenter.default.removeObserver(self) // just in case</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Now, we'll get the <code>windowKeyednessChanged(_:)</code> notifications whenever keyedness changes (and note that we could do the same for main-ness as well) without worrying about which window we're contained within. The next thing to do is wire our first responder state into the method, which sounds inappropriate, but since we use the method <em>just</em> for handling drawing and event state, it's okay to do so without getting pedantic about it.</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override func becomeFirstResponder() -&gt; Bool {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    DispatchQueue.main.async {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.windowKeyednessChanged(Notification(name: NSWindow.didBecomeKeyNotification,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                                                 object: self.window, userInfo: nil))</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override func resignFirstResponder() -&gt; Bool {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    DispatchQueue.main.async {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.windowKeyednessChanged(Notification(name: NSWindow.didResignKeyNotification,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                                                 object: self.window, userInfo: nil))</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>We need to enqueue the <code>windowKeyednessChanged</code> invocation to the main queue because we haven't yet become the first responder until the <code>become/resignFirstResponder</code> method returns.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="global-hotkey-interference">Global HotKey Interference<a href="#global-hotkey-interference" class="hash-link" aria-label="Direct link to Global HotKey Interference" title="Direct link to Global HotKey Interference">​</a></h3><p>At this point we have a fully functional keyboard shortcut recorder! However... attempting to record certain shortcuts, you'll find, don't work, mysteriously. After a few different shortcuts you've tried to record, it hits you: these are symbolic shortcuts that we've set in the System Preferences! We're accidentally triggering them instead of recording the shortcut! Surely, you wonder, how does System Preferences allow you to record shortcuts without triggering symbolic ones willy-nilly? The answer lies in a den of dragons:</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">// Here lie dragons!</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">fileprivate typealias CGSConnectionID = UInt</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">fileprivate enum CGSGlobalHotKeyOperatingMode: UInt {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    case enable = 0, disable = 1, universalAccessOnly = 2</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">@_silgen_name("CGSMainConnectionID")</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">fileprivate func CGSMainConnectionID() -&gt; CGSConnectionID</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">@_silgen_name("CGSGetGlobalHotKeyOperatingMode")</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">fileprivate func CGSGetGlobalHotKeyOperatingMode(_ connection: CGSConnectionID,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                                                 _ mode: UnsafeMutablePointer&lt;CGSGlobalHotKeyOperatingMode?&gt;) -&gt; CGError</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">@_silgen_name("CGSSetGlobalHotKeyOperatingMode")</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">fileprivate func CGSSetGlobalHotKeyOperatingMode(_ connection: CGSConnectionID,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                                                 _ mode: CGSGlobalHotKeyOperatingMode) -&gt; CGError</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The answer to recording hotkeys that have been reserved already... is to turn off hotkeys globally while you're first responder. I swear up and down this is exactly what System Preferences does - take a look yourself if you don't believe me! It's pretty simple to cache the existing global state, turn the hotkeys off, and then once we're resigning first responder, reset the global state. Here's what that looks like:</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">private var savedOperatingMode: CGSGlobalHotKeyOperatingMode? = nil</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">deinit {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    if self.savedOperatingMode != nil {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        _ = CGSSetGlobalHotKeyOperatingMode(CGSMainConnectionID(), self.savedOperatingMode!)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">@objc private func windowKeyednessChanged(_ note: Notification) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    if window.isKeyWindow &amp;&amp; window.firstResponder == self { // becomeKey</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        guard self.savedOperatingMode == nil else { return }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        _ = CGSGetGlobalHotKeyOperatingMode(CGSMainConnectionID(), &amp;self.savedOperatingMode)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        _ = CGSSetGlobalHotKeyOperatingMode(CGSMainConnectionID(), .disable)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    } else { // resignKey</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        guard self.savedOperatingMode != nil else { return }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        _ = CGSSetGlobalHotKeyOperatingMode(CGSMainConnectionID(), self.savedOperatingMode!)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.savedOperatingMode = nil</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        window.makeFirstResponder(nil) // resign ourselves if window resigned</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>A disclaimer: <em>you don't need to include this to roll a fully functional shortcut recorder.</em> You <strong>can</strong> ignore the fact that the user will be trying to record shortcuts and then be disappointed that it's not working. You <strong>can!</strong> let your user down! And you <strong>will</strong> if you're submitting your app to the MAS, so keep this in mind. We're not to use this facility for evil, but to respond to exactly what the user is doing. The unfortunate downside is that the symbolic/other hot keys will be triggered when the user double-dips with our app, unless we claim the shortcut exclusively (see, there <em>was</em> a reason for that!).</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="string-localization">String Localization<a href="#string-localization" class="hash-link" aria-label="Direct link to String Localization" title="Direct link to String Localization">​</a></h3><p>Alright, we're done now right? No one using this control lives outside America (and even those that live within, they definitely speak English fluently, right?) and none of <em>our users</em> are disabled right? <strong>Wrong.</strong> Always consider that you, as the developer, are not the target audience of your tool (be it a control, or an app), and always focus on <strong>i18n</strong> and <strong>accessibility</strong>, because like it or not, it's not beneficence, it's a responsibility.</p><p>Luckily, localization support is pretty easy, except for the hard part (which is the localization itself). I've opted to wrap it into a <code>Localized</code> container with a helper function <code>value(_:default:comment:)</code> that looks up the string from the bundle that contains the class. This is important, because your control may or may not be in the <code>main</code> bundle. To use it, just create static properties like <code>Localized.voiceOverBegin</code> below:</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">private enum Localized {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    private static func value(_ key: String, `default`: String, comment: String) -&gt; String {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        return NSLocalizedString(key, tableName: nil, bundle: Bundle(for: KeyboardShortcutView.self),</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                                 value: `default`, comment: comment) // helper!</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    fileprivate static var actionName: String {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        return value("action_name", default: "Record Shortcut",</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                     comment: "The action name for undo and redo")</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    fileprivate static var voiceOverBegin: String {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        return value("voiceover_begin", default: "Now recording a shortcut",</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                     comment: "The notification name for VoiceOver if the control began recording")</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Always provide helpful comments for your translators, and provide a <code>default</code> in your expected target language in case you haven't loaded a good <code>strings</code> file, or you just plain don't have one in the current bundle.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="accessibility">Accessibility<a href="#accessibility" class="hash-link" aria-label="Direct link to Accessibility" title="Direct link to Accessibility">​</a></h3><p>I'm no accessibility expert, but here's the bare minimum you should implement for a control that resembles a button and contains other sub-controls. Be sure to conform <code>KeyboardShortcutView</code> to <code>NSAccessibilityButton</code> and <code>NSAccessibilityGroup</code>.</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override func isAccessibilityElement() -&gt; Bool {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override func accessibilityHelp() -&gt; String? {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return Localized.help</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override func accessibilityRole() -&gt; NSAccessibilityRole? {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return .button</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override func accessibilityLabel() -&gt; String? {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    let str = self.stringRepresentation</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return str.isEmpty ? Localized.noShortcut : str</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override func accessibilityValue() -&gt; Any? {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return self.accessibilityLabel()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override func accessibilityRoleDescription() -&gt; String? {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return Localized.tooltipPrefix</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override var accessibilityFocusedUIElement: Any? {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return self.window?.firstResponder == self</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override func accessibilityChildren() -&gt; [Any]? {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return [self.clearButton]</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override func accessibilityPerformPress() -&gt; Bool {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    guard self.isEnabled else { return false }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.performClick(nil)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>And while that presents our accessible properties to the accessibility daemons and tools, we should also post notifications using <code>NSAccessibilityPostNotification</code> when <code>shortcut</code> changes, and definitely emit a VoiceOver announcement when we change recording state or set the shortcut from user input.</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">/*@objc*/ open var shortcut: KeyboardShortcutView.Pair? {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    didSet {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        NSAccessibilityPostNotification(self, .valueChanged)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override func performKeyEquivalent(with event: NSEvent) -&gt; Bool {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    if /* we should record the new shortcut */ {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        NSAccessibilityPostNotificationWithUserInfo(self, .announcementRequested, [</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            .announcement: Localized.voiceOverRecorded,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            .priority: NSAccessibilityPriorityLevel.high</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        ])</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        return true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public func beginRecording() -&gt; Bool {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    NSAccessibilityPostNotificationWithUserInfo(self, .announcementRequested, [</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        .announcement: Localized.voiceOverBegin,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        .priority: NSAccessibilityPriorityLevel.high</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    ])</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">@objc private func buttonAction(_ button: NSButton) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    if /* we should clear the shortcut set */ {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        NSAccessibilityPostNotificationWithUserInfo(self, .announcementRequested, [</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            .announcement: Localized.voiceOverCleared,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            .priority: NSAccessibilityPriorityLevel.high</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        ])</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override func updateLayer() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.clearButton.setAccessibilityLabel(canStop ? Localized.buttonRecordLabel</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                                                   : Localized.buttonClearLabel)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">in KeyboardShortcutView.clearButton.getter:</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        button.toolTip = Localized.buttonTooltip</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        button.setAccessibilityHelp(Localized.buttonTooltip)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>We don't just place the VoiceOver announcements in <code>willSet</code>/<code>didSet</code> for <code>isRecording</code>, because they are unique to the reason why the recording state changed.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="nscoding--state-restoration"><code>NSCoding</code> &amp; State Restoration<a href="#nscoding--state-restoration" class="hash-link" aria-label="Direct link to nscoding--state-restoration" title="Direct link to nscoding--state-restoration">​</a></h3><p>One of the most crucial things is to support <code>NSCoding</code> if you aim to be Interface Builder-compatible, and to support automatic termination, through <code>NSResponder</code> state restoration. State restoration should encode and decode only a subset of the keys the class typically encodes or decodes for <code>NSCoding</code>: the ones that are actually user-facing state. As Apple says, <em>"you must store enough data to reconfigure the responder and return it to its current state during a subsequent launch of the application."</em></p><p><strong>Here, you really should <em>not</em> be passing <code>NSCoding</code> methods onto <code>NSResponder</code>'s state restoration.</strong> I leave the proper implementation as an exercise for the reader. <em>(read: I was lazy about it.)</em> I've decided to not implement it correctly as I'm currently experimenting with a <code>Codable</code> &lt;--&gt; <code>NSCoding</code> adapter specific to my implementation of this control. I'll possibly write another post on that later.</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">open static var supportsSecureCoding: Bool {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public required init?(coder: NSCoder) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    super.init(coder: coder)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.restoreState(with: coder)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.commonInit()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override func encode(with coder: NSCoder) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    super.encode(with: coder)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.encodeRestorableState(with: coder)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override func encodeRestorableState(with coder: NSCoder) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    //super.encodeRestorableState(with: coder)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    coder.encode(self.suggestions.map { representation(of: $0) }, forKey: "suggestions")</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    coder.encode(representation(of:self.shortcut), forKey: "shortcut")</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    coder.encode(self.isEnabled as NSNumber, forKey: "isEnabled")</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override func restoreState(with coder: NSCoder) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    //super.restoreState(with: coder)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    let s = coder.decodeObject(of: NSArray.self, forKey: "suggestions") as? [NSDictionary]</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.suggestions = (s ?? []).compactMap { representation(of: $0) }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.shortcut = representation(of: coder.decodeObject(of: NSDictionary.self, forKey: "shortcut"))</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.isEnabled = coder.decodeObject(of: NSNumber.self, forKey: "isEnabled") as? Bool ?? false</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Be sure to conform <code>KeyboardShortcutView</code> to <code>NSSecureCoding</code>. When we change certain properties (the ones we're encoding and decoding), we should call <code>invalidateRestorableState</code> to ensure our current state is encoded (automatic termination is like the grim reaper: it arrives without warning, and thus we must protect our interests before its arrival). Add the <code>self.invalidateRestorableState()</code> call to the <code>didSet</code> of <code>shortcut</code>, <code>suggestions</code>, and <code>isEnabled</code>. </p><p>Now when you make a change, quit the app, reopen it, and you'll find that things were as you left it before you quit the app!</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="context-nsmenu-popups">Context <code>NSMenu</code> Popups<a href="#context-nsmenu-popups" class="hash-link" aria-label="Direct link to context-nsmenu-popups" title="Direct link to context-nsmenu-popups">​</a></h3><p>It may be desirable to allow the user to select a keyboard shortcut from a list of suggestions, like the Siri System Preferences pane, for example. To support this, let's add a <code>suggestions</code> property that takes an <code>[KeyboardShortcutView.Pair]</code>. When a <code>Pair</code> is selected from the list, the <code>shortcut</code> property is overridden with the selected value.</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">/*@objc*/ open var suggestions: [KeyboardShortcutView.Pair] = [] {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    willSet { self.willChangeValue(forKey: #function) }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    didSet {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.didChangeValue(forKey: #function)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Now, how do we actually display the list of suggestions to the user, in-band with the control itself? <code>NSView</code> offers a <code>menu</code> property, but we can also override <code>menu(for:)</code> to return an <code>NSMenu</code> based on where the menu-opening right click occurred, specifically. Since we don't need that level of granularity, let's go ahead and override <code>menu</code> directly and map <code>suggestions</code> into <code>NSMenuItem</code>s. Note that to be able to manually enable or disable menu items, we should set <code>NSMenu.autoenablesItems</code> to <code>false</code>, because otherwise, <code>NSMenu</code> will validate the existence of each menu item's <code>action</code> method existing on the item's <code>target</code>. </p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override var menu: NSMenu? {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    get {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        let menu = NSMenu()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        menu.autoenablesItems = false</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        for (i, x) in self.suggestions.enumerated() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            let str = Localized.menuPrefix + " " + x.modifierFlags.characters + x.keyCode.characters</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            let item = NSMenuItem(title: str, action: #selector(self.selectAction(_:)), keyEquivalent: "")</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            item.tag = i</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            item.target = self</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            item.isEnabled = self.isEnabled</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            menu.addItem(item)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        return menu</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    set { }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">@objc private func selectAction(_ item: NSMenuItem) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    guard self.isEnabled else { return }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.endRecording()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.shortcut = self.suggestions[item.tag]</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>We've also overridden <code>menu.setter</code> to become a no-op, because we no longer want to allow a client to set a <code>menu</code> that may have no context with our control. In effect, we're forcing our clients to use <code>suggestions</code> only. An alternative could be to override <code>menu(for:)</code> and return a new <code>NSMenu</code> with <code>self.menu.items + self.suggestions.map { $0.toMenuItem() }</code> (pseudocode). </p><p>Astute readers will spot the race condition possible with this code: <code>suggestions</code> may have been modified between <code>menu.getter</code> and <code>selectAction(_:)</code>, causing <code>self.suggestions[item.tag]</code> to become inconsistent or crash. <em>Solving this race condition is an exercise left to the reader... (I'm just using that phrase to avoid solving the problems myself aren't I?)</em></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="undo-management">Undo Management<a href="#undo-management" class="hash-link" aria-label="Direct link to Undo Management" title="Direct link to Undo Management">​</a></h3><p>Because macOS applications use variations of the <code>⌘Z</code> shortcut to undo or redo, it might seem a little odd to support undo management in a control that's designed to record keyboard shortcuts themselves. However, as long as the control isn't the first responder, the undo action will always trigger, <em>except</em> in cases where the app has registered <code>⌘Z</code> as a global shortcut (the <code>delegate</code> should ideally prevent things like that).</p><p>Adding support for undo management is actually very easy; since setting the <code>shortcut</code> property changes what the user sees, and we set this property internally in <code>performKeyEquivalent(_:)</code>, we can register our undo action there! This does have an unintended/unwanted side effect of also pushing the undo stack when the app is programmatically setting the <code>shortcut</code> value. However, I think it's perfectly acceptable to keep a continuous undo stack between the app and user actions in this case.</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">/*@objc*/ open var shortcut: KeyboardShortcutView.Pair? {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    didSet {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.undoManager?.registerUndo(withTarget: self) { [oldValue] _ in</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            self.shortcut = oldValue</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.setActionName(Localized.actionName)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Each <code>NSResponder</code> has an <code>undoManager</code> that we can just register the undo action with -- an undo action takes <code>self</code> as the target, with a handler to execute when the user un-does the current action. Notice that we capture <code>oldValue</code> at registration-time, instead of invocation-time: this is so we don't set the undone <code>shortcut</code> value to itself accidentally.</p><p>Running an application with an existing saved state, we'll notice an unusual glitch: it appears that even though the app was just launched (and restored its state), the user sees an undo action, even though they haven't interacted with the control yet! This is because the one edge-case we need to control in setting the <code>shortcut</code> property is the initializer(s) setting it. A <code>Swift</code> initializer does not invoke any property observers when a member's value is set, <strong>however</strong>, <code>restoreState(_:)</code> is not an initializer! It's a normal method, and thus, will invoke the <code>didSet</code>, which is harmless, except for this particular side effect. The solution is to only register an action with the undo manager if we aren't restoring state.</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">/*@objc*/ open var shortcut: KeyboardShortcutView.Pair? {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    didSet {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        if !self.isRestoringState {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            self.undoManager?.registerUndo(withTarget: self) { [oldValue] _ in</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                self.shortcut = oldValue</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            self.setActionName(Localized.actionName)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">// ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">private var isRestoringState: Bool = false</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override func restoreState(with coder: NSCoder) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.isRestoringState = true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    defer {self.isRestoringState = false }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Now, running the app from an existing saved state won't cause unexpected undo actions to register! The astute reader will also observe that we could just flip the condition on <code>isRestoringState</code>, calling the boolean <code>shouldRegisterUndo</code>, and only enable it during <code>performKeyEquivalent(_:)</code>. That's a perfectly fine solution as well, depending on what undo registration behavior you want to achieve.</p><p>What about redo actions? We've only set up undo actions: if the user types <code>⌘L</code> and then undoes the action, how do we allow the user to redo that (that is, set the shortcut again to <code>⌘L</code>)? It turns out that <code>UndoManager</code> handles this logic already, and if we're currently executing the registered undo action's handler, <code>isUndoing</code> is <code>true</code>, and the "undo action of the undo action" is translated into a "redo action" for us. We're all done here!</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="conclusion">Conclusion<a href="#conclusion" class="hash-link" aria-label="Direct link to Conclusion" title="Direct link to Conclusion">​</a></h2><p>With that, we've completely designed and implemented a keyboard shortcut recording control, following correct practice and masquerading as a first class AppKit citizen! If you have any questions, comments, or concerns, contact me on Twitter or Github @avaidyam!</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Building a Better RegisterEventHotKey]]></title>
        <id>https://aditya.vaidyam.me/blog/2018/03/16/</id>
        <link href="https://aditya.vaidyam.me/blog/2018/03/16/"/>
        <updated>2018-03-16T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Okay, well, maybe not better, but at least, not under imminent threat of deprecation - and even that is questionable, because we'll be using [Private SPI] (I mean, would you really be here reading this if it didn't? At least I've marked it all so you can cut it out for MAS apps.)]]></summary>
        <content type="html"><![CDATA[<p>Okay, well, maybe not better, but at least, not under imminent threat of deprecation - and even that is questionable, because we'll be using <code>[Private SPI]</code> (I mean, would you really be here reading this if it didn't? At least I've marked it all so you can cut it out for MAS apps.)</p><p>Recently, I've wanted to get around to adding "hot key" support for Parrot, and realized I didn't like any of the existing solutions:</p><ol><li>Use <code>MASShortcut</code> or <code>ShortcutRecorder</code> which are tried and proven to work in ObjC-land.</li><li>Use a new but not proven Swift hotkey recorder (there's a few out there).</li><li>Roll my own using dangerous private SPI and not test it at all! </li></ol><p><em>Obviously I went with option #3.</em> </p><p>I ended up building a µFramework (everything these days is one, right?) that handles hotkeys, provides a user input and display for hotkeys, and a small high-level recognizer platform to handle them with ease. I'll walk you, the reader, through each step! But first, I want to clarify something: the terms "hot key", "key equivalent", "keyboard shortcut", and "mnemonic" are not the same things, on the same or different (i.e. macOS vs Windows) platforms, and so here, I've chosen "keyboard shortcut" as the most descriptive term. </p><p>Before we get into the nitty gritty hand-holding pair-programming stuff, if you'd like to jump straight to the comment-annotated final source code, <a href="https://gist.github.com/avaidyam/32975976c23dd3b38336f22d971f5eaa" target="_blank" rel="noopener noreferrer">I've included a snapshot here.</a> It's the whole final product, exactly 1500 LOC, including the code from the next "episode" - a corresponding keyboard shortcut recording control! If you think this should be a formal repository and whatnot, contact me on Twitter or Github @avaidyam!</p><hr><h2 class="anchor anchorWithStickyNavbar_LWe7" id="how-does-registereventhotkey-work">How does <code>RegisterEventHotKey</code> work?<a href="#how-does-registereventhotkey-work" class="hash-link" aria-label="Direct link to how-does-registereventhotkey-work" title="Direct link to how-does-registereventhotkey-work">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="disassembly--reverse-engineering">Disassembly &amp; Reverse Engineering<a href="#disassembly--reverse-engineering" class="hash-link" aria-label="Direct link to Disassembly &amp; Reverse Engineering" title="Direct link to Disassembly &amp; Reverse Engineering">​</a></h3><p>The first step to designing a better <code>X</code> is to understand how <code>X</code> works. To do that, whip out <code>Hopper</code> (I'm not paid to say this but if you don't have this app yet, you definitely need it!) and disassemble <code>/System/Library/Carbon.framework/Frameworks/HIToolbox.framework</code>. Locate the function and take a peek -- or, if you'd like, <a href="https://gist.github.com/avaidyam/18b7c3d0a15afade931d10a27ed53872" target="_blank" rel="noopener noreferrer">just take a look at my cleaned up version of the function here.</a> I also added a similar function from <code>ScreenReader.framework</code> to cross-reference with.</p><p>All the function basically does is wrap its parameters into an internal data type and call through to <code>SkyLight.framework</code> (you may know it as <code>CoreGraphicsServices</code>, from <code>CoreGraphics.framework</code> on pre-macOS 12) while keeping track of the hotkey registration in a static var dictionary. I'll come back to the CoreGraphics call in a little bit, because this function does something very interesting... we'll also ignore the <code>CGSSetHotButtonWithExclusion</code> call, which is actually an alias for the function <code>CGSSetHotKeyRepresentationWithOptions</code>, because that's not what we want right now. We'll instead be using <code>CGSSetHotKeyWithExclusion</code>. </p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="cgshotkey-symbols">CGSHotKey Symbols<a href="#cgshotkey-symbols" class="hash-link" aria-label="Direct link to CGSHotKey Symbols" title="Direct link to CGSHotKey Symbols">​</a></h3><p>Here's a complete list of <code>CGSHot*</code> symbols:</p><ul><li><code>CGSGetHotButton</code></li><li><code>CGSGetHotKeyRepresentation</code></li><li><code>CGSGetHotKeyType</code></li><li><code>CGSGetHotModifier</code></li><li><code>CGSSetHotButtonWithExclusion</code></li><li><code>CGSSetHotKeyEnabled</code></li><li><code>CGSSetHotKeyRepresentation</code></li><li><code>CGSSetHotKeyRepresentationWithOptions</code></li><li><code>CGSSetHotKeyType</code></li><li><code>CGSSetHotKeyWithExclusion</code></li><li><code>CGSSetHotKeyWithOptions</code></li><li><code>CGSSetHotModifierWithExclusion</code></li><li><code>CGSSetHotModifierWithOptions</code></li><li><code>CGSGetSymbolicHotKeyButtonValue</code></li><li><code>CGSGetSymbolicHotKeyRepresentation</code></li><li><code>CGSGetSymbolicHotKeyRepresentationList</code></li><li><code>CGSGetSymbolicHotKeyValuesAndStates</code></li><li><code>CGSGetSymbolicHotModifierValue</code></li><li><code>CGSSetSymbolicHotKey</code></li><li><code>CGSSetSymbolicHotKeyButtonValue</code></li><li><code>CGSSetSymbolicHotKeyEnabledForConnection</code></li><li><code>CGSSetSymbolicHotKeyRepresentation</code></li><li><code>CGSSetSymbolicHotKeyValue</code></li><li><code>CGSSetSymbolicHotKeyWithExclusion</code></li><li><code>CGSSetSymbolicHotKeyWithOptions</code></li><li><code>CGSSetSymbolicHotModifierValue</code></li><li><code>CGSIsSymbolicHotKeyEnabledForConnection</code></li></ul><p>I'll demystify some of these symbols: there are two types of "hot" events: <strong>regular</strong>, and <strong>symbolic</strong>. Symbolic hot events are those that the <code>WindowServer</code> has designated and named. <a href="https://github.com/NUIKit/CGSInternal/blob/master/CGSHotKeys.h#L38" target="_blank" rel="noopener noreferrer">You can find a near-full list of symbolic identifiers here.</a> These include things like Exposé or Screenshot keys, basically those that are defined in the "System Preferences &gt; Keyboard &gt; Shortcut" pane. </p><p>Now, within these types, there are subtypes: <code>HotKey</code>, <code>HotButton</code>, <code>HotModifier</code>, and <code>HotKeyRepresentation</code>. <code>HotButton</code> is actually just an alias for <code>HotKeyRepresentation</code>, which I'll admit, I'm not savvy to the reason behind its specific distinction. <code>HotModifier</code> is just that -- a modifier press that activates an event, like Siri or Dictation shortcuts. Finally, what we want, is the <code>HotKey</code> facility, which is a plain old keyboard shortcut, with a virtual key code, and a modifier list. </p><p>There is a special <code>WithExclusion</code> function, which calls through to <code>WithOptions</code> (presumably, there are more options, but I doubt any are used right now): setting a hot key with exclusion implies that no other application (including the calling one) may register this same hot key again, and if it was already acquired by another application, the call fails. As far as I'm able to tell, this is the behavior, but I can't be sure since I haven't dug deeper into this option.</p><hr><h2 class="anchor anchorWithStickyNavbar_LWe7" id="building-a-replacement-cgskeyboardshortcut">Building a replacement: <code>CGSKeyboardShortcut</code>!<a href="#building-a-replacement-cgskeyboardshortcut" class="hash-link" aria-label="Direct link to building-a-replacement-cgskeyboardshortcut" title="Direct link to building-a-replacement-cgskeyboardshortcut">​</a></h2><p>Since we've got a cursory understanding of how the existing Carbon facility works, and what hot events facilities Window Server offers, we can architect our own version. </p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">public final class CGSKeyboardShortcut: Hashable {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="properties--acquisition-policy">Properties &amp; Acquisition Policy<a href="#properties--acquisition-policy" class="hash-link" aria-label="Direct link to Properties &amp; Acquisition Policy" title="Direct link to Properties &amp; Acquisition Policy">​</a></h3><p>A keyboard shortcut needs a virtual key code (<code>CGKeyCode</code>), modifier flags (<code>CGEventFlags</code>, instead of <code>NSEvent.ModifierFlags</code>), and an identifier (we'll create a intly-typed wrapper, for better developer&amp;user-side management), at the very least.</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">public struct Identifier: RawRepresentable, Hashable, Codable {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public typealias RawValue = Int</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public let rawValue: Identifier.RawValue</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public init(rawValue: Identifier.RawValue) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.rawValue = rawValue</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public init(_ rawValue: Identifier.RawValue) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.rawValue = rawValue</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public let identifier: CGSKeyboardShortcut.Identifier</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public let keyCode: CGKeyCode</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public let modifierFlags: CGEventFlags</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Now, returning to the issue of <code>WithExclusion</code>, we'll also add an <code>AcquisitionPolicy</code> to handle that:</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">public enum AcquisitionPolicy: Int, Codable {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    case none</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    case exclusively</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    case exclusivelyIfPossible</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public let acquisitionPolicy: AcquisitionPolicy</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public init(identifier: CGSKeyboardShortcut.Identifier, keyCode: CGKeyCode,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">       modifierFlags: CGEventFlags, acquisitionPolicy: AcquisitionPolicy = .none) throws</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">{</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.identifier = identifier</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.keyCode = keyCode</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.modifierFlags = modifierFlags</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.acquisitionPolicy = acquisitionPolicy</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Essentially, this will be the policy to use when initializing a new <code>CGSKeyboardShortcut</code> - do we want to do so <code>exclusively</code>, not (<code>none</code>) at all, or maybe <code>exclusivelyIfPossible</code>? The final option is a special case where we'll attempt to be exclusive, but if someone else got to the shortcut first, we still do want a shortcut event delivered to our handler. (Note that we shouldn't be considering this value in equality between two <code>CGSKeyboardShortcut</code>s.)</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="resource-management">Resource Management<a href="#resource-management" class="hash-link" aria-label="Direct link to Resource Management" title="Direct link to Resource Management">​</a></h3><p>Since keyboard shortcuts are something of a finite resource (there are only so many key combinations viable for user input) and application or component acquisition matters, we'll keep a <code>Set</code> of registered keyboard shortcuts at all times, but note that we can only keep track of the shortcuts tracked through our new facility, and not those by <code>CGS</code> or <code>HIToolbox</code> facilities, unfortunately.</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">public private(set) static var all: Set&lt;CGSKeyboardShortcut&gt; = []</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public init(...) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    guard CGSKeyboardShortcut.all.filter({ $0.identifier == identifier }).count == 0 else {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        throw CGError.cannotComplete</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    CGSKeyboardShortcut.all.insert(self)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">deinit {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    CGSKeyboardShortcut.all.remove(self)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>There is an issue with this mechanism as it stands, though. If we'd like to invalidate a keyboard shortcut, we have no way of <code>deinit</code>ing it without removing it from the <code>Set</code>, which only happens upon <code>deinit</code>! That's a problem, so we'll add an explicit <code>invalidate</code> method (or two).</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">deinit {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.invalidate()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public func invalidate() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    CGSKeyboardShortcut.all.remove(self)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public static func invalidateAll() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    CGSKeyboardShortcut.all = []</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>There, that's a little better. Now, we don't need to hold an explicit reference to a shortcut to keep it valid, and we'll need this <code>Set</code> for actually handling shortcuts soon anyway. </p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="windowserver-acquisition--invalidation">WindowServer Acquisition &amp; Invalidation<a href="#windowserver-acquisition--invalidation" class="hash-link" aria-label="Direct link to WindowServer Acquisition &amp; Invalidation" title="Direct link to WindowServer Acquisition &amp; Invalidation">​</a></h3><p>Now that we've defined our shortcut class and its containment/usage policies, how do we actually... you know, make it do stuff? For that, we'll need to add a suffix to our file here:</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">// Here lie dragons!</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">fileprivate typealias CGSConnectionID = UInt</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">@_silgen_name("CGSMainConnectionID")</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">fileprivate func CGSMainConnectionID() -&gt; CGSConnectionID</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">@_silgen_name("CGSSetHotKeyWithExclusion")</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">fileprivate func CGSSetHotKeyWithExclusion(_ connection: CGSConnectionID,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                                           _ hotKeyID: Int,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                                           _ hotKeyMask: UInt16, // always 0xffff</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                                           _ keyCode: UInt16,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                                           _ modifierFlags: UInt64,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                                           _ options: Int8) -&gt; CGError</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">@_silgen_name("CGSSetHotKeyType")</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">fileprivate func CGSSetHotKeyType(_ connection: CGSConnectionID,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                                  _ hotKeyID: Int,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                                  _ options: Int8) -&gt; CGError</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">@_silgen_name("CGSSetHotKeyEnabled")</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">fileprivate func CGSSetHotKeyEnabled(_ connection: CGSConnectionID,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                                     _ hotKeyID: Int,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                                     _ enabled: Bool) -&gt; CGError</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">@_silgen_name("CGSIsHotKeyEnabled")</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">fileprivate func CGSIsHotKeyEnabled(_ connection: CGSConnectionID,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                                    _ hotKeyID: Int) -&gt; Bool</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">@_silgen_name("CGSRemoveHotKey")</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">fileprivate func CGSRemoveHotKey(_ connection: CGSConnectionID,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                                 _ hotKeyID: Int) -&gt; CGError</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This is a horrible terrible idea. But then again, you've read this much already, so you're probably okay with this sick twisted kind of stuff. :)  After elucidating the function arguments, we're using <code>@_silgen_name</code> to tell the Swift compiler that "hey, these functions exist somewhere, so just go along with my devious plans". Obviously, if anything goes wrong, you're on your own. Be careful with this block of code. </p><p>Now we'll register and unregister the shortcut where necessary, and add a way to enable or disable the shortcut (since <code>WindowServer</code> allows us this functionality).</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public var isEnabled: Bool {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    get { return CGSIsHotKeyEnabled(CGSMainConnectionID(), self.identifier.rawValue) }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    set { _ = CGSSetHotKeyEnabled(CGSMainConnectionID(), self.identifier.rawValue, newValue) }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public init(...) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    var error: CGError = .success</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    error = CGSSetHotKeyWithExclusion(CGSMainConnectionID(), self.identifier.rawValue,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                                      0xffff, self.keyCode, self.modifierFlags.rawValue,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                                      self.acquisitionPolicy == .none ? 0x0 : 0x1)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // If our acquisition policy can fallback, register non-exclusively.</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    if error == .noneAvailable &amp;&amp; self.acquisitionPolicy == .exclusivelyIfPossible {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        error = CGSSetHotKeyWithExclusion(CGSMainConnectionID(), self.identifier.rawValue,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                                          0xffff, self.keyCode, self.modifierFlags.rawValue, 0x0)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    guard error == .success else { throw error }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    error = CGSSetHotKeyType(CGSMainConnectionID(), self.identifier.rawValue, 0x1)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    guard error == .success else { throw error }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public func invalidate() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    _ = CGSRemoveHotKey(CGSMainConnectionID(), self.identifier.rawValue)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="local-event-handling">Local Event Handling<a href="#local-event-handling" class="hash-link" aria-label="Direct link to Local Event Handling" title="Direct link to Local Event Handling">​</a></h3><p>Alright, now we've got a functioning shortcut right? Not yet! We actually need to get <code>WindowServer</code> to send <strong>us</strong> specifically the event for the shortcut! However, (it turns out, in macOS 6+) <code>NSApplication</code> actually handles these kinds of events in <code>-sendEvent:</code>, but we need to register an event monitor to be notified of them. Let's use a local <code>NSEvent</code> monitor to trampoline notifications into <code>NotificationCenter</code>.</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">public static let pressedNotification = Notification.Name("CGSKeyboardShortcut.pressedNotification")</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public static let releasedNotification = Notification.Name("CGSKeyboardShortcut.releasedNotification")</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">private static var monitor = NSEvent.addLocalMonitorForEvents(matching: .systemDefined) { event in</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    if [6, 9].contains(event.subtype.rawValue) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        CGSKeyboardShortcut.all.filter { $0.identifier.rawValue == event.data1 }.forEach { obj in</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            let name: Notification.Name = event.subtype.rawValue == 6</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                ? CGSKeyboardShortcut.pressedNotification /* 6 */</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                : CGSKeyboardShortcut.releasedNotification /* 9 */</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            NotificationCenter.default.post(name: name, object: obj)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        return nil // consumed</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return event</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public init(...) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    _ = CGSKeyboardShortcut.monitor // bootstrap!</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>All we've done here is grab the shortcut identifier from the <code>data1</code> field of the <code>.systemDefined</code> event if it's of <code>subtype</code> <code>6</code> or <code>9</code>, which are the <code>-keyDown:</code> and <code>-keyUp:</code> event subtypes, respectively. Once we've done so, and our facility registered the shortcut (that is, not Carbon or another CGS client), bounce the event into a notification. Be sure to "bootstrap" the event monitor in your <code>init</code>, otherwise it'll never be initialized and trampoline shortcut events.</p><p>Here, I've explicitly chosen to use <code>NotificationCenter</code> over a delegation or target-action/handler pattern, because it turns a single-producer (the user input) single-consumer (portions of our app) model into a single-producer multiple-consumer pattern. With a single shortcut registration, multiple components can share event information. If we wanted a shortcut to be exclusive to the app, but multiple components acted on it, we would either end up in a hairy mess or end up using <code>NotificationCenter</code> anyway. </p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="the-magic-within-registereventhotkey">The Magic Within <code>RegisterEventHotKey</code><a href="#the-magic-within-registereventhotkey" class="hash-link" aria-label="Direct link to the-magic-within-registereventhotkey" title="Direct link to the-magic-within-registereventhotkey">​</a></h3><p>Remember how earlier, I said <code>RegisterEventHotKey</code> was doing something interesting? It <code>malloc</code>'s what I'm dubbing a <code>HotButtonData</code> to hold hot key parameters (presumably) and uses its pointer as the hot key identifier! Holy carp, that's insanely bad practice! It is, however, an extremely intelligent alternative to our global <code>Set</code>. That was really it. I found it pretty interesting, and I'm not even really sure if that was developer-intended or a compiler optimization/mangling of some sort. :)</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="frozen-representations">Frozen Representations<a href="#frozen-representations" class="hash-link" aria-label="Direct link to Frozen Representations" title="Direct link to Frozen Representations">​</a></h3><p>While we've now built a complete and functional shortcut facility, we have no way of storing a shortcut in a non-live, or frozen, way. We could make our class <code>Codable</code>, our initializer is where shortcut registration occurs, and invoking a <code>Codable</code> initializer should not have any side effects. Instead, I've opted for a design that mirrors only the internal properties of the shortcut class but with no activity of its own, called <code>CGSKeyboardShortcut.Definition</code>. It's effectively a frozen version of a <code>CGSKeyboardShortcut</code>, and we can use this type to inform the client of our class that explicit initialization is required. While there may be better approaches to this problem, I feel that this solution separates the notion of a live shortcut and a frozen one pretty cleanly.</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">public struct Definition: Hashable, Codable {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public let identifier: CGSKeyboardShortcut.Identifier</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public let keyCode: CGKeyCode</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public let modifierFlags: CGEventFlags</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public let acquisitionPolicy: AcquisitionPolicy</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public init(identifier: CGSKeyboardShortcut.Identifier, keyCode: CGKeyCode, modifierFlags: CGEventFlags, acquisitionPolicy: AcquisitionPolicy) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.identifier = identifier</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.keyCode = keyCode</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.modifierFlags = modifierFlags</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.acquisitionPolicy = acquisitionPolicy</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public convenience init(definition: Definition) throws {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    try self.init(identifier: definition.identifier, keyCode: definition.keyCode,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                  modifierFlags: definition.modifierFlags,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                  acquisitionPolicy: definition.acquisitionPolicy)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public var definition: Definition {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return Definition(identifier: self.identifier, keyCode: self.keyCode,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                      modifierFlags: self.modifierFlags,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                      acquisitionPolicy: self.acquisitionPolicy)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="cgkeycode--cgeventflags-supplements">CGKeyCode &amp; CGEventFlags Supplements<a href="#cgkeycode--cgeventflags-supplements" class="hash-link" aria-label="Direct link to CGKeyCode &amp; CGEventFlags Supplements" title="Direct link to CGKeyCode &amp; CGEventFlags Supplements">​</a></h3><p>Finally, we're not out of the woods yet. There's a slight issue with registering a shortcut with any old <code>NSEvent</code>-provided modifier flags - only a few flag bits are allowed (the physical key modifer ones)! Modify the line in <code>init(...) { ... }</code> that reads <code>self.modifierFlags = modifierFlags</code> to <code>self.modifierFlags = modifierFlags.intersection(.maskShortcutFlags)</code>. We'll define a few extensions to <code>CGEventFlags</code> to support this, and to allow conversion between <code>NSEvent.ModifierFlags</code>. In addition, we'll conform <code>CGError</code> to <code>Error</code> since it's not already for some reason...</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">extension CGError: Error {}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">extension CGEventFlags: Hashable, Codable {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public var hashValue: Int { return self.rawValue.hashValue }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public extension CGEventFlags {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public init(_ flags: NSEvent.ModifierFlags) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.init(rawValue: UInt64(flags.rawValue))</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public static let maskDeviceIndependentFlags = CGEventFlags(rawValue: 0x00000000ffff0000)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public static let maskShortcutFlags = CGEventFlags(rawValue: 0x0000000000ff0000)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public static let maskUserFlags: CGEventFlags = [.maskCommand, .maskControl, .maskShift, .maskAlternate]</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public extension NSEvent.ModifierFlags {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public init(_ flags: CGEventFlags) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.init(rawValue: UInt(flags.rawValue))</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><hr><h2 class="anchor anchorWithStickyNavbar_LWe7" id="building-higher-order-recognizers">Building Higher-Order Recognizers<a href="#building-higher-order-recognizers" class="hash-link" aria-label="Direct link to Building Higher-Order Recognizers" title="Direct link to Building Higher-Order Recognizers">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="why">Why?<a href="#why" class="hash-link" aria-label="Direct link to Why?" title="Direct link to Why?">​</a></h3><p>Realistically, a developer could use the <code>CGSKeyboardShortcut</code> class as is and be perfectly fine! It does everything, after all, from maintaining the shortcut list, to trampolining events into notifications, and more. However, building "higher-order" facilities to handle complex interactions is well worth it, even if it means a little more code to accomplish the simple use-case (because remember, we're not removing the original facility, only building atop it). Let's define a <code>ShortcutRecognizer</code> protocol that takes two inputs: <code>keyDown</code> and <code>keyUp</code>, but does not provide a standard output. It'll be up to our implementing classes to do that.</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">public protocol ShortcutRecognizer: class {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    func keyDown()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    func keyUp()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>So what would handling a shortcut, the normal way, look like with this protocol?</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">public final class PressShortcutRecognizer: ShortcutRecognizer {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public let handler: () -&gt; ()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public init(_ handler: @escaping () -&gt; ()) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.handler = handler</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public func keyDown() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        /// ignored!</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public func keyUp() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.handler()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Ugh, that's like, 10 extra lines of code and another class to deal with! But that's not the point! We've written something that doesn't actually rely on <code>CGS</code> facilities or even our <code>CGSKeyboardShortcut</code> facility! We don't even need to use this for shortcuts! It can do anything! (Maybe limiting its scope is a good thing to do though...) </p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="how">How?<a href="#how" class="hash-link" aria-label="Direct link to How?" title="Direct link to How?">​</a></h3><p>Okay, but the whole point of a recognizer type was to be able to simplify complex interactions, so how about this, an action in my app requires the user to do this exact sequence:  <code>keyDown</code> -&gt; <code>keyUp</code> -&gt; <code>keyDown</code> within 1sec -&gt; <code>keyUp</code> after 2sec. </p><p>It'll be a <code>TapHoldShortcutRecognizer</code> with a variable hold duration:</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">public final class TapHoldShortcutRecognizer: ShortcutRecognizer {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    private var timeInterval = DispatchTimeInterval.seconds(0)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public let handler: () -&gt; ()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public init(for t: DispatchTimeInterval = .seconds(2), _ handler: @escaping () -&gt; ()) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.timeInterval = t</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.handler = handler</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public func keyDown() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public func keyUp() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Since we actually never need to handle the first <code>keyUp</code>, let's handle the double <code>keyDown</code> first, using a bool as well as a time marker, to maintain the inter-<code>keyDown</code> and hold durations. </p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">private var timeReference: CFAbsoluteTime = 0.0</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">private var inDoubleTap = false</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public func keyDown() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    defer { self.timeReference = CFAbsoluteTimeGetCurrent() }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    guard CFAbsoluteTimeGetCurrent() - self.timeReference &lt; 1.0 else { return } // double-tapped</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.inDoubleTap = true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    DispatchQueue.main.asyncAfter(deadline: .now() + self.timeInterval) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>We've put the time tracking in a <code>defer { ... }</code> statement because we want it execute only after the method has finished processing; it's just a marker of when we noticed the <code>keyDown</code>, after all. This way, our <code>guard</code> statement isn't affected either, and we can ignore the inter-<code>keyDown</code> interval. Notice that we're only using <code>DispatchTimeInterval</code> for the hold duration, to play nice with <code>DispatchQueue.asyncAfter(...)</code>. Once we enter the hold phase (that is, <code>keyDown</code> -&gt; <code>keyUp</code> -&gt; <code>keyDown</code> within 1sec -&gt; ...), we can defer to the <code>keyUp()</code> function.</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">// ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    DispatchQueue.main.asyncAfter(deadline: .now() + self.timeInterval) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        guard self.inDoubleTap else { return }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.inDoubleTap = false</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        DispatchQueue.main.async(execute: self.handler)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public func keyUp() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    guard self.inDoubleTap else { return }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.inDoubleTap = false</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    print("shortcut recognizer failed because hold duration was \(CFAbsoluteTimeGetCurrent() - self.timeReference)s")</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>For the hold phase, we essentially race the user input to our designated hold duration: if the user gets there first (pressing the shortcut before the hold duration is up), we unset the double tap flag and bail our handler execution. Our inter-<code>keyDown</code> phase waited on the user to fail to <code>keyUp</code> so it could invoke the handler when we reached our hold duration. Clever, but there's probably a design pattern or something for this.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="binding-to-a-cgskeyboardshortcut">Binding to a <code>CGSKeyboardShortcut</code><a href="#binding-to-a-cgskeyboardshortcut" class="hash-link" aria-label="Direct link to binding-to-a-cgskeyboardshortcut" title="Direct link to binding-to-a-cgskeyboardshortcut">​</a></h3><p>It's now pretty simple to create a binder between a recognizer and a <code>CGSKeyboardShortcut</code>, by just adding the recognizer as an observer of... two... notifications... that's a little bit unwieldy. Instead, we can add a convenience function to add observers for both notifications and then return a single disposable value. If that value is <code>deinit</code>'ed, both observers are invalidated and the recognizer is effectively unbound! It's pretty straightforward.</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">public extension ShortcutRecognizer {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public func bind(to shortcut: CGSKeyboardShortcut) -&gt; Any {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        let x = NotificationCenter.default.addObserver(forName: CGSKeyboardShortcut.pressedNotification, object: shortcut, queue: nil) { _ in</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            self.keyDown()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        let y = NotificationCenter.default.addObserver(forName: CGSKeyboardShortcut.releasedNotification, object: shortcut, queue: nil) { _ in</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            self.keyUp()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        return _Holder([x, y])</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">// Implementation Detail:</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">class _Holder {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    private let observers: [Any]</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public init(_ observers: [Any]) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.observers = observers</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="sample-usage">Sample Usage<a href="#sample-usage" class="hash-link" aria-label="Direct link to Sample Usage" title="Direct link to Sample Usage">​</a></h3><p>Complex user shortcut interaction becomes much cleaner now! Here's how we can use all of this together:</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">let hotkey = try CGSKeyboardShortcut(identifier: .myShortcut,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                                     keyCode: 0x7E,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                                     modifierFlags: [.maskCommand, .maskControl],</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                                     acquisitionPolicy: .exclusivelyIfPossible)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">let tracker = TapHoldShortcutRecognizer {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    _ = NSAlert(style: .informational, text: "Double tap and hold succeeded!").runModal()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">self.observer = tracker.bind(to: hotkey)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">// ... elsewhere ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public extension CGSKeyboardShortcut.Identifier {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public static let myShortcut = CGSKeyboardShortcut.Identifier(0xBAAAAAAD)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><em>(That <code>NSAlert</code> initializer is pretty easy to implement and is left as an exercise for the reader.)</em></p><p><img loading="lazy" alt="Sample Alert" src="/assets/images/shortcut-recognizer-action-f45fcc8970120ce12943725d24f79007.png" width="1064" height="526" class="img_ev3q"></p><hr><h2 class="anchor anchorWithStickyNavbar_LWe7" id="conclusion">Conclusion<a href="#conclusion" class="hash-link" aria-label="Direct link to Conclusion" title="Direct link to Conclusion">​</a></h2><p>In short, there are better ways to do keyboard shortcuts than to resign to Carbon. Unfortunately, for those targeting the Mac App Store, this has just been an exercise in futility. An alternate implementation of <code>CGSKeyboardShortcut</code> could probably just wrap <code>RegisterEventHotKey</code> but that's no fun is it? Might as well just use <code>MASShortcut</code> or something else and not deal with writing it yourself. </p><p>In the next episode, I'll be designing and developing a corresponding view to display and record keyboard shortcuts! If you have any questions, comments, or concerns, contact me on Twitter or Github @avaidyam!</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[The Secret Life of Core Animation]]></title>
        <id>https://aditya.vaidyam.me/blog/2018/02/22/</id>
        <link href="https://aditya.vaidyam.me/blog/2018/02/22/"/>
        <updated>2018-02-22T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Most developers know of Core Animation through its few key classes, such as CALayer and CAAnimation, and their subclasses. Very few need to venture past this realm to take advantage of this powerful framework. What's not very clear to most is how many faces the framework takes on; there are three: CoreAnimation, CoreAnimationCF, and the internal C++ CoreAnimation underpinnings.]]></summary>
        <content type="html"><![CDATA[<p>Most developers know of Core Animation through its few key classes, such as <code>CALayer</code> and <code>CAAnimation</code>, and their subclasses. Very few need to venture past this realm to take advantage of this powerful framework. What's not very clear to most is how many faces the framework takes on; there are three: <code>CoreAnimation</code>, <code>CoreAnimationCF</code>, and the internal C++ CoreAnimation underpinnings. </p><p>All three are contained within the single <code>QuartzCore.framework</code> - I've managed to recreate a majority (if not all) the private headers for the first two (C++ is a lot harder unfortunately), and I suggest the reader <a href="https://github.com/avaidyam/QuartzInternal" target="_blank" rel="noopener noreferrer">take a peek at them first over here.</a> For the third facet, I've produced a list of some, but not all, <a href="https://github.com/avaidyam/QuartzInternal/wiki/Private-CoreAnimation-CPP-Packages" target="_blank" rel="noopener noreferrer">the packages (namespaces) being used</a>, and I suggest the reader take a look at those as well.</p><p>Let's start with the first one: the "normal" <code>CoreAnimation</code> - the one that runs atop Objective-C and is the only publicly marked API for any App Store apps. The easiest way to begin using it is to link AppKit or UIKit and <code>NSView</code> or <code>UIView</code> will take care of the rest for you. You just need to interface your view's layer, animate properties as needed, and so on. There is one small indexing trick used internally called <code>CAAtom</code> --  using <code>CAAtomGetString</code> and <code>CAInternAtom</code>, you can convert between a key path (string) and an indexed id used internally. In addition to atoms, the <code>CAObject_*</code> family of functions (<code>attributesForKey/Path</code>, <code>valueForKey/Path</code>, <code>setValueForKey/Path</code>, <code>initWithCoder</code>, <code>encodeWithCoder/CAMLWriter</code>, etc) are used within <code>CALayer</code> and friends to keep track of arbitrary values for arbitrary keys. This is why you're able to set any layer keyPath and it won't throw a <code>valueForUndefinedKey:</code> exception. Past this, there's not much else to see here that isn't public.</p><p>The interesting stuff starts with <code>CoreAnimationCF</code>: it's a barebones version of the above API... all in pure C using the <code>CoreFoundation</code> library only. You've got contexts, layers, rendering, and animations. If you haven't already, take a look at the source code above. Why does this exist at all? Because Core Animation actually is cross-platform (along a few other Apple libraries, including Core Graphics)! WebKit and iTunes, for example, have existing DLLs for all of these frameworks, but since they don't rely on Objective-C, they use the CF flavor of this API. Should a macOS/iOS developer be using this API? Really, probably not - there's nothing you can't do in the normal API that <code>CoreAnimationCF</code> will help you with. You'll also notice, some API are missing, like <code>CATransaction</code>.</p><p>The final facet is the most interesting, and is pretty much a mystery to me (and remains undocumented by anyone else, AFAIK) -- the C++ API. Through one ObjC protocol (<code>CARenderValue</code>), all of the ObjC API (that is, the first facet) can be translated into the C++ API by calling <code>CA_copyRenderValue</code>). If you haven't already, take a look at the list of packages above, because you'll notice some striking similarities. My cursory understanding of this API is that, the render server (be it a background thread or a separate process) copies the context and its layer tree's render values and can encode/decode them privately, relieving the ObjC/developer-facing API of any misuse or unexpected results. All of the <code>CA::Render::</code> packages/classes correspond to an ObjC layer or animation class, and once packaged up and sent over, the render server would directly manipulate these entities using the <code>CA::OGL::</code> packages/classes via a <code>SW</code> (software) renderer, <code>OGL</code> (OpenGL), or <code>Metal</code> renderer (which is likely used on all Apple platforms). In the middle, however, is <code>CA::CG::</code>, which looks like a lot of drawing routines that resemble Core Graphics (that is, <code>CGContext</code>)...</p><p>The way <code>CGContext</code> works, is that it has an internal <code>CGGState</code> stack, and a current <code>GState</code> (top of the stack), that all its clients set and manipulate via draw calls, but under the hood, <code>CGContextDelegate</code> translates these calls into a specific surface. <code>CGSWindow</code> has a <code>CGContextWindowDelegate</code> that when a <code>NSWindow</code>s (or their non-layer-backed views) need to draw, is passed as the delegate to <code>CGWindowContextCreate</code> and handles this translation layer. Similarly, a <code>CALayer</code> likely creates its context using the <code>CA::CG::</code> packages as a delegate, allowing the draw calls and GState modifications to map into whatever renderer is being currently used. </p><p>Finally, there's one thing about both the internal C++ and public ObjC API that not many folks have documented or picked up on: <code>CATransaction</code>'s commit handlers and <code>CAContext</code>. Every process that needs to work with a layer (or more) requires at least one <code>CAContext</code> - this is where the root layer is hosted. You can create additional contexts, remote, or local, to allow hosting your layers in another process (a la Safari tabs). The context supports the notion of <code>slot</code>s and <code>fence</code>s: I presume slots are a way to pass context-related objects around remote contexts, but haven't tested the theory. Fences, however, can be used to delay the host app's transaction commit cycle until the client app (the one serving a remote layer) is done with its commit - essentially, it's used to synchronize rendered frames, and a fence has a natural timeout of about one second (so the remote layer server should finish its commit within this time). This ties into transaction phases: there are a few points in a <code>CATransaction</code> that you can inject a handler: pre-layout, pre-commit, and post-commit. Combining fences with commit handlers, you can correctly synchronize remote rendered layers.</p><p>Some readers may arrive at a question here: if layers require a context, how does the context get rendered? I'm not too sure. I know there's a way to initialize a local render server and a way to hook into a remote render server (that is, on macOS, <code>windowserver</code>), but I don't know how the contextId makes its way over or how the two link up. However, if you're creating a <code>CGSWindow</code>, the fast way to get a <code>CALayer</code> on-screen is to create a <code>CGSSurface</code> and bind a <code>CAView</code> to it. The header for <code>CAView</code> is incomplete, but it looks trivial to work with, as it then manages the surface for you.</p><p>So, in conclusion, there are three different facets of the Core Animation API, intricate links to Core Graphics, via <code>CGContextDelegate</code>, and some kind of <code>CARender</code> and <code>CAContext</code> song-and-dance that allows a layer to be presented on-screen or in a buffer somewhere. I hope that demystifies a lot of the private API here for you. Drop me a line on Twitter if you think anything is incorrect or needs explaining!</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CAStateController & Friends]]></title>
        <id>https://aditya.vaidyam.me/blog/2018/02/19/</id>
        <link href="https://aditya.vaidyam.me/blog/2018/02/19/"/>
        <updated>2018-02-19T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[CALayer has internal/private support for two pretty cool things: archives and states. We'll talk about states first, as they're the more complex part of the exercise.]]></summary>
        <content type="html"><![CDATA[<p><code>CALayer</code> has internal/private support for two pretty cool things: archives and states. We'll talk about states first, as they're the more complex part of the exercise. </p><p>A <code>CALayer</code> can have any number of <code>states</code> which are <code>CAState</code> objects containing a number of <code>CAStateElement</code>s. The elements configure the state, and can <code>target</code> any sublayer of the root layer, and any <code>keyPath</code> on <code>CALayer</code>. It looks like it can also have a <code>source</code> (which is a <code>CAStateElement</code> itself) but I'm not sure what that specifically means. A state can also be <code>basedOn</code> another <code>CAState</code>, presumably one that preceeds it in the state diagram of the layer; an <code>initial</code> state is one that a layer can start off with (and doesn't need a <code>name</code> to uniquely identify it). On top of that, a <code>CALayer</code> may also have a number of <code>stateTransitions</code> which are <code>CAStateTransition</code> objects (containing <code>CAStateTransitionElement</code>s). The typical use case will be to create elements with a <code>target</code> and an <code>animation</code> representing the <code>keyPath</code> that needs to be animated between the two states. Be sure to set the <code>toState</code> and <code>fromState</code> on your transition to match the unique state <code>name</code>s from earlier. If you use the string <code>"*"</code>, I believe it refers to any possible state. Here's a code sample:</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">let s1 = CAState()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">s1.name = "inactive"</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">s1.isInitial = true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">let e1 = CAStateSetValue()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">e1.keyPath = "backgroundColor"</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">e1.value = NSColor.red.cgColor</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">e1.target = layer</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">s1.addElement(e1)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">let s2 = CAState()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">s2.name = "active"</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">let e2 = CAStateSetValue()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">e2.keyPath = "backgroundColor"</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">e2.value = NSColor.blue.cgColor</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">e2.target = layer</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">s2.addElement(e2)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">let t1 = CAStateTransition()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">t1.fromState = "*"</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">t1.toState = "active"</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">let e3 = CAStateTransitionElement()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">e3.key = "backgroundColor"</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">e3.animation = CABasicAnimation(keyPath: "backgroundColor")</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">e3.target = layer</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">e3.isEnabled = true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">e3.duration = 2.0</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">t1.elements = [e3]</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">let t2 = CAStateTransition()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">t1.fromState = "*"</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">t1.toState = "inactive"</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">let e4 = CAStateTransitionElement()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">e4.key = "backgroundColor"</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">e4.animation = CABasicAnimation(keyPath: "backgroundColor")</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">e4.target = layer</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">e4.isEnabled = true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">e4.duration = 2.0</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">t2.elements = [e4]</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">let t3 = CAStateTransition()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">t3.fromState = "inactive"</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">t3.toState = "active"</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">let e5 = CAStateTransitionElement()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">e5.key = "backgroundColor"</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">e5.animation = CABasicAnimation(keyPath: "backgroundColor")</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">e5.target = layer</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">e5.isEnabled = true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">e5.duration = 2.0</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">t3.elements = [e5]</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">let t4 = CAStateTransition()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">t4.fromState = "active"</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">t4.toState = "inactive"</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">let e6 = CAStateTransitionElement()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">e6.key = "backgroundColor"</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">e6.animation = CABasicAnimation(keyPath: "backgroundColor")</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">e6.target = layer</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">e6.isEnabled = true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">e6.duration = 2.0</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">t4.elements = [e6]</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">layer.states = [s1, s2]</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">layer.stateTransitions = [t1, t2, t3, t4]</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">DispatchQueue.main.asyncAfter(deadline: .now() + .seconds(1)) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.ctrl = CAStateController(layer: layer)!</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.ctrl.setInitialStatesOfLayer(layer, transitionSpeed: 0.5)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    DispatchQueue.main.asyncAfter(deadline: .now() + .seconds(1)) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.ctrl.setState(s2, ofLayer: layer, transitionSpeed: 0.5)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>To actually apply and modify states on a layer, you'll want to create a <code>CAStateController</code>. It's simple to use, as you initially call <code>setInitialStatesOfLayer(_:)</code>  and to change a state, call <code>setState(ofLayer:)</code>. If you include the <code>transitionSpeed</code> argument, it'll set a duration for any possible transitions to occur (independently of the duration of its <code>element</code>s).</p><p>I don't recommend using <code>CAStateController</code> and <code>CAState</code> without having written a good CoreAnimation "Interface Builder" to help you design states and layers correctly. Since Apple likely has this tool and we don't, it's probably why the API is private at the moment. A first step towards this, however, is to use <code>CAML</code> packages correctly. There is a <code>CAPackage</code> class to aid in all of this, but we'll use <code>CAMLWriter</code> and <code>CAMLParser</code> instead, which mirror <code>NSKeyedArchiver</code> and <code>NSKeyedUnarchiver</code>, but serialize into a "core animation archive" (caar) which uses a different XML format. Here's a code sample:</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">// Write:</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">let data = NSMutableData()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">let writer = CAMLWriter(data: data)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">writer?.encode(layer)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">// Read:</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">let parser = CAMLParser()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">_ = parser.parseData(data as Data)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">let layer2 = parser.result as! CALayer</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Pretty simple right!? Now the challenge is to build an interface designer to model <code>CALayer</code>s and <code>CAState</code>s. Encode it into a <code>caml</code> file and decode it at runtime, and you're all set. Use a <code>CAPackage</code> to neatly wrap the loading logic -- check out <code>AVMicaPackage</code> in AVKit, some of the packages in DictationServices (within PrivateFrameworks/SpeechObjects), or PassKitUIFoundation.</p><p>Regarding <code>CAState</code>, I'm still not sure what <code>CAState.locked</code>, <code>CAStateElement.source</code>, <code>CAStateControllerLayer</code> (which isn't even a <code>CALayer</code> subclass??) or <code>CAStateControllerUndo</code> (and related <code>undoStack</code>) do. I'll investigate those but if anyone has any idea, drop me a line and let me know!</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CAPortalLayer]]></title>
        <id>https://aditya.vaidyam.me/blog/2018/02/18/</id>
        <link href="https://aditya.vaidyam.me/blog/2018/02/18/"/>
        <updated>2018-02-18T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[In the macOS 10.13.4 beta, I spotted a new CALayer class called CAPortalLayer being used in AppKit, and apparently also in UIKit. After looking into it a bit more, it turns out it does exactly what CAPluginLayer did for CGSWindow/NSWindow but for CALayers!]]></summary>
        <content type="html"><![CDATA[<p>In the macOS 10.13.4 beta, I spotted a new <code>CALayer</code> class called <code>CAPortalLayer</code> being used in AppKit, and apparently also in UIKit. After looking into it a bit more, it turns out it does exactly what <code>CAPluginLayer</code> did for <code>CGSWindow</code>/<code>NSWindow</code> but for <code>CALayer</code>s! </p><p>I've neglected to provide a screenshot because it really doesn't look like much (it does update in realtime though).</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">let layer = CAPortalLayer()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">layer.frame = CGRect(x: 10, y: 10, width: 200, height: 200)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">layer.sourceLayer = self.view.layer!</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">//layer.sourceContextId = 0</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">//layer.sourceLayerRenderId = 0</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">layer.hidesSourceLayer = false // try out true as well!</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">//layer.matchesOpacity = true // apparently always true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">//layer.matchesPosition = false // apparently always true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">//layer.matchesTransform = true // apparently always true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">self.parentView.layer?.addSublayer(layer)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Notice in the code sample, all we needed to do was set <code>sourceLayer</code> to an existing valid layer and it worked! There are two more interesting properties here as well: <code>sourceLayerRenderId</code> and <code>sourceContextId</code> -- it appears that you must set <code>sourceLayerRenderId</code> for <code>sourceContextId</code> to matter to the render server (backboardd on iOS and windowserver on macOS). What these properties allow you to do is "portal" a layer from <strong>any process whose context you know of</strong> - just like with <code>CAPluginLayer</code>.  Just send the <code>CAContext.contextId</code> over the wire from a friendly process and it'll render. Unlike <code>CALayerHost</code> et al. however, the originating layer will <strong>also</strong> render on-screen (unless <code>hidesSourceLayer</code> is <code>true</code>). How do you get the <code>sourceLayerRenderId</code> you might ask? Here's the function prototype: <code>NSUInteger CALayerGetRenderId(CALayer *);</code> -- it won't be hard.</p><p>P.S. I originally tested this on iOS using the private <code>_UIPortalView</code> class. On macOS, AppKit has <code>NSPortalView</code> as well as <code>NSPortalView1</code> and <code>NSPortalView2</code> for some weird reason.</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CAPluginLayer & CABackdropLayer]]></title>
        <id>https://aditya.vaidyam.me/blog/2018/02/17/</id>
        <link href="https://aditya.vaidyam.me/blog/2018/02/17/"/>
        <updated>2018-02-17T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[There's a lot of cool CoreAnimation goodies hiding around in the private headers, but there are three private CALayer classes that really caught my eye: CAProxyLayer, CALayerHost, CABackdropLayer, and CAPluginLayer. CALayerHost is similar in design to CARemoteLayerClient/Server, so I'll be writing about both of these classes in a later post. I experimented with CAProxyLayer a little bit, as it's used for visual effects (think NS/UIVisualEffectView) and either I didn't know the right constants or wasn't using it correctly, but I couldn't get it to work reliably without nuking windowserver. I'll talk about the remaining two, using code samples.]]></summary>
        <content type="html"><![CDATA[<p>There's a lot of cool CoreAnimation goodies hiding around in the private headers, but there are three private <code>CALayer</code> classes that really caught my eye: <code>CAProxyLayer</code>, <code>CALayerHost</code>, <code>CABackdropLayer</code>, and <code>CAPluginLayer</code>. <code>CALayerHost</code> is similar in design to <code>CARemoteLayerClient/Server</code>, so I'll be writing about both of these classes in a later post. I experimented with <code>CAProxyLayer</code> a little bit, as it's used for visual effects (think <code>NS/UIVisualEffectView</code>) and either I didn't know the right constants or wasn't using it correctly, but I couldn't get it to work reliably without nuking <code>windowserver</code>. I'll talk about the remaining two, using code samples.</p><h1>CAPluginLayer</h1><p>This one is pretty weirdly named, but it looks like it was designed to support <code>windowserver</code> plugins - there's even a vtable, but as of right now, only <code>com.apple.WindowServer.CGSWindow</code> is supported. Here's a code sample:</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">let layer = CAPluginLayer()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">layer.frame = CGRect(x: 50, y: 50, width: 200, height: 200)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">layer.pluginType = "com.apple.WindowServer.CGSWindow"</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">layer.pluginId = UInt64(self.window.windowNumber)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">layer.pluginGravity = kCAGravityResizeAspect</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">//layer.pluginFlags = 0x4 // display without a shadow</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><img loading="lazy" alt="CAPluginLayer Sample" src="/assets/images/plugin-layer-77d31175df5417747ea3d2742aa1c7ae.png" width="2158" height="1672" class="img_ev3q"></p><p>So the big takeaway is, right now you can only use <code>CAPluginLayer</code> to mirror a window in real time (all its UI changes and interactions are reflected in the layer contents). You can set a <code>pluginGravity</code> similarly to <code>contentsGravity</code>, and the only known <code>pluginFlags</code> value is <code>0x4</code>, used by Dock to display the window without a shadow. </p><p>The <code>pluginId</code> actually refers to the <code>windowNumber</code> (or <code>_realWindowNumber</code> depending on your window type, but that's usually not a concern) and actually can be *<em>any window available on screen!</em> That's right - you can mirror any window, not just your own app's windows. For fun, I used <code>CGWindowListCopyWindowInfo</code> to grab the frontmost window (that wasn't my own app's) and used that id to mirror it into my app's layer. One might conclude at this point that it's a huge security violation if I can see the contents of ANY application's windows, but that's not the case. Using the Xcode UI hierarchy capture tool, you won't be able to see anything inside the layer, and this is because <code>CAPluginLayer</code> renders within the <code>windowserver</code> (and thus requires <code>layerUsesCoreImageFilters</code> to be <code>false</code>).  </p><p>The Dock uses this to display minimized windows and AppKit uses it to manage the toolbar in full-screen window transitions (in which the toolbar and titlebar are actually moved into a new window anchored to the screen's menubar). In your own app, supposing you're using a long-running XPC daemon for something already, you could request the daemon to help you animate your windows seamlessly if you didn't want to use <code>CGSWindow*</code> functions or make a fake window screenshot layer and animate that instead. You would send your window's <code>windowNumber</code> over to the daemon which would use a screen-sized <code>NSWindow</code> with a <code>CAPluginLayer</code> inside (be sure to set <code>pluginFlags</code> to <code>0x0</code>!) and animate that layer. There's a lot of things wrong with this approach, but it's fun to try it out!</p><h1>CABackdropLayer</h1><p>The <code>CABackdropLayer</code> is used to display layer blending on iOS (<code>UIVisualEffectView</code>) and within-window-only layer blending on macOS (<code>NSVisualEffectView</code>). Here's a code sample:</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">let layer = CABackdropLayer()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">layer.frame = CGRect(x: 0, y: 0, width: 200, height: 200)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">layer.allowsHitTesting = true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">layer.groupName = "group_name_here"</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">layer.windowServerAware = true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">let blur = CAFilter(type: kCAFilterGaussianBlur)!</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">blur.setValue(true, forKey: "inputNormalizeEdges")</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">blur.setValue(30.0, forKey: "inputRadius")</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">let saturate = CAFilter(type: kCAFilterColorSaturate)!</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">saturate.setValue(1.8, forKey: "inputAmount")</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">layer.filters = [blur, saturate]</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">layer.name = "backdrop"</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">layer.scale = 0.25</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">layer.bleedAmount = 0.2</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><img loading="lazy" alt="CABackdropLayer Sample" src="/assets/images/backdrop-layer-7def2425d4606ff367f933a2c8632fc3.png" width="512" height="466" class="img_ev3q"></p><p>When using <code>CABackdropLayer</code>, be sure to set <code>windowServerAware</code> to <code>true</code>, and set <code>layerUsesCoreImageFilters</code> on its parent view to <code>false</code>, otherwise the effect won't work (as it's also rendered in <code>windowserver</code>). Any combination of <code>CAFilter</code>s will work on the <code>CABackdropLayer</code>, as none that I've tried have failed me yet, but in the code sample, I've replicated the macOS Sierra saturated vibrant light appearance (as close as possible). The <code>scale</code> is important to set as I believe it's the sampling size of the underlying contents, and setting it to <code>2.0</code> made rendering quite slow. I'm also not sure why, but <code>groupName</code> is always set on a backdrop layer and it's always unique. It has something to do with <code>windowserver</code> rendering as there is a property to make it a "globally unique" name. </p><p>I would recommend against using <code>CABackdropLayer</code> over <code>NSVisualEffectView</code> as there are a lot of edge cases that aren't correctly handled unless using the AppKit class, but for an educational exercise or a venture into the wilderness with some interesting filter combinations (maybe <code>vibrantDark</code> just isn't doing it for you?) it could yield some great blending effects.</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ViewBridge.framework: It works!]]></title>
        <id>https://aditya.vaidyam.me/blog/2017/10/01/</id>
        <link href="https://aditya.vaidyam.me/blog/2017/10/01/"/>
        <updated>2017-10-01T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Around two years ago I began looking into ViewBridge.framework and a bunch of related frameworks as a side-project, mostly for fun. Realizing I had figured out most of it but just hadn’t put it together, I assembled a quick demo project that worked almost instantly with ViewBridge. All I had to do was create an XPC service, add a few Info.plist keys, grab the headers (I cleaned a few up) and I was on the road.]]></summary>
        <content type="html"><![CDATA[<p>Around two years ago I began looking into ViewBridge.framework and a bunch of related frameworks as a side-project, mostly for fun. Realizing I had figured out most of it but just hadn’t put it together, I assembled a quick demo project that worked almost instantly with ViewBridge. All I had to do was create an XPC service, add a few Info.plist keys, grab the headers (I cleaned a few up) and I was on the road. </p><p><a href="https://github.com/avaidyam/RemoteViewHost" target="_blank" rel="noopener noreferrer">You can see the results here.</a>
Put simply, it works, and it works great. There are a few event handling blips, but it does the job and loads the service view in less than 300ms on my machine. The next step for me will be to create a new branch in which I define my own NSExtensionSDK with the NSViewService_PKSubsystem and make it all “extensible” like Today Widgets are. I would have had that working, but pkd refuses to learn my NSExtensionSDK for some reason.</p><p><img loading="lazy" src="https://raw.githubusercontent.com/avaidyam/RemoteViewHost/master/Sample.png" alt="Sample" class="img_ev3q"></p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Picture-in-Picture on macOS Sierra]]></title>
        <id>https://aditya.vaidyam.me/blog/2016/08/05/</id>
        <link href="https://aditya.vaidyam.me/blog/2016/08/05/"/>
        <updated>2016-08-05T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Similar to iOS, macOS recently gained Picture-In-Picture mode for videos; so far, only Safari seems to support it out of the box. The question remains: why isn’t it a public API? That’s a question we’ll never have an answer for, but as it turns out, PIP.framework does exist in the PrivateFrameworks realm, and a quick job of reverse engineering shows exactly how it works.]]></summary>
        <content type="html"><![CDATA[<p>Similar to iOS, macOS recently gained Picture-In-Picture mode for videos; so far, only Safari seems to support it out of the box. The question remains: why isn’t it a public API? That’s a question we’ll never have an answer for, but as it turns out, PIP.framework does exist in the PrivateFrameworks realm, and a quick job of reverse engineering shows exactly how it works.</p><p>PIPViewController is the entry point for the framework, which allows configuration of a single view in PIP mode; when presentViewControllerAsPictureInPicture is called with any view controller, it animates the view out into a PIPPanel. The PIPPanel actually registers and operates inside of NotificationCenter, allowing notifications to display around it. Surprisingly, that’s really all there is to it. PIPViewController tacks on three buttons (play/pause, close, return) and allows delegates to track things.
A picture is worth a thousand words (see what I did there), so I’ve put together a quick SPI sample of how to actually use the framework over <a href="https://github.com/avaidyam/PIP-Demo/" target="_blank" rel="noopener noreferrer">here</a>!</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[NSExtension  & PlugInKit]]></title>
        <id>https://aditya.vaidyam.me/blog/2016/07/12/</id>
        <link href="https://aditya.vaidyam.me/blog/2016/07/12/"/>
        <updated>2016-07-12T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Recently I’ve been doing a lot of reverse engineering in the PrivateFrameworks department, simply out of curiosity. One thing that really always bothered me was how to insert a view hierarchy across processes — and I was interested in seeing how Apple had done it. A few frameworks of note the NSXPCConnection API, which internally wraps the libxpc.dylib library, found in /usr/lib/system.]]></summary>
        <content type="html"><![CDATA[<p>Recently I’ve been doing a lot of reverse engineering in the <code>PrivateFrameworks</code> department, simply out of curiosity. One thing that really always bothered me was how to insert a view hierarchy across processes — and I was interested in seeing how Apple had done it. A few frameworks of note: <code>ViewBridge.framework</code>, <code>PlugInKit.framework</code>, <code>LaunchServices.framework</code>, and finally, <code>libextension.dylib</code>. The last one is a bit weird because it’s actually a high level Objective-C framework that’s tied into <code>AppKit</code> — but for some reason has been relegated to <code>/usr/lib</code> (but is now located in <code>Foundation.framework</code> in macOS Sierra). All of the frameworks above use a common transmission medium: the <code>NSXPCConnection</code> API, which internally wraps the <code>libxpc.dylib</code> library, found in <code>/usr/lib/system</code>.</p><p>With the introductions out of the way, I took a quick look into <code>ViewBridge.framework</code>, and realized it was the wrong place to start. I had to start off a little bit lower, down in <code>PlugInKit.framework</code> and <code>libextension.dylib</code>. In my understanding, the <code>PlugInKit</code> serves as generic plugin subsystem hub framework which an app can hook into with a custom subsystem and set of protocols of some sort and start using. The <code>FxPlug</code> API for writing Final Cut Pro plugins seems to be based atop <code>PlugInKit</code>, along with many others, but modern macOS (Yosemite and beyond) extensions use the newer <code>NSExtension</code> API, which is a subsystem to the former framework. In addition, <code>ViewBridge</code> framework is also a subsystem to the former framework by tying in <code>NSViewController</code>s. An <code>NSViewController</code> can be discovered as an extension and then vend its view through the <code>ViewBridge.framework</code> into a host application.</p><h1><code>PlugInKit</code> and <code>LaunchServices</code></h1><p><code>PlugInKit</code>’s life begins with plugin discovery — if you take a look at Console and search for “pkd”, you’ll see a lot of interesting things going on related to extension installation. This is really just <code>LaunchServices</code>’ private API with a little sprinkles on top. <code>LSApplicationWorkspace</code> seems to be <code>NSWorkspace</code>’s older and more mature cousin, able to query for applications anywhere on disk with certain properties (like settings bundles on iOS, audio components, VPN plugins, user activity handlers, and URL schemes). In addition, it also allows registering for notifications (<code>LSApplicationWorkspaceObserver</code>) when an application is installed (which I assume really means copied and then opened at least once). It allows un/installing applications, opening URLs, and most importantly grabbing plugins from applications. The <code>LSBundleProxy</code> and its subclasses provide detailed information (mostly through <code>Info.plist</code> hunting) about bundles, applications, resources, plugins, and more. In addition, there is a pluginkit tool that allows system-level control of plugins.</p><p>Essentially, when an application is installed, pkd picks it up and detects all sorts of metadata within it, including any plugins or extensions it may have. From there, things begin to diverge: <code>PlugInKit</code> relies on a conventional model of providing explicit protocol information and formal communication with a plugin; <code>NSExtension</code>, the new bees’ knees, relies on an informal “generic item” based communication model (as seen in <code>NSExtensionRequestHandling</code> for Safari Link extensions) and builds on top of <code>PlugInKit</code>. This allows the application to be really flexible with extension protocols.</p><h1>The NSExtension Host</h1><p>The NSExtension framework doesn’t have its own plugin discovery system; it uses PlugInKit for that. <code>+[NSExtension beginMatchingExtensionsWithAttributes:completion:]</code> internally calls through to <code>-[[PKHost defaultHost] continuouslyDiscoverPlugInsForAttributes:flags:found:]</code> with a discovery block. This block enumerates each <code>PKPlugIn</code> discovered and transforms them into <code>NSExtension</code>s by grabbing necessary properties, and holding a strong reference to them, as seen in <code>-[NSExtension _initWithPKPlugin:]</code>. When <code>+[NSExtension endMatchingExtensions:]</code> is invoked, it calls through to <code>-[[PKHost defaultHost] cancelPlugInDiscovery:]</code>. There’re a couple features I don’t fully understand here yet: <code>-[NSExtension attemptOptIn:]</code>, <code>-[NSExtension attemptOptOut:]</code>, and <code>-[NSExtension optedIn]</code>. All of these call into <code>-[PKPlugIn userElection]</code>, of which I’m not sure of the purpose.</p><p>So once you have all these extensions, how do you begin using them? <code>-[NSExtension beginExtensionRequestWithInputItems:completion:]</code>. What this really does is prepare an internal call on the “GlobalStateQueue” to <code>-[NSExtension _reallyBeginExtensionRequestWithInputItems:listenerEndpoint:completion:]</code>, I know, very imaginative name. In the process of this call as well as the matching one to end using the plugin, <code>-[NSExtension _safelyBeginUsing:]</code> and <code>-[NSExtension _safelyEndUsing:]</code> both call into <code>-[PKPlugIn beginUsing:]</code> and <code>-[PKPlugIn endUsing:]</code> to prepare anything needed.</p><p>Back to the main hero here: <code>_reallyBeginExtensionRequest…:</code> First, it sets up things where necessary (nil checks for extension contexts or service connection dictionaries), and then ensures to load “<code>NSExtensionContextHostClass</code>” if it exists in the extension’s Bundle’s Info.plist. It then invokes <code>-[NSExtensionContext initWithInputItems:]</code> with the <code>inputItems</code> passed in. It stores the extension data by the context’s UUID in the <code>NSExtension</code>’s dictionaries. After configuring the invalidation and interruption handlers on its <code>NSXPCConnection</code>, it invokes -resume and grabs the connection’s <code>remoteObjectProxy</code>. If it was able to obtain the object proxied (a <code>_NSExtensionContextVendor</code> object), it then sets it as the <code>NSExtensionContext</code>’s <code>extensionVendorProxy</code> (by invoking <code>-[NSExtensionContext _setExtensionVendorProxy:]</code>). If the <code>listenerEndpoint</code> passed in was nil, it assigns it as the value of <code>-[NSExtensionContext _auxiliaryListener]</code>’s endpoint.
And then we go down the rabbit hole of XPC by invoking <code>-[_NSExtensionContextVendor _beginRequestWithExtensionItems:listenerEndpoint:withContextUUID:completion:]</code>. It passes the context UUID to match with an <code>endRequest</code> call, so the <code>NSExtension</code> knows which <code>NSExtensionContext</code> was completed or invalidated. Of course, it also provides the listener endpoint, and the input items. If an error occurs at any stage, if the host cancels the request, or if the request completes successfully, everything is torn down by invoking <code>__NSExtensionTearDownRequestWithIdentifier</code>.</p><h1>The Rabbit Hole that is <code>PlugInKit</code></h1><p>Let’s take a step back and take a look at things from the extension vendor’s point of view first. If you begin a new app extension project, you might notice the lack of a main.c or <code>NSApplicationMain</code>. That’s because Xcode performs some magic linker voodoo (flag -e) to set the executable EntryPoint to <code>_NSExtensionMain</code>. When the extension host begins a connection to the extension, launchd actually executes the extension, where this function begins. Ideally, if you’ve worked with XPC helpers, what happens is the application invokes <code>-resume</code> on the <code>NSXPCListener</code>, preferably after setting its delegate to to accept any incoming connections. <code>NSExtensionMain</code> calls through to <code>+[PKService _defaultRun:arguments:]</code> which then calls through to <code>-[PKService run]</code> on the <code>+[PKService defaultService]</code>. What follows is pretty interesting: it reveals that <code>PlugInKit</code> was originally designed to service multiple SDKs in the Mavericks era, possibly initially servicing FxPlug only — the <code>PKService</code> instance then sets the <code>NSXPCListener</code>’s delegate and calls an interesting method <code>-[PKService discoverSubsystems]</code>. What it does is enumerate over <code>-[PKService configuredSubsystemsList]</code> which currently checks to see if the bundle’s Info.plist has an “<code>NSExtension</code>” or “<code>PlugInKit</code>” array — within <code>-[PKService mergeSubsystems:from:]</code>, it looks for the key “<code>NSExtensionPointIdentifier</code>”, and if it doesn’t exist, “SDK” (a Legacy term) and then invokes <code>+[PKPlugInCore readSDKDictionary:]</code> to retrieve the entire dictionary information.</p><p>Interestingly enough, there’s a function <code>_xpc_copy_extension_sdk_entry</code> that’s invoked here and there are references to looking for an “<code>NSExtensionSDK</code>” key somewhere. Upon taking a peek into <code>libxpc.dylib</code>, it’s easy to see that there are a couple provisional functions: <code>_xpc_connection_is_extension</code>, <code>_launch_extension_check_in_live_4UIKit</code>, and some more internal <code>_launch_extension*</code> functions. It’s a little unnerving to see that there’s so much framework bleed, to the point where it enters launchd, xpc, and two whole plugin oriented frameworks. Also, random sidenote: XPC has a number of painful functions to create an XPC object from a Plist file descriptor… which ultimately ends up parsing the binary format. :( Anyway, after a lot of processing of the SDK dictionaries, <code>PKService</code> checks for any Subsystems involved. One of interest being “<code>NSViewService_PKSubsystem</code>”, which pops up in <code>-[PKService _processDefaultSubsystemName:]</code>. Once the whole subsystem discovery ends, <code>PlugInKit</code> knows exactly what SDKs and subsystems it’ll be vending and I assume it knows their definitions for XPC communication as well. After this, it looks for a <code>PKServiceDelegate</code> (with the key “Delegate”) set in the <code>Info.plist</code>, and attaches it if it can. Once ALL of this is done, the <code>NSXPCListener</code> is resumed.</p><p>When a new connection attempts to connect, if it’s from the correct listener, it creates what is called an “<code>PKServicePersonality</code>” with that connection which configures the connection. It exports the <code>PKCorePlugInProtocol</code> protocol, and expects the remote interface to be a <code>PKCoreHostProtocol</code> (which is basically empty…). The idea is that a <code>PKService</code> may either have a number of personalities or a <code>solePersonality</code> (either the highest priority or the only personality). These objects encompass the plugin SDK and communications channel, and the service keys them according to the host <code>processIdentifier</code> (pid) of the NSXPCConnection. To register or unregister a <code>PKServicePersonality</code>, <code>-[PKService registerPersonality:]</code> and <code>-[PKService unregisterPersonality:]</code> both enqueue operations on the internal <code>_sync</code> <code>DispatchQueue</code>. <code>PKService</code> is also a little bit nifty in that it can be scheduled to terminate the XPC transaction using an internal <code>dispatch_source_timer</code> <code>terminationTimer</code>, which can also be cancelled later. <code>PKService</code> has a number of other useful functions too, such as getting a personality’s connection, defaults, <code>pluginPrincipal</code>, <code>hostPrincipal</code>, and <code>embeddedPrincipal</code>; all of these functions call-through to the <code>PKServicePersonality</code> with the appropriate name. In addition, it can also launch the containing application, if on the host’s side of things. Both <code>PKServicePersonality</code> and <code>PKHostPlugIn</code> are subclasses of <code>PKPlugInCore</code>, where most of the heavy lifting seems to happen.</p><p>When PKServicePersonality receives a <code>-[PKCorePlugInProtocol prepareUsing:reply:]</code> call, it caches the identifier, <code>hostProtocol</code>, version, and uuid. Of particular importance is the <code>hostProtocol</code> — once the personality invokes <code>-[PKServicePersonality setupWithIdentifier:]</code>, it tries to find the protocol if there is one using <code>_pkFindProtocol()</code>. Within that setup method, the personality first invokes <code>resolveSDK</code>, then <code>registerPersonality</code> with the <code>PKService</code>’s <code>defaultService</code>. In addition, it prepares a <code>PKServiceDefaults</code> for itself and calls <code>-[PKServicePersonality checkEnvironment:]</code>. There’s another “prepareUsing” call, <code>-[PKServicePersonality prepareUsingPlugIn:hostProtocol:reply:]</code>, but that appears to just call into the former method, and is designated as legacy. This is where things get interesting: the personality enumerates over all subsystems and invokes <code>-[PKModularService beginUsing:withBundle:]</code>. This essentially implies that all subsystems conform to <code>PKModularService</code>… and this checks out, as both NSExtension and NSViewService_PKSubsystem and do. When the <code>PKServicePersonality</code> receives a <code>-[PKCorePlugInProtocol shutdownPlugIn]</code> call, it basically does the opposite: it unregisters itself, invokes <code>-[PKModularService endUsing:]</code> on all of the service’s subsystems, and finally calls <code>-[PKService scheduleTermination:]</code> on the service. Side note: <code>PKCorePlugInProtocol</code> has two preferences methods which simply call down to the <code>PKServiceDefaults</code> for the personality.</p><blockquote><p>Well that was fun.  —  No one ever.</p><h1>Where are we really going with this?</h1></blockquote><p>Ultimately, the paragraphs above were just an interactive disassembly of what the system is really doing with extensions. We’ve learned a bit about how tightly integrated they are with the system, to the point where launchd and XPC are getting slightly involved (does no one know the meaning of separation of tasks?) and how <code>PlugInKit</code> uses <code>LaunchServices</code> through pkd to auto-magically register and unregister plugin bundles. From there, we went through the bootstrap procedure of PlugInKit on the vendor (plugin) side, and how <code>PlugInKit</code> is designed around modular services called subsystems. In fact, grab a copy of the system’s runtime headers and grep for <code>PKModularService</code> — there’s plenty of them. We also covered how <code>NSExtension</code> requests can be started and how they snake down the PlugInKit lifeline to reach the vendor. There’s so much more. In fact, this is quite literally the tip of the iceberg; I know there could be facts I may have gotten wrong about this whole shpeel, but it was a fun trip.</p><p>A fun side project would be to use the extension framework to allow your app to interface with plugins, or even create your own <code>PlugInKit</code> modular subsystem (which actually doesn’t seem to be that much of a challenge)! Or perhaps, use the ideas here on a smaller scale (<code>NSWorkspace</code> instead of <code>LaunchServices</code>, perhaps?) to create your very own <code>PlugInKit</code>! In reality, a clone might just be <code>Info.plist</code> checking and some XPC magic.</p>]]></content>
    </entry>
</feed>