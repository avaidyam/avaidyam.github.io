<!doctype html>
<html lang="en" dir="ltr" class="blog-wrapper blog-post-page plugin-blog plugin-id-default">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.21">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Aditya Vaidyam RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Aditya Vaidyam Atom Feed">
<link rel="alternate" type="application/json" href="/blog/feed.json" title="Aditya Vaidyam JSON Feed"><title data-rh="true">An Exercise in Modern Cocoa Views | Aditya Vaidyam</title><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://aditya.vaidyam.me//logo.png"><meta data-rh="true" name="twitter:image" content="https://aditya.vaidyam.me//logo.png"><meta data-rh="true" property="og:url" content="https://aditya.vaidyam.me//blog/2018/03/22/"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><meta data-rh="true" property="og:title" content="An Exercise in Modern Cocoa Views | Aditya Vaidyam"><meta data-rh="true" name="description" content="Like I said in the previous &quot;episode&quot;, recently, I&#x27;ve wanted to get around to adding &quot;hot key&quot; support for Parrot, and realized I didn&#x27;t like any of the existing solutions:"><meta data-rh="true" property="og:description" content="Like I said in the previous &quot;episode&quot;, recently, I&#x27;ve wanted to get around to adding &quot;hot key&quot; support for Parrot, and realized I didn&#x27;t like any of the existing solutions:"><meta data-rh="true" property="og:type" content="article"><meta data-rh="true" property="article:published_time" content="2018-03-22T00:00:00.000Z"><link data-rh="true" rel="icon" href="/photo.png"><link data-rh="true" rel="canonical" href="https://aditya.vaidyam.me//blog/2018/03/22/"><link data-rh="true" rel="alternate" href="https://aditya.vaidyam.me//blog/2018/03/22/" hreflang="en"><link data-rh="true" rel="alternate" href="https://aditya.vaidyam.me//blog/2018/03/22/" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.a02a6c90.css">
<link rel="preload" href="/assets/js/runtime~main.93e70d6f.js" as="script">
<link rel="preload" href="/assets/js/main.2cfa5855.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_fXgn">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><b class="navbar__title text--truncate">Aditya Vaidyam</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a aria-current="page" class="navbar__link active" aria-haspopup="true" aria-expanded="false" role="button" href="/">Contact</a><ul class="dropdown__menu"><li><a href="mailto:aditya@vaidyam.me" target="_blank" rel="noopener noreferrer" class="dropdown__link">Send an Email</a></li><li><a href="https://calendly.com/avaidyam/meet" target="_blank" rel="noopener noreferrer" class="dropdown__link">Schedule a Meeting</a></li></ul></div><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="Blog recent posts navigation"><div class="sidebarItemTitle_pO2u margin-bottom--md">All posts</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2019/06/02/">On the debate of iOS vs. macOS</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2019/02/19/">DIY: Core Animation</a></li><li class="sidebarItem__DBe"><a aria-current="page" class="sidebarItemLink_mo7H sidebarItemLinkActive_I1ZP" href="/blog/2018/03/22/">An Exercise in Modern Cocoa Views</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2018/03/16/">Building a Better RegisterEventHotKey</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2018/02/22/">The Secret Life of Core Animation</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2018/02/19/">CAStateController &amp; Friends</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2018/02/18/">CAPortalLayer</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2018/02/17/">CAPluginLayer &amp; CABackdropLayer</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2017/10/01/">ViewBridge.framework: It works!</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2016/08/05/">Picture-in-Picture on macOS Sierra</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2016/07/12/">NSExtension  &amp; PlugInKit</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h1 class="blogPostTitle_Ikge" itemprop="headline">An Exercise in Modern Cocoa Views</h1><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2018-03-22T00:00:00.000Z" itemprop="datePublished">March 22, 2018</time> · <!-- -->43 min read</div></header><div id="post-content" class="markdown" itemprop="articleBody"><p>Like I said in the previous &quot;episode&quot;, recently, I&#x27;ve wanted to get around to adding &quot;hot key&quot; support for Parrot, and realized I didn&#x27;t like any of the existing solutions:</p><ol><li>Use <code>MASShortcut</code> or <code>ShortcutRecorder</code> which are tried and proven to work in ObjC-land.</li><li>Use a new but not proven Swift hotkey recorder (there&#x27;s a few out there).</li><li>Roll my own (probably somehow using dangerous private SPI) and not test it at all! </li></ol><p><em>Obviously I went with option #3.</em> </p><p>And here we are now, onto part two of the thrilling saga in which you witness me breaking AppKit and WindowServer and inviting the wrath and fury of the engineers that work on said components. I hope you brought your popcorn. </p><p>I&#x27;d like to clarify that we&#x27;ll only be building a single self-contained control that manages a single shortcut. I expect Parrot, like most apps, will not need a Command Editor like Final Cut Pro, which is purpose-built for video editors with more than two keyboards and more than two hands to match, clearly.</p><p><img loading="lazy" alt="Final Cut Pro Command Editor" src="/assets/images/finalcut-keyboard-a42ab2a630db0d4127a3b1e7072d6545.jpg" width="1800" height="1220" class="img_ev3q"></p><p>Our end result will look, sound, and feel something like this, instead:</p><p><img loading="lazy" alt="KeyboardShortcutView" src="/assets/images/shortcut-recorder-b7f561211d859622dbfe5614b14170fc.gif" width="398" height="340" class="img_ev3q"></p><p>Before we get into the nitty gritty hand-holding pair-programming stuff, if you&#x27;d like to jump straight to the comment-annotated final source code, <a href="https://gist.github.com/avaidyam/32975976c23dd3b38336f22d971f5eaa" target="_blank" rel="noopener noreferrer">I&#x27;ve included a snapshot here.</a> It&#x27;s the whole final product, exactly 1500 LOC, including the code from the previous &quot;episode&quot; - the corresponding keyboard shortcut facility! If you think this should be a formal repository and whatnot, contact me on Twitter or Github @avaidyam!</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="principles-of-modern-views">Principles of Modern Views<a class="hash-link" href="#principles-of-modern-views" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="subclassing-a-view-or-a-viewcontroller">Subclassing a <code>View</code> or a <code>ViewController</code><a class="hash-link" href="#subclassing-a-view-or-a-viewcontroller" title="Direct link to heading">​</a></h3><p>The first question we should answer is, what kind of component are we building? The answer to this question is what determines what kind of a subclass we are, as well as the interaction model we have with other components in our app. </p><p>When you&#x27;re building a discrete component that takes a program input and presents a display to the user, and in the case of a control, receives user input and presents a program output, you should be subclassing a <code>View</code>. Anything beyond that should be a subclass of a <code>ViewController</code>, a component that mediates interactions between other components, or a component that handles model/database objects, or really just anything else. A <code>View</code> should be easily reusable in other contexts outside of the one you&#x27;re building in immediately, but a <code>ViewController</code> is not necessarily capable of fulfilling this contract. </p><p>For example, a contact avatar would best be a <code>View</code> subclass, but a contact avatar <strong>picker</strong> should be a <code>ViewController</code>, as it not only displays an avatar image, but it also allows the user to select an image, and might handle the synchronization with the contact store (maybe it&#x27;s a JSON file, maybe it&#x27;s a remote API, or maybe it&#x27;s a <code>CNContact</code>). </p><p>On macOS, you should also consider subclassing an <code>WindowController</code> if the component you&#x27;re building both composes other components (like a <code>ViewController</code>) and is self-contained in a <code>Window</code> -- a contact avatar picker may not fit this criteria, but a contact <strong>editor panel</strong> would, where the contact avatar picker would be a <code>ViewController</code> nested within, alongside name, phone, email, and other editable fields.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="layers">Layers<a class="hash-link" href="#layers" title="Direct link to heading">​</a></h3><p>While <code>AppKit</code> is often seen as a dinosaur compared to its younger sibling, <code>UIKit</code>, it&#x27;s important to know that nearly all the design patterns that <code>UIKit</code> sports came from <code>AppKit</code>, and if not, they eventually make their way back into <code>AppKit</code>, with the exception of a very limited few. For example, the concept of a <code>UIView</code> being backed by an underlying <code>CALayer</code> type is very similar to how <code>NSControl</code> is (rather, used to be?) backed by <code>NSCell</code>. The differences being that the <code>CALayer</code> is actually driving the rendering of display content instead of the <code>UIView</code>, and that <code>NSCell</code> acts as a &quot;rubber stamp&quot; for specific event handling and drawing. </p><p>When it comes to layer-backed views, <code>AppKit</code> actually has several modes by which to achieve this: </p><ol><li><strong>Layer-hosting:</strong> <ul><li><code>self.layer = CALayer(); self.wantsLayer = true</code></li><li>The <code>NSView</code> owns the <code>CALayer</code> and is responsible for creating and managing it; <code>NSView</code> does nothing except create its rendering surface.</li></ul></li><li><strong>Implicit Layer-backed and drawn:</strong> <ul><li><code>superview.wantsLayer = true</code></li><li>The <code>NSView</code> has an explicitly layer-backed parent and will grant itself a private <code>CALayer</code> to draw into, using the rendering surface of the layer-backed parent&#x27;s <code>CALayer</code>.</li></ul></li><li><strong>Implicit Superview Layer-drawn:</strong> <ul><li><code>superview.wantsLayer = true; superview.canDrawSubviewsIntoLayer = true</code></li><li><strong>If you expect to use animations or any layer-related properties, you must opt out of this!</strong></li><li>The <code>NSView</code> has an explicitly layer-backed parent whose <code>canDrawSubviewsIntoLayer</code> is true, and thus, will not grant itself a <code>CALayer</code>, and instead draw directly into the layer-backed parent&#x27;s <code>CALayer</code>. </li></ul></li><li><strong>Explicit Layer-backed and drawn:</strong> <ul><li><code>self.wantsLayer = true</code></li><li>The <code>NSView</code> has explicitly declared itself as layer-backed and will set its layer&#x27;s <code>contents</code> with the result of its <code>drawRect:</code> call (that is, drawing directly into the layer).</li><li>If this view declares that it <code>canDrawSubviewsIntoLayer</code>, its subviews are rendered into this view&#x27;s <code>layer</code>. </li></ul></li><li><strong>Explicit Layer-backed:</strong> <ul><li><code>self.wantsLayer = true; self.wantsUpdateLayer = true; self.layerContentsRedrawPolicy = .onSetNeedsDisplay</code></li><li><em>Note: you must actually override the <code>wantsUpdateLayer</code> function in your custom <code>NSView</code> subclass to achieve this, as there is no setter for the property. This property is queried at each view update cycle, if the view is marked dirty - don&#x27;t attempt any complex computations here.</em></li><li>The <code>NSView</code> has explicitly declared itself as layer-backed and that it will not <code>drawRect:</code> into the layer. Instead, the layer is manually managed, <strong>but not owned by the subview</strong>, during the <code>updateLayer</code> method.</li><li>It&#x27;s important to set <code>layerContentsRedrawPolicy</code> to <code>.onSetNeedsDisplay</code> here, since the <code>layer.contents</code> are no longer dependent on your <code>drawRect:</code>.</li></ul></li></ol><p><em>Note: where I say &quot;rendering surface&quot;, the underlying type is either a <code>CAContext</code>, which is used by the WindowServer to render your layers out-of-process, <strong>or</strong> by <code>CAViewRef</code> which can be thought of as a wrapper around `CA::Render::</em>`, which is rendered in-process but likely off the main thread.*</p><p>Personally, I think the <code>NSView.layer</code> property should never have been public; instead, if layer-hosting, it&#x27;s the view&#x27;s responsibility to keep a strong reference to its layer, and in explicit <code>updateLayer</code> views, the <code>updateLayer</code> method signature should have been <code>- (void)updateLayer:(CALayer *)layer</code>, so as to pass in the <code>AppKit</code>-owned layer for the view to update. Too many iOS developers mistake <code>NSView</code> for being identical to <code>UIView</code>, where it&#x27;s almost even orthogonal to it depending on the scenario. <code>UIView</code>&#x27;s layer ownership model is most closely represented by layer-hosting, but in AppKit, this means layer hierarchies and other view facilities are not managed for you, and so, the closest to it would be explicit layer-backed. This is the approach we&#x27;ll be taking. It may appear that you won&#x27;t be able to use <code>drawRect:</code>, but there are ways to work around that, as we&#x27;ll see soon.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="nscontrol"><code>NSControl</code>?<a class="hash-link" href="#nscontrol" title="Direct link to heading">​</a></h3><p>The next question we need to tackle is, should we design a subclass of <code>NSControl</code> or <code>NSView</code>? In this specific instance, the answer is pretty straight forward, as we&#x27;re designing a control, it makes the most sense to take advantage of <code>NSControl</code>... it&#x27;s in the name, after all. </p><p>However, here&#x27;s a few things you&#x27;ll want to consider:</p><ul><li><strong><code>NSCell</code>:</strong> Because this class has been soft-deprecated, it&#x27;s pretty safe to assume <code>NSControl</code>s can be written without a corresponding cell (spoiler alert: yep).</li><li><strong>Polymorphic <code>*Value</code> Properties:</strong> <code>NSControl</code> has several <code>*Value</code> properties, like <code>objectValue</code>, and <code>take*ValueFrom(_:)</code> methods to go along with them, for use in Interface Builder and Cocoa Bindings. These aren&#x27;t really that helpful, from my experience, and if they were, re-implementing them for <code>NSView</code> classes isn&#x27;t that hard.</li><li><strong>Field Editors:</strong> This is another of those <code>NeXT</code>-era ideas, where instead of loading say, a hundred, heavyweight <code>NSTextView</code>s into a window, which would kill performance and memory, you would only load one, and share it across a hundred lightweight <code>NSTextFieldCell</code>s. It doesn&#x27;t make much of a difference in 2018, especially since your memory and performance competition are Electron apps: <strong>as long as you don&#x27;t use Electron (or develop in JS for Desktop apps), you&#x27;re winning.</strong></li><li><strong>Target/Action Model:</strong> This is what we know and love <code>NSControl</code> (and <code>UIControl</code>) for! A control has a target, and an action that fires on that target, when the control has been activated somehow. <code>UIControl</code> goes a step further, allowing you to register different targets for different event types, but <code>NSControl</code> offers a single condition-setting <code>sendAction(on:)</code> version. It&#x27;s arguable which is more convenient.</li></ul><p>In summary, there&#x27;s a few reasons to use or not use <code>NSControl</code>, but after weighing out the options, a standard of conformity in being a &quot;control,&quot; and just having the target/action model already implemented for you is pretty helpful, so we&#x27;ll go with that.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="working-with-cgskeyboardshortcut">Working With <code>CGSKeyboardShortcut</code><a class="hash-link" href="#working-with-cgskeyboardshortcut" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="human-readable-string-representation">Human-Readable String Representation<a class="hash-link" href="#human-readable-string-representation" title="Direct link to heading">​</a></h3><p>Before we begin building a user-facing control, we need to make sure <code>CGSKeyboardShortcut</code> and friends can be translated to a human-readable string representation. This is because modifiers and virtual key codes that compose a shortcut like <code>⌘D</code> are device-independent mechanism, and when registering a shortcut, we can&#x27;t use a string containing the shortcut. It&#x27;s important to note that virtual key codes are not ASCII-ordered (that is, sequential in the ASCII table), and may not always have a corresponding glyph to match the key. To determine what the virtual key code points to on the current keyboard, we unfortunately have to return to <code>Carbon.framework</code> for <em>Text Input Services</em> (<code>TIS</code>) and <em>Unicode Utilities</em> (<code>UC</code>). To translate the key code, we grab the current input source&#x27;s keyboard layout, and use the <code>UCKeyTranslate</code> facility to determine what the unicode character resulting from pressing this key in the current layout will be. There are a few special cases like Fn keys that print <code>F13</code>, for example, or the spacebar, which we want to print <code>Space</code>.</p><p><em>Cocoa key equivalents, used by <code>NSMenu</code> and <code>NSButton</code>, for example, internally translate a string containg <code>&quot;x&quot;</code> into the right virtual key code; this is left as an exercise for the reader. Hint: just create a reverse mapping table and look it up!</em></p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">public extension CGKeyCode {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public var isFunctionKey: Bool {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        switch Int(self) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        case kVK_F1, kVK_F2, kVK_F3, kVK_F4, kVK_F5, kVK_F6, kVK_F7, kVK_F8,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">             kVK_F9, kVK_F10, kVK_F11, kVK_F12, kVK_F13, kVK_F14, kVK_F15,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">             kVK_F16, kVK_F17, kVK_F18, kVK_F19, kVK_F20:</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            return true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        default:</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            return false</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public var characters: String {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        if let special = CGKeyCode._special[Int(self)] { return special }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        let source = TISCopyCurrentASCIICapableKeyboardLayoutInputSource().takeUnretainedValue()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        let layoutData = TISGetInputSourceProperty(source, kTISPropertyUnicodeKeyLayoutData)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        let dataRef = unsafeBitCast(layoutData, to: CFData.self)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        let keyLayout = unsafeBitCast(CFDataGetBytePtr(dataRef), to: UnsafePointer&lt;CoreServices.UCKeyboardLayout&gt;.self)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        let keyTranslateOptions = OptionBits(CoreServices.kUCKeyTranslateNoDeadKeysBit)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        var deadKeyState: UInt32 = 0</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        let maxChars = 256</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        var chars = [UniChar](repeating: 0, count: maxChars)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        var length = 0</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        let error = CoreServices.UCKeyTranslate(keyLayout, self,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                                                UInt16(CoreServices.kUCKeyActionDisplay),</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                                                0, UInt32(LMGetKbdType()),</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                                                keyTranslateOptions, &amp;deadKeyState,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                                                maxChars, &amp;length, &amp;chars)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        if error != noErr { return &quot;&quot; }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        return NSString(characters: &amp;chars, length: length).uppercased</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    private static var _special: [Int: String] = [...]</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public extension CGEventFlags {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public var characters: String {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        var string = &quot;&quot;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        if self.contains(.maskAlphaShift) { string.append(&quot;⇪&quot;) }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        if self.contains(.maskHelp) { string.append(&quot;?⃝&quot;) }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        if self.contains(.maskControl) { string.append(&quot;⌃&quot;) }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        if self.contains(.maskAlternate) { string.append(&quot;⌥&quot;) }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        if self.contains(.maskShift) { string.append(&quot;⇧&quot;) }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        if self.contains(.maskCommand) { string.append(&quot;⌘&quot;) }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        return string</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public extension NSEvent.ModifierFlags {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public var characters: String {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        return CGEventFlags(self).characters</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><em>Portions of this code are copyright © 2016 Shunsuke Furubayashi, author of the <code>Magnet</code> library.</em></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="a-simpler-shortcut-representation">A Simpler Shortcut Representation<a class="hash-link" href="#a-simpler-shortcut-representation" title="Direct link to heading">​</a></h3><p>Because we don&#x27;t want to lock ourselves into <code>CGSKeyboardShortcut</code>, and we don&#x27;t exactly manage state like <code>identifier</code> or <code>acquisitionPolicy</code>, which are more within-app intrinsics, we&#x27;ll define a new, simpler type: <code>KeyboardShortcutView.Pair = (CGKeyCode, CGEventFlags)</code>, and create two wrapper functions to transform it to and from an <code>NSDictionary</code>. This is important because we&#x27;ll need to be able to encode and decode it for state restoration and <code>NSCoding</code>.</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">open class KeyboardShortcutView: NSControl, ... {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public typealias Pair = (keyCode: CGKeyCode, modifierFlags: CGEventFlags)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public func representation(of pair: KeyboardShortcutView.Pair?) -&gt; NSDictionary? {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    guard let pair = pair else { return nil }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return [</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        &quot;keyCode&quot;: pair.keyCode,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        &quot;modifierFlags&quot;: pair.modifierFlags.rawValue</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    ] as NSDictionary</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public func representation(of dict: NSDictionary?) -&gt; KeyboardShortcutView.Pair? {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    guard let dict = dict as? [String: Any],</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        let kc = dict[&quot;keyCode&quot;] as? CGKeyCode,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        let mf = dict[&quot;modifierFlags&quot;] as? CGEventFlags.RawValue</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        else { return nil }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return (kc, CGEventFlags(rawValue: mf))</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>With that, we have a facility to converse with other keyboard shortcut libraries or non-Swift objects, like <code>UserDefaults</code>. <em>(Recall that tuples cannot conform to <code>Codable</code>!)</em></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="being-a-good-citizen">Being A Good Citizen<a class="hash-link" href="#being-a-good-citizen" title="Direct link to heading">​</a></h2><p>We&#x27;ll have our recorder control compose a label (<code>NSTextField</code>) and a record/stop button (<code>NSButton</code>):</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">open class KeyboardShortcutView: NSControl, ... {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    /*@objc*/ open weak var delegate: KeyboardShortcutViewDelegate? {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        willSet { self.willChangeValue(forKey: #function) }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        didSet { self.didChangeValue(forKey: #function) }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    @objc open override var alignment: NSTextAlignment {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        get { return self.textLabel.alignment }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        set { self.textLabel.alignment = newValue }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    @objc open var tintColor: NSColor = .keyboardFocusIndicatorColor {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        didSet { /* ... */ }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    @objc open var placeholderString: String? {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        get { return self.textLabel.placeholderAttributedString?.string }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        set {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            let style = NSMutableParagraphStyle()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            style.alignment = self.alignment</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            let attr = NSAttributedString(string: newValue ?? &quot;&quot;, attributes: [</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                .foregroundColor: NSColor.secondaryLabelColor,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                .paragraphStyle: style</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            ])</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            self.textLabel.placeholderAttributedString = attr</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    @objc open override var isEnabled: Bool {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        didSet { /* .. */ }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    open override var isHighlighted: Bool {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    private lazy var clearButton: NSButton = {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        let button = NSButton()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        button.wantsLayer = true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        button.translatesAutoresizingMaskIntoConstraints = false</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        button.image = NSImage(named: .stopProgressTemplate)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        button.bezelStyle = .texturedRounded // for template image rendering</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        button.setButtonType(.momentaryChange)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        button.isBordered = false</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        button.title = &quot;&quot;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        button.target = self</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        button.action = #selector(self.buttonAction(_:))</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        return button</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    private lazy var textLabel: NSTextField = {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        let label = NSTextField()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        label.wantsLayer = true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        label.translatesAutoresizingMaskIntoConstraints = false</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        label.isEditable = false</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        label.isSelectable = false</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        label.isContinuous = false</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        label.isEnabled = true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        label.textColor = self.tintColor</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        label.backgroundColor = .clear</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        label.refusesFirstResponder = true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        label.drawsBackground = false</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        label.isBezeled = false</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        label.lineBreakMode = .byClipping</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        label.setValue(true, forKey: &quot;ignoreHitTest&quot;)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        return label</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public override init(frame frameRect: NSRect) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        super.init(frame: frameRect)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.commonInit()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public required init?(coder: NSCoder) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        super.init(coder: coder)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.commonInit()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    private func commonInit() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.wantsLayer = true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.layerContentsRedrawPolicy = .onSetNeedsDisplay</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.translatesAutoresizingMaskIntoConstraints = false</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.addSubview(self.clearButton)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.addSubview(self.textLabel)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.isEnabled = true // NSControl.isEnabled is false by default.</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.alignment = .center</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This bit of code is pretty basic subview setup, and we&#x27;re using lazy initialization for our views, but it&#x27;s not necessary to do so. In addition, we&#x27;ve added or overridden some properties that forward into our <code>subviews</code> or to our <code>superclass</code>. Remember to always set <code>wantsLayer</code>, <code>layerContentsRedrawPolicy</code> <strong>and definitely never forget <code>translatesAutoresizingMaskIntoConstraints</code> or you will cry.</strong> Notice that we didn&#x27;t touch constraints in our <code>commonInit()</code>, and I&#x27;ll explain why soon.</p><p>Speaking of that, there&#x27;s a particular side effect of invoking setters in <code>commonInit()</code> versus in the initializer itself: it allows us to call the <code>didSet</code> on the property! Just be aware of that, and double check that there are no unintended side effects in your <code>didSet</code>s. Note the <code>will/didChangeValue</code> in our properties, though - we used <code>#function</code> as the key path, but these aren&#x27;t the magical Swift <code>KeyPath</code>s (like <code>\.isRecording</code>) we got in Swift 4.1! What gives? It actually is because we aren&#x27;t able to mark our properties as <code>@objc</code> because they aren&#x27;t able to be represented in ObjC. As a workaround, we&#x27;re able to get the ObjC <code>KeyPath</code> stuff working, but it&#x27;s by no means a good solution. If you have a better solution, let me know!</p><p>Take note that we have to wrap the <code>placeholderString</code> in an <code>NSAttributedString</code> because the default label color is way too dim/translucent and therefore hard to read. This causes an unintended non-updating effect: <code>alignment</code> should be set before setting <code>placeholderString</code>, because we&#x27;re not updating the <code>placeholderString</code>&#x27;s <code>paragraphStyle</code>&#x27;s <code>alignment</code> in <code>updateLayer</code>, and so <code>placeholderString</code>, if set only once, uses the exact value given to it at that time.</p><p>A few more notes about the subviews:</p><ul><li><code>ignoreHitTest</code> is a <strong>Private SPI</strong>! We need it though, because without this flag, the label steals our firstMouse/responder status. If you would rather <em>not</em> do this, subclass <code>NSTextField</code> and override <code>hitTest:</code> to return <code>nil</code>. It has the same effect.</li><li>To render template images (that is, <code>NSImage</code>s whose <code>isTemplate</code> is <code>true</code>, or their name ends with <code>Template</code>) in the current <code>NSAppearance</code>, <code>NSButton</code> has to be a textured style. This adds a little bit of padding around the button, so we&#x27;ll take that into account when working with constraints.</li></ul><p>Since we&#x27;ll also be using the <code>NSControl</code> target/action model, our <code>delegate</code> should primarily be for decision-making. If we wanted to focus on notification of control state, it&#x27;s better to use <code>NSNotificationCenter</code>, which some Cocoa text classes do.</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">public protocol KeyboardShortcutViewDelegate: class {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    func keyboardShortcutViewShouldBeginRecording(_ keyboardShortcutView: KeyboardShortcutView) -&gt; Bool</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    func keyboardShortcutView(_ keyboardShortcutView: KeyboardShortcutView,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                              canRecordShortcut shortcut: KeyboardShortcutView.Pair) -&gt; Bool</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    func keyboardShortcutViewDidEndRecording(_ keyboardShortcutView: KeyboardShortcutView)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>There - now we have a pretty effective API client interface to determine what the control should do in a given situation, along with a visual foundation.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="accepting-key-view">Accepting Key View<a class="hash-link" href="#accepting-key-view" title="Direct link to heading">​</a></h3><p>The important part of a control is to allow the user to activate and deactivate it, which we&#x27;ll do by just clicking within or outside of the control bounds. It&#x27;s very easy to allow becoming the key view or first responder:</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override var acceptsFirstResponder: Bool {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return self.isEnabled</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override var canBecomeKeyView: Bool {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return super.canBecomeKeyView &amp;&amp; NSApp.isFullKeyboardAccessEnabled</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override var needsPanelToBecomeKey: Bool {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override func acceptsFirstMouse(for event: NSEvent?) -&gt; Bool {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override func performClick(_ sender: Any?) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.window?.makeFirstResponder(self)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>That&#x27;s all you need to do! Now, clicking inside the control will give us key input, which we&#x27;ll focus on in the next section. </p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="responding-to-user-input">Responding to User Input<a class="hash-link" href="#responding-to-user-input" title="Direct link to heading">​</a></h3><p>This is the meat of the control: actually recording the shortcut. The first thing we should do is get our <code>isEnabled</code>, <code>isHighlighted</code>, <code>isRecording</code> properties correctly wired together. We shouldn&#x27;t be able to set our highlight state because that&#x27;s for the user to do; instead, wire its getter through to <code>isRecording</code>. The two main properties are <code>shortcut</code> and <code>inputModifiers</code>, the latter of which we&#x27;ll use to track which modifier flags are set when the user is entering the shortcut. When setting the <code>shortcut</code>, we&#x27;ll use the <code>NSControl</code> target/action mechanism to send our <code>action</code> to our <code>target</code>. If we don&#x27;t have a defined <code>target</code> (that is, it&#x27;s <code>nil</code>), the message travels up the responder chain automatically! If the client (instead of the user) sets the <code>shortcut</code> directly, it&#x27;ll still trigger the action, so keep that in mind - the solution to this is to wrap it in an <code>if self.isRecording</code>, but in this case, it&#x27;s the behavior we might want.</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">@objc open override var isEnabled: Bool {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    didSet {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        if !self.isEnabled { self.endRecording() }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override var isHighlighted: Bool {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    get { return self.isRecording }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    set { }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">@objc open private(set) var isRecording = false {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    willSet { self.willChangeValue(forKey: #function) }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    didSet { self.didChangeValue(forKey: #function) }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">/*@objc*/ open var shortcut: KeyboardShortcutView.Pair? {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    willSet {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        guard self.shortcut?.keyCode != newValue?.keyCode &amp;&amp;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            self.shortcut?.modifierFlags != newValue?.modifierFlags else { return }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.willChangeValue(forKey: #function)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    didSet {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        guard self.shortcut?.keyCode != oldValue?.keyCode &amp;&amp;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            self.shortcut?.modifierFlags != oldValue?.modifierFlags else { return }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        _ = self.sendAction(self.action, to: self.target)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.didChangeValue(forKey: #function)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">private var inputModifiers: NSEvent.ModifierFlags = [] {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    didSet {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Now we&#x27;ll have to actually handle mouse activation and keyboard events:</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override func mouseDown(with event: NSEvent) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    guard self.isEnabled else {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        super.mouseDown(with: event); return</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    let locationInView = self.convert(event.locationInWindow, from: nil)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    if self.mouse(locationInView, in: self.bounds) &amp;&amp; !self.isRecording {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.inputModifiers = []</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        _ = self.beginRecording()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        super.mouseDown(with: event)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>If we&#x27;re enabled, and the mouse press was within our bounds, reset our recording state and begin recording. Next, if our <code>flagsChanged(with:)</code> is called, change our input modifiers state (and we&#x27;ll cover soon how that reflects in the UI). The easy thing about writing a shortcut recorder is that we can use <code>performKeyEquivalent(with:)</code>! It&#x27;s called when a &quot;key equivalent&quot; <em>(read: &quot;keyboard shortcut&quot;)</em> is pressed and we&#x27;re first responder. This basically has already taken care of all the work for us, and we just need to validate the new shortcut with the delegate and end recording.</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override func performKeyEquivalent(with event: NSEvent) -&gt; Bool {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    if !self.isEnabled || !self.isRecording { return false }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    if self.window?.firstResponder != self { return false }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    let shortcut = (keyCode: CGKeyCode(event.keyCode),</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                    modifierFlags: CGEventFlags(event.modifierFlags))</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // inline validation func if we have no delegate response:</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    func validate() -&gt; Bool {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        guard !shortcut.keyCode.isFunctionKey else { return true }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        return !shortcut.modifierFlags.intersection(.maskUserFlags).isEmpty</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    let del = (self.delegate ?? self.target as? KeyboardShortcutViewDelegate)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    if del?.keyboardShortcutView(self, canRecordShortcut: shortcut) ?? validate() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.shortcut = shortcut</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.endRecording()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        return true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return false</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override func flagsChanged(with event: NSEvent) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.inputModifiers = self.isRecording ? event.modifierFlags : []</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    super.flagsChanged(with: event)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>If we don&#x27;t have a <code>delegate</code>, we&#x27;ll check if our <code>target</code> is <em>also</em> capable of being our <code>delegate</code> -- this is mostly convenience, kinda like how you have a <code>delegate</code> and a <code>dataSource</code> for a collection or table view, but usually it&#x27;s one view controller implementing both. If neither the <code>delegate</code> or <code>target</code> can help us validate the input, we&#x27;ll just allow it to go through as long as it&#x27;s not a single non-Fn key (that is, you shouldn&#x27;t allow just <code>Q</code> as a hot key: that would lead to a lot of problems!).</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override func keyDown(with event: NSEvent) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    guard !self.performKeyEquivalent(with: event) else { return }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    super.keyDown(with: event)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override func resignFirstResponder() -&gt; Bool {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.endRecording()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>And with that, we&#x27;ve completed handling our event handling: if we get a stray <code>keyDown(with:)</code> message, just invoke <code>performKeyEquivalent(with:)</code>, as this can occur in the case described before, where a single non-Fn key is pressed. Again, <strong>allowing this is bad practice and interferes with system keyboard input!</strong> But who are we to judge, right? </p><p>The recording actions take place primarily in <code>beginRecording()</code> and <code>endRecording()</code>; we could have just placed the body of these methods in <code>isRecording.didSet</code> but that would be very very bloated and inappropriate code style. Be sure to handle state correctly and guard against out-of-place calls to these methods, as that can lead to unexpected user-visible state leakage. </p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">public func beginRecording() -&gt; Bool {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    if !self.isEnabled { return false }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    if self.isRecording { return true }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    let del = (self.delegate ?? self.target as? KeyboardShortcutViewDelegate)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    guard del?.keyboardShortcutViewShouldBeginRecording(self) ?? true else {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        NSSound.beep(); return false</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.isRecording = true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public func endRecording() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    if !self.isRecording { return }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.inputModifiers = []</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.isRecording = false</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    if self.window?.firstResponder == self &amp;&amp; !self.canBecomeKeyView {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.window?.makeFirstResponder(nil)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    let del = (self.delegate ?? self.target as? KeyboardShortcutViewDelegate)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    del?.keyboardShortcutViewDidEndRecording(self)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>It&#x27;s pretty self-explanatory, as all we do is consult (or notify) the <code>delegate</code>/<code>target</code>, and fallback to the assumption that we are allowed to record, if none are available. When we <code>resignFirstResponder()</code> or <code>endRecording()</code>, we end up calling the opposite method, but these calls aren&#x27;t re-entrant as <code>NSWindow.makeFirstResponder(_:)</code> does the verification for us. Finally, we just need to wire up the <code>clearButton</code> action to perform the context-specific thing: if we&#x27;re not recording but we don&#x27;t have a set <code>shortcut</code>, <code>beginRecording()</code>; if we <strong>do</strong> have a set <code>shortcut</code>, clear it and end recording. Otherwise, we&#x27;re already recording - <code>endRecording()</code> without losing the previously set <code>shortcut</code>, if any.</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">@objc private func buttonAction(_ button: NSButton) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    if !self.isRecording &amp;&amp; self.shortcut == nil { // cleared state</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.window?.makeFirstResponder(self)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        _ = self.beginRecording()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    } else if self.isRecording &amp;&amp; self.shortcut != nil { // cleared state</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.endRecording()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        if self.shortcut != nil { self.shortcut = nil }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.endRecording()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="updatelayer"><code>updateLayer</code><a class="hash-link" href="#updatelayer" title="Direct link to heading">​</a></h3><p>Let&#x27;s take a brief moment to provide a convenience function for visually representing the whole shortcut to the user: </p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">private var stringRepresentation: String {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    var modifiers: NSEvent.ModifierFlags = self.inputModifiers</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    if self.isRecording {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        return modifiers.characters</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        if let shortcut = self.shortcut {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            modifiers.formUnion(NSEvent.ModifierFlags(shortcut.modifierFlags))</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        return modifiers.characters + (self.shortcut?.keyCode.characters ?? &quot;&quot;)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>It&#x27;s not too much: if we&#x27;re recording, return the input modifers as a string, but if we&#x27;re not, use the <code>shortcut</code>&#x27;s <code>modifier.characters</code> <strong>and</strong> the input modifier&#x27;s, together, along with the <code>keyCode</code> as a string at the very end. This will match the canonical string representation seen in <code>NSMenuItem</code>s. Since we&#x27;re explicitly layer-backed and requesting <code>updateLayer</code>, we should definitely control our visual appearance here:</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override var allowsVibrancy: Bool {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return false</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override var wantsUpdateLayer: Bool {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override func updateLayer() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.textLabel.textColor = self.isEnabled ? self.tintColor : .disabledControlTextColor</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    let str = self.stringRepresentation</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.textLabel.stringValue = str</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.toolTip = Localized.tooltipPrefix + &quot;: &quot; + (str.isEmpty ? Localized.noShortcut : str)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                    + &quot;\n\n&quot; + Localized.help</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.clearButton.isEnabled = self.isEnabled</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    let canStop = self.isRecording || self.shortcut != nil</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.clearButton.image = NSImage(named: canStop ? .stopProgressFreestandingTemplate</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                                                    : .statusUnavailable)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>You&#x27;ll notice we set the <code>tooltip</code> here as well. It&#x27;s important to do so per-view, or if we&#x27;re drawing specific regions with different tooltips, we can use <code>addToolTipRect...</code> and friends; these are hover-based context clues as to what the view under the mouse provides, and there&#x27;s no iOS equivalent. For now, ignore the <code>Localized...</code> values, as we&#x27;ll talk about that later.</p><p>Add a <code>self.needsDisplay = true</code> call to the <code>didSet</code> of the properties: <code>tintColor</code>, <code>shortcut</code>, <code>isEnabled</code>, and <code>inputModifers</code>. This will mark the view as needing <code>updateLayer()</code> called, which we can then update visual appearances in.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="drawing-a-button-without-being-one">Drawing a Button Without Being One<a class="hash-link" href="#drawing-a-button-without-being-one" title="Direct link to heading">​</a></h3><p>An important thing to do in designing and implementing a new control is to <strong>always look and feel like a system control!</strong> It&#x27;s very obvious to a user when an app doesn&#x27;t do this and it provides the perception of a cheap or poorly designed app, leading to possible user dissatisfaction. For this control, let&#x27;s act like a mix between a button and text input, because we act like a mix between the two. A good example of a control that already has this appearance is an <code>NSSearchField</code> in an <code>NSToolbar</code> (in a regular <code>NSView</code>, it looks recessed, but in the toolbar it has a button-like appearance). Instead, however, we&#x27;ll steal the appearance of an <code>NSButton</code> directly using an <code>NSButtonCell</code>. Like I said much earlier in the article, <code>NSCell</code>s encapsulate both event-handling <em>and</em> visual appearance, without being an actual view! We can quite simply share a button cell between all instances of our control and draw it into a sublayer in <code>updateLayer()</code>, using the <code>drawBezel(withFrame:in:)</code> method. Be sure to add the sublayer to our hierarchy and set the correct <code>bezelStyle</code>.</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">private static var stampCell: NSButtonCell = {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    let c = NSButtonCell()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    c.bezelStyle = .texturedRounded</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return c</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">private lazy var underlayer = CALayer()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">private func commonInit() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.layer?.addSublayer(self.underlayer)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override func updateLayer() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    var b = self.bounds.size; b.height = 22</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    let img = NSImage(size: b, flipped: false) { r in</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        KeyboardShortcutView.stampCell.drawBezel(withFrame: r, in: self)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        return true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    CATransaction.begin()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    CATransaction.setDisableActions(true)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.underlayer.contents = img</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.underlayer.contentsScale = self.layer!.contentsScale // inherit</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.underlayer.contentsCenter = CGRect(x: 0.25, y: 0.25, width: 0.5, height: 0.5)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    CATransaction.commit()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override func layout() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    super.layout()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    CATransaction.begin()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    CATransaction.setDisableActions(true)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.underlayer.frame = self.layer!.bounds</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    CATransaction.commit()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><em><code>-[NSButtonCell updateLayerWithFrame:inView:]</code> actually uses a private <code>NSLayerContentsFacet</code> and CoreUI to optimize drawing <code>CALayer</code> contents, but it&#x27;s a non-issue for us.</em></p><p>If we could use <code>drawRect:</code> it might be more straight forward, but we lose the ability to set the <code>CALayer.contentsCenter</code> which automatically does 9-part image slicing for us, if the <code>underlayer</code> frame and the <code>content</code> size don&#x27;t match up. You might notice that if you just set <code>layer.frame</code>, it&#x27;ll animate and look weird as it snaps into a new frame, where we don&#x27;t expect this to occur. To fix this, we just open an explicit sub-transaction, which disables <code>CALayer</code> actions. Another possible approach to avoid <code>frame</code> implicit animations is to modify the layer&#x27;s <code>actions</code> dictionary:</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">var implicits = layer.actions</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">implicits[&quot;position&quot;] = NSNull()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">implicits[&quot;bounds&quot;] = NSNull()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">layer.actions = implicits</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Another small visual issue is that the <code>NSCell</code> we&#x27;re drawing has no understanding of the control&#x27;s <code>effectiveAppearance</code>, unless we tell it using <code>NSAppearance.current</code>:</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override func updateLayer() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    let img = NSImage(size: b, flipped: false) { r in</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.effectiveAppearance.using {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            KeyboardShortcutView.stampCell.drawBezel(withFrame: r, in: self)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        return true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">// ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public extension NSAppearance {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public func using(_ handler: () -&gt; ()) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        let x = NSAppearance.current</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        NSAppearance.current = self</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        handler()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        NSAppearance.current = x</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Now, if you set the whole <code>window</code>&#x27;s <code>appearance</code> to, say, <code>vibrantDark</code>, the control will render perfectly no matter what size, in that appearance! (It&#x27;s a little baffling to me that <code>NSButton</code>s don&#x27;t stretch their drawing, but oh well.)</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="focus-rings">Focus Rings<a class="hash-link" href="#focus-rings" title="Direct link to heading">​</a></h3><p>Now, as a control that can become key and first responder in its <code>window</code>, we should inform the user that we have done so using a focus ring. After macOS Lion, we no longer need to draw them ourselves, but instead provide their bounds and a mask to match our view&#x27;s shape. Let&#x27;s just ask our layer to render itself <em>as</em> a mask, since only the alpha channel is used for masking!</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override var focusRingMaskBounds: NSRect {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return (self.isEnabled &amp;&amp; self.window?.firstResponder == self) ? self.bounds : .zero</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override func drawFocusRingMask() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    guard self.isEnabled &amp;&amp; window?.firstResponder == self else { return }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.underlayer.render(in: NSGraphicsContext.current!.cgContext)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Now we just need to add a <code>self.noteFocusRingMaskChanged()</code> call to <code>isEnabled.didSet</code>, so we can show and hide the focus ring automatically. <code>CALayer.render(in:)</code> isn&#x27;t a great idea in most cases because it actually uses the <code>CG</code> rendering path, instead of the <code>OGL</code> or <code>Metal</code> rendering paths that Core Animation can use to accelerate layers on the GPU, and so it&#x27;s actually a visual approximation to what the layer actually looks like. This doesn&#x27;t really bother us because we only need the shape to be correct, though, but it&#x27;s something to keep in mind in general when designing a view with sublayers.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="layout-updateconstraints--intrinsiccontentsize"><code>layout</code>, <code>updateConstraints</code>, &amp; <code>intrinsicContentSize</code><a class="hash-link" href="#layout-updateconstraints--intrinsiccontentsize" title="Direct link to heading">​</a></h3><p>Because we have sublayers and subviews, we should adjust their layout here. We&#x27;ve already taken care of <code>underlayer</code>, so now let&#x27;s dynamically resize our <code>font</code> to match our control&#x27;s height. It&#x27;s surprisingly not straightforward, because the facility to do so is found on <code>NSFontManager</code> and not <code>NSFont</code>, but using the facility is pretty easy.</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override func layout() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    if let font = self.font {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.textLabel.font = NSFontManager.shared.convert(font, toSize: self.bounds.height / 1.7)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.textLabel.font = NSFont.systemFont(ofSize: self.bounds.height / 1.7)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Here&#x27;s where we finally set up and handle constraints! We&#x27;ll use constraints to handle our subviews, because our sublayer just needs to match our frame. We could, however, add an <code>NSLayoutGuide</code> to our control, set up constraints on that guide, and then synchronize its frame to the sublayer frame, but it&#x27;s not worth the trouble.</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override class var requiresConstraintBasedLayout: Bool {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">private var childConstraints: [NSLayoutConstraint] = []</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override func updateConstraints() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    if self.childConstraints.count == 0 {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.childConstraints = [</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            self.textLabel.leadingAnchor.constraint(equalTo: self.leadingAnchor, constant: 4.0),</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            self.textLabel.trailingAnchor.constraint(equalTo: self.clearButton.leadingAnchor, constant: 0.0),</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            self.clearButton.trailingAnchor.constraint(equalTo: self.trailingAnchor, constant: 0.0),</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            self.clearButton.heightAnchor.constraint(equalTo: self.heightAnchor, multiplier: 1.0),</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            self.clearButton.widthAnchor.constraint(equalTo: self.clearButton.heightAnchor, multiplier: 1.0),</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            self.textLabel.centerYAnchor.constraint(equalTo: self.centerYAnchor, constant: -1.0),</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            self.clearButton.centerYAnchor.constraint(equalTo: self.centerYAnchor),</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        ]</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        NSLayoutConstraint.activate(self.childConstraints)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    super.updateConstraints()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The gist of it is, <code>updateConstraints()</code> is called post-initialization, and whenever we set <code>self.needsUpdateConstraints = true</code>, and if we haven&#x27;t configured any constraints, we&#x27;ll cache our constraints and activate them. It&#x27;s helpful to do so in this method because we may, in the future, want to dynamically adjust our constraints, and we can do that in order with the layout and display cycle here.</p><p>The last thing we should do as a good citizen control, is provide an <code>intrinsicContentSize</code>: this is the size that our control will take up if we don&#x27;t add any size constraints to it. Usually, it&#x27;s just the smallest bounding box of the control&#x27;s contents, which we can sum the <code>intrinsicContentSize</code>s of our <code>textLabel</code> and <code>clearButton</code> to find. Since there&#x27;s a chance that they might provide a <code>.noIntrinsicMetric</code>, and our control <em>does</em> have intrinsic metrics for width (both <code>textLabel</code> and <code>clearButton</code> do, in fact), we should be cautious of that case. We&#x27;ll factor in our padding from the constraints above as well.</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override var intrinsicContentSize: NSSize {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    var _t = self.textLabel.intrinsicContentSize</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    var _b = self.clearButton.intrinsicContentSize</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    if _t.width == NSView.noIntrinsicMetric { _t.width = 0.0 }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    if _b.width == NSView.noIntrinsicMetric { _b.width = 0.0 }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // Compute the sum/max of the intrinsicContentSizes of our subviews.</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return NSSize(width: _t.width + _b.width + 12.0 /* padding */,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                  height: max(_t.height, _b.height) /* 22.0? */)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>We could also take the approach that <code>NSButton</code> and similar controls take, which is to clamp the intrinsic size to <code>22px</code> in height. For a platform with a cursor, <code>22px</code> is the &quot;right height&quot; for a clickable control that contains a label, and for a platform that relies on touch input, it&#x27;s between <code>32px</code> and <code>44px</code>. <em>(That&#x27;s from the Apple HIG somewhere.)</em></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="hover--cursors">Hover &amp; Cursors<a class="hash-link" href="#hover--cursors" title="Direct link to heading">​</a></h3><p>To support any kind of cursor change or mouse hovering, we need to use <code>NSTrackingArea</code> and the related methods on <code>NSView</code> used to add and remove them. It&#x27;s not recommended to use any of the methods with the phrase <code>TrackingRect</code> or <code>CursorRect</code> in them - they&#x27;ve been superseded since Leopard by <code>NSTrackingArea</code>.</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">private func commonInit() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.addTrackingArea(NSTrackingArea(rect: .zero,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                                        options: [.activeInKeyWindow, .inVisibleRect, .cursorUpdate],</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                                        owner: self, userInfo: nil))</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override func cursorUpdate(with event: NSEvent) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    NSCursor.pointingHand.set()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>We don&#x27;t even have to implement <code>updateTrackingAreas()</code> to handle changing frames or anything. The <code>NSTrackingArea</code> makes sure that <code>cursorUpdate(with:)</code> is only called with the visible frame of the view, when the window containing the view is key. It&#x27;s dead simple; if we wanted to support mouse hovering, to perhaps display suggestions or change our drawing in some way, we would just change <code>.cursorUpdate</code> to <code>.mouseEnteredAndExited</code> or <code>.mouseMoved</code>. Maybe we just want to change our drawing or cursor when we&#x27;re the first responder? Just change <code>.activeInKeyWindow</code> to <code>.activeWhenFirstResponder</code> -- be mindful that the <code>options</code> are three individual option sets masked together. You can&#x27;t use <code>.activeInKeyWindow</code> and <code>.activeWhenFirstResponder</code> simultaneously for example.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="haptic--audio-feedback">Haptic &amp; Audio Feedback<a class="hash-link" href="#haptic--audio-feedback" title="Direct link to heading">​</a></h3><p>Some controls may want to add audio feedback support, like <code>NSButton.sound</code>, but in my opinion, this makes assumptions on the availability and implementation of the audo feedback (what if the client wishes to use <code>AVAudioPlayer</code>?); instead, it&#x27;s probably a better idea to play the sound in our delegate or target/action methods. If we did want to support audio feedback with <code>NSSound</code>, however, it&#x27;s quite simple:</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">@objc open var sound: NSSound? = nil</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">// ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">open func doSomething() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.sound?.play()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Likewise, some controls may want to add haptic feedback, but those controls <em>(should)</em> primarily rely on <em>(specifically)</em> force touch interaction, like dragging or deep pressing, and our shortcut recording control relies primarily on keyboard input. If we were to, adding simple haptic responses is just as simple, albeit a little more wordy:</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">@objc open var hapticPerformer: NSHapticFeedbackPerformer? = NSHapticFeedbackManager.defaultPerformer</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">// ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">open func doSomething() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.hapticPerformer?.perform(.levelChange, performanceTime: .drawCompleted)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>In this specific case, while currently on macOS, there is only a <code>defaultPerformer</code>, we can expect that there may be more in the future, perhaps one for the touch bar, as an example. In anticipating such changes, it might be a good idea to allow our client to set the desired <code>hapticPerformer</code> - if it&#x27;s set to <code>nil</code>, it acts as if we&#x27;ve disabled haptic feedback.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="window-keyedness">Window Keyedness<a class="hash-link" href="#window-keyedness" title="Direct link to heading">​</a></h3><p><img loading="lazy" alt="NSWindow State" src="/assets/images/window-state-ccecc78070390cf7b33c68fa20484132.png" width="608" height="417" class="img_ev3q"></p><p>An important concept on macOS is that of window &quot;keyedness&quot; and &quot;main-ness&quot;, as you can see above. Controls are expected to draw accordingly to visually explain to the user if they&#x27;re able to be interacted with or not. We can monitor our parent <code>window</code>&#x27;s state without any strong reference to the <code>window</code> by using the <code>viewWillMove(toWindow:)</code> method, and then trampoline that using <code>NSNotificationCenter</code>.</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">@objc private func windowKeyednessChanged(_ note: Notification) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    guard let window = self.window, (note.object as? NSWindow) == window else { return }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // do nothing for now</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override func viewWillMove(toWindow newWindow: NSWindow?) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    let n = NotificationCenter.default // shorthand</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    if let oldWindow = self.window {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        n.removeObserver(self, name: NSWindow.didBecomeKeyNotification,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                         object: oldWindow)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        n.removeObserver(self, name: NSWindow.didResignKeyNotification,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                         object: oldWindow)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    if let newWindow = newWindow {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        n.addObserver(self, selector: #selector(self.windowKeyednessChanged(_:)),</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                      name: NSWindow.didBecomeKeyNotification, object: newWindow)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        n.addObserver(self, selector: #selector(self.windowKeyednessChanged(_:)),</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                      name: NSWindow.didResignKeyNotification, object: newWindow)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">deinit {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    NotificationCenter.default.removeObserver(self) // just in case</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Now, we&#x27;ll get the <code>windowKeyednessChanged(_:)</code> notifications whenever keyedness changes (and note that we could do the same for main-ness as well) without worrying about which window we&#x27;re contained within. The next thing to do is wire our first responder state into the method, which sounds inappropriate, but since we use the method <em>just</em> for handling drawing and event state, it&#x27;s okay to do so without getting pedantic about it.</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override func becomeFirstResponder() -&gt; Bool {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    DispatchQueue.main.async {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.windowKeyednessChanged(Notification(name: NSWindow.didBecomeKeyNotification,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                                                 object: self.window, userInfo: nil))</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override func resignFirstResponder() -&gt; Bool {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    DispatchQueue.main.async {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.windowKeyednessChanged(Notification(name: NSWindow.didResignKeyNotification,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                                                 object: self.window, userInfo: nil))</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>We need to enqueue the <code>windowKeyednessChanged</code> invocation to the main queue because we haven&#x27;t yet become the first responder until the <code>become/resignFirstResponder</code> method returns.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="global-hotkey-interference">Global HotKey Interference<a class="hash-link" href="#global-hotkey-interference" title="Direct link to heading">​</a></h3><p>At this point we have a fully functional keyboard shortcut recorder! However... attempting to record certain shortcuts, you&#x27;ll find, don&#x27;t work, mysteriously. After a few different shortcuts you&#x27;ve tried to record, it hits you: these are symbolic shortcuts that we&#x27;ve set in the System Preferences! We&#x27;re accidentally triggering them instead of recording the shortcut! Surely, you wonder, how does System Preferences allow you to record shortcuts without triggering symbolic ones willy-nilly? The answer lies in a den of dragons:</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">// Here lie dragons!</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">fileprivate typealias CGSConnectionID = UInt</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">fileprivate enum CGSGlobalHotKeyOperatingMode: UInt {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    case enable = 0, disable = 1, universalAccessOnly = 2</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">@_silgen_name(&quot;CGSMainConnectionID&quot;)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">fileprivate func CGSMainConnectionID() -&gt; CGSConnectionID</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">@_silgen_name(&quot;CGSGetGlobalHotKeyOperatingMode&quot;)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">fileprivate func CGSGetGlobalHotKeyOperatingMode(_ connection: CGSConnectionID,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                                                 _ mode: UnsafeMutablePointer&lt;CGSGlobalHotKeyOperatingMode?&gt;) -&gt; CGError</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">@_silgen_name(&quot;CGSSetGlobalHotKeyOperatingMode&quot;)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">fileprivate func CGSSetGlobalHotKeyOperatingMode(_ connection: CGSConnectionID,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                                                 _ mode: CGSGlobalHotKeyOperatingMode) -&gt; CGError</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The answer to recording hotkeys that have been reserved already... is to turn off hotkeys globally while you&#x27;re first responder. I swear up and down this is exactly what System Preferences does - take a look yourself if you don&#x27;t believe me! It&#x27;s pretty simple to cache the existing global state, turn the hotkeys off, and then once we&#x27;re resigning first responder, reset the global state. Here&#x27;s what that looks like:</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">private var savedOperatingMode: CGSGlobalHotKeyOperatingMode? = nil</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">deinit {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    if self.savedOperatingMode != nil {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        _ = CGSSetGlobalHotKeyOperatingMode(CGSMainConnectionID(), self.savedOperatingMode!)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">@objc private func windowKeyednessChanged(_ note: Notification) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    if window.isKeyWindow &amp;&amp; window.firstResponder == self { // becomeKey</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        guard self.savedOperatingMode == nil else { return }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        _ = CGSGetGlobalHotKeyOperatingMode(CGSMainConnectionID(), &amp;self.savedOperatingMode)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        _ = CGSSetGlobalHotKeyOperatingMode(CGSMainConnectionID(), .disable)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    } else { // resignKey</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        guard self.savedOperatingMode != nil else { return }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        _ = CGSSetGlobalHotKeyOperatingMode(CGSMainConnectionID(), self.savedOperatingMode!)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.savedOperatingMode = nil</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        window.makeFirstResponder(nil) // resign ourselves if window resigned</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>A disclaimer: <em>you don&#x27;t need to include this to roll a fully functional shortcut recorder.</em> You <strong>can</strong> ignore the fact that the user will be trying to record shortcuts and then be disappointed that it&#x27;s not working. You <strong>can!</strong> let your user down! And you <strong>will</strong> if you&#x27;re submitting your app to the MAS, so keep this in mind. We&#x27;re not to use this facility for evil, but to respond to exactly what the user is doing. The unfortunate downside is that the symbolic/other hot keys will be triggered when the user double-dips with our app, unless we claim the shortcut exclusively (see, there <em>was</em> a reason for that!).</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="string-localization">String Localization<a class="hash-link" href="#string-localization" title="Direct link to heading">​</a></h3><p>Alright, we&#x27;re done now right? No one using this control lives outside America (and even those that live within, they definitely speak English fluently, right?) and none of <em>our users</em> are disabled right? <strong>Wrong.</strong> Always consider that you, as the developer, are not the target audience of your tool (be it a control, or an app), and always focus on <strong>i18n</strong> and <strong>accessibility</strong>, because like it or not, it&#x27;s not beneficence, it&#x27;s a responsibility.</p><p>Luckily, localization support is pretty easy, except for the hard part (which is the localization itself). I&#x27;ve opted to wrap it into a <code>Localized</code> container with a helper function <code>value(_:default:comment:)</code> that looks up the string from the bundle that contains the class. This is important, because your control may or may not be in the <code>main</code> bundle. To use it, just create static properties like <code>Localized.voiceOverBegin</code> below:</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">private enum Localized {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    private static func value(_ key: String, `default`: String, comment: String) -&gt; String {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        return NSLocalizedString(key, tableName: nil, bundle: Bundle(for: KeyboardShortcutView.self),</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                                 value: `default`, comment: comment) // helper!</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    fileprivate static var actionName: String {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        return value(&quot;action_name&quot;, default: &quot;Record Shortcut&quot;,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                     comment: &quot;The action name for undo and redo&quot;)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    fileprivate static var voiceOverBegin: String {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        return value(&quot;voiceover_begin&quot;, default: &quot;Now recording a shortcut&quot;,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                     comment: &quot;The notification name for VoiceOver if the control began recording&quot;)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Always provide helpful comments for your translators, and provide a <code>default</code> in your expected target language in case you haven&#x27;t loaded a good <code>strings</code> file, or you just plain don&#x27;t have one in the current bundle.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="accessibility">Accessibility<a class="hash-link" href="#accessibility" title="Direct link to heading">​</a></h3><p>I&#x27;m no accessibility expert, but here&#x27;s the bare minimum you should implement for a control that resembles a button and contains other sub-controls. Be sure to conform <code>KeyboardShortcutView</code> to <code>NSAccessibilityButton</code> and <code>NSAccessibilityGroup</code>.</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override func isAccessibilityElement() -&gt; Bool {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override func accessibilityHelp() -&gt; String? {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return Localized.help</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override func accessibilityRole() -&gt; NSAccessibilityRole? {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return .button</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override func accessibilityLabel() -&gt; String? {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    let str = self.stringRepresentation</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return str.isEmpty ? Localized.noShortcut : str</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override func accessibilityValue() -&gt; Any? {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return self.accessibilityLabel()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override func accessibilityRoleDescription() -&gt; String? {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return Localized.tooltipPrefix</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override var accessibilityFocusedUIElement: Any? {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return self.window?.firstResponder == self</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override func accessibilityChildren() -&gt; [Any]? {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return [self.clearButton]</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override func accessibilityPerformPress() -&gt; Bool {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    guard self.isEnabled else { return false }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.performClick(nil)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>And while that presents our accessible properties to the accessibility daemons and tools, we should also post notifications using <code>NSAccessibilityPostNotification</code> when <code>shortcut</code> changes, and definitely emit a VoiceOver announcement when we change recording state or set the shortcut from user input.</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">/*@objc*/ open var shortcut: KeyboardShortcutView.Pair? {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    didSet {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        NSAccessibilityPostNotification(self, .valueChanged)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override func performKeyEquivalent(with event: NSEvent) -&gt; Bool {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    if /* we should record the new shortcut */ {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        NSAccessibilityPostNotificationWithUserInfo(self, .announcementRequested, [</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            .announcement: Localized.voiceOverRecorded,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            .priority: NSAccessibilityPriorityLevel.high</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        ])</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        return true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public func beginRecording() -&gt; Bool {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    NSAccessibilityPostNotificationWithUserInfo(self, .announcementRequested, [</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        .announcement: Localized.voiceOverBegin,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        .priority: NSAccessibilityPriorityLevel.high</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    ])</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">@objc private func buttonAction(_ button: NSButton) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    if /* we should clear the shortcut set */ {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        NSAccessibilityPostNotificationWithUserInfo(self, .announcementRequested, [</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            .announcement: Localized.voiceOverCleared,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            .priority: NSAccessibilityPriorityLevel.high</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        ])</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override func updateLayer() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.clearButton.setAccessibilityLabel(canStop ? Localized.buttonRecordLabel</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                                                   : Localized.buttonClearLabel)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">in KeyboardShortcutView.clearButton.getter:</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        button.toolTip = Localized.buttonTooltip</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        button.setAccessibilityHelp(Localized.buttonTooltip)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>We don&#x27;t just place the VoiceOver announcements in <code>willSet</code>/<code>didSet</code> for <code>isRecording</code>, because they are unique to the reason why the recording state changed.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="nscoding--state-restoration"><code>NSCoding</code> &amp; State Restoration<a class="hash-link" href="#nscoding--state-restoration" title="Direct link to heading">​</a></h3><p>One of the most crucial things is to support <code>NSCoding</code> if you aim to be Interface Builder-compatible, and to support automatic termination, through <code>NSResponder</code> state restoration. State restoration should encode and decode only a subset of the keys the class typically encodes or decodes for <code>NSCoding</code>: the ones that are actually user-facing state. As Apple says, <em>&quot;you must store enough data to reconfigure the responder and return it to its current state during a subsequent launch of the application.&quot;</em></p><p><strong>Here, you really should <em>not</em> be passing <code>NSCoding</code> methods onto <code>NSResponder</code>&#x27;s state restoration.</strong> I leave the proper implementation as an exercise for the reader. <em>(read: I was lazy about it.)</em> I&#x27;ve decided to not implement it correctly as I&#x27;m currently experimenting with a <code>Codable</code> &lt;--&gt; <code>NSCoding</code> adapter specific to my implementation of this control. I&#x27;ll possibly write another post on that later.</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">open static var supportsSecureCoding: Bool {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public required init?(coder: NSCoder) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    super.init(coder: coder)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.restoreState(with: coder)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.commonInit()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override func encode(with coder: NSCoder) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    super.encode(with: coder)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.encodeRestorableState(with: coder)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override func encodeRestorableState(with coder: NSCoder) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    //super.encodeRestorableState(with: coder)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    coder.encode(self.suggestions.map { representation(of: $0) }, forKey: &quot;suggestions&quot;)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    coder.encode(representation(of:self.shortcut), forKey: &quot;shortcut&quot;)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    coder.encode(self.isEnabled as NSNumber, forKey: &quot;isEnabled&quot;)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override func restoreState(with coder: NSCoder) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    //super.restoreState(with: coder)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    let s = coder.decodeObject(of: NSArray.self, forKey: &quot;suggestions&quot;) as? [NSDictionary]</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.suggestions = (s ?? []).compactMap { representation(of: $0) }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.shortcut = representation(of: coder.decodeObject(of: NSDictionary.self, forKey: &quot;shortcut&quot;))</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.isEnabled = coder.decodeObject(of: NSNumber.self, forKey: &quot;isEnabled&quot;) as? Bool ?? false</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Be sure to conform <code>KeyboardShortcutView</code> to <code>NSSecureCoding</code>. When we change certain properties (the ones we&#x27;re encoding and decoding), we should call <code>invalidateRestorableState</code> to ensure our current state is encoded (automatic termination is like the grim reaper: it arrives without warning, and thus we must protect our interests before its arrival). Add the <code>self.invalidateRestorableState()</code> call to the <code>didSet</code> of <code>shortcut</code>, <code>suggestions</code>, and <code>isEnabled</code>. </p><p>Now when you make a change, quit the app, reopen it, and you&#x27;ll find that things were as you left it before you quit the app!</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="context-nsmenu-popups">Context <code>NSMenu</code> Popups<a class="hash-link" href="#context-nsmenu-popups" title="Direct link to heading">​</a></h3><p>It may be desirable to allow the user to select a keyboard shortcut from a list of suggestions, like the Siri System Preferences pane, for example. To support this, let&#x27;s add a <code>suggestions</code> property that takes an <code>[KeyboardShortcutView.Pair]</code>. When a <code>Pair</code> is selected from the list, the <code>shortcut</code> property is overridden with the selected value.</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">/*@objc*/ open var suggestions: [KeyboardShortcutView.Pair] = [] {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    willSet { self.willChangeValue(forKey: #function) }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    didSet {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.didChangeValue(forKey: #function)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Now, how do we actually display the list of suggestions to the user, in-band with the control itself? <code>NSView</code> offers a <code>menu</code> property, but we can also override <code>menu(for:)</code> to return an <code>NSMenu</code> based on where the menu-opening right click occurred, specifically. Since we don&#x27;t need that level of granularity, let&#x27;s go ahead and override <code>menu</code> directly and map <code>suggestions</code> into <code>NSMenuItem</code>s. Note that to be able to manually enable or disable menu items, we should set <code>NSMenu.autoenablesItems</code> to <code>false</code>, because otherwise, <code>NSMenu</code> will validate the existence of each menu item&#x27;s <code>action</code> method existing on the item&#x27;s <code>target</code>. </p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override var menu: NSMenu? {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    get {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        let menu = NSMenu()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        menu.autoenablesItems = false</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        for (i, x) in self.suggestions.enumerated() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            let str = Localized.menuPrefix + &quot; &quot; + x.modifierFlags.characters + x.keyCode.characters</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            let item = NSMenuItem(title: str, action: #selector(self.selectAction(_:)), keyEquivalent: &quot;&quot;)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            item.tag = i</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            item.target = self</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            item.isEnabled = self.isEnabled</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            menu.addItem(item)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        return menu</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    set { }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">@objc private func selectAction(_ item: NSMenuItem) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    guard self.isEnabled else { return }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.endRecording()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.shortcut = self.suggestions[item.tag]</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>We&#x27;ve also overridden <code>menu.setter</code> to become a no-op, because we no longer want to allow a client to set a <code>menu</code> that may have no context with our control. In effect, we&#x27;re forcing our clients to use <code>suggestions</code> only. An alternative could be to override <code>menu(for:)</code> and return a new <code>NSMenu</code> with <code>self.menu.items + self.suggestions.map { $0.toMenuItem() }</code> (pseudocode). </p><p>Astute readers will spot the race condition possible with this code: <code>suggestions</code> may have been modified between <code>menu.getter</code> and <code>selectAction(_:)</code>, causing <code>self.suggestions[item.tag]</code> to become inconsistent or crash. <em>Solving this race condition is an exercise left to the reader... (I&#x27;m just using that phrase to avoid solving the problems myself aren&#x27;t I?)</em></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="undo-management">Undo Management<a class="hash-link" href="#undo-management" title="Direct link to heading">​</a></h3><p>Because macOS applications use variations of the <code>⌘Z</code> shortcut to undo or redo, it might seem a little odd to support undo management in a control that&#x27;s designed to record keyboard shortcuts themselves. However, as long as the control isn&#x27;t the first responder, the undo action will always trigger, <em>except</em> in cases where the app has registered <code>⌘Z</code> as a global shortcut (the <code>delegate</code> should ideally prevent things like that).</p><p>Adding support for undo management is actually very easy; since setting the <code>shortcut</code> property changes what the user sees, and we set this property internally in <code>performKeyEquivalent(_:)</code>, we can register our undo action there! This does have an unintended/unwanted side effect of also pushing the undo stack when the app is programmatically setting the <code>shortcut</code> value. However, I think it&#x27;s perfectly acceptable to keep a continuous undo stack between the app and user actions in this case.</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">/*@objc*/ open var shortcut: KeyboardShortcutView.Pair? {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    didSet {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.undoManager?.registerUndo(withTarget: self) { [oldValue] _ in</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            self.shortcut = oldValue</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.setActionName(Localized.actionName)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Each <code>NSResponder</code> has an <code>undoManager</code> that we can just register the undo action with -- an undo action takes <code>self</code> as the target, with a handler to execute when the user un-does the current action. Notice that we capture <code>oldValue</code> at registration-time, instead of invocation-time: this is so we don&#x27;t set the undone <code>shortcut</code> value to itself accidentally.</p><p>Running an application with an existing saved state, we&#x27;ll notice an unusual glitch: it appears that even though the app was just launched (and restored its state), the user sees an undo action, even though they haven&#x27;t interacted with the control yet! This is because the one edge-case we need to control in setting the <code>shortcut</code> property is the initializer(s) setting it. A <code>Swift</code> initializer does not invoke any property observers when a member&#x27;s value is set, <strong>however</strong>, <code>restoreState(_:)</code> is not an initializer! It&#x27;s a normal method, and thus, will invoke the <code>didSet</code>, which is harmless, except for this particular side effect. The solution is to only register an action with the undo manager if we aren&#x27;t restoring state.</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">/*@objc*/ open var shortcut: KeyboardShortcutView.Pair? {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    didSet {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        if !self.isRestoringState {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            self.undoManager?.registerUndo(withTarget: self) { [oldValue] _ in</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                self.shortcut = oldValue</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            self.setActionName(Localized.actionName)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">// ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">private var isRestoringState: Bool = false</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">open override func restoreState(with coder: NSCoder) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.isRestoringState = true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    defer {self.isRestoringState = false }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Now, running the app from an existing saved state won&#x27;t cause unexpected undo actions to register! The astute reader will also observe that we could just flip the condition on <code>isRestoringState</code>, calling the boolean <code>shouldRegisterUndo</code>, and only enable it during <code>performKeyEquivalent(_:)</code>. That&#x27;s a perfectly fine solution as well, depending on what undo registration behavior you want to achieve.</p><p>What about redo actions? We&#x27;ve only set up undo actions: if the user types <code>⌘L</code> and then undoes the action, how do we allow the user to redo that (that is, set the shortcut again to <code>⌘L</code>)? It turns out that <code>UndoManager</code> handles this logic already, and if we&#x27;re currently executing the registered undo action&#x27;s handler, <code>isUndoing</code> is <code>true</code>, and the &quot;undo action of the undo action&quot; is translated into a &quot;redo action&quot; for us. We&#x27;re all done here!</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="conclusion">Conclusion<a class="hash-link" href="#conclusion" title="Direct link to heading">​</a></h2><p>With that, we&#x27;ve completely designed and implemented a keyboard shortcut recording control, following correct practice and masquerading as a first class AppKit citizen! If you have any questions, comments, or concerns, contact me on Twitter or Github @avaidyam!</p></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Blog post page navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/blog/2019/02/19/"><div class="pagination-nav__sublabel">Newer Post</div><div class="pagination-nav__label">DIY: Core Animation</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/blog/2018/03/16/"><div class="pagination-nav__sublabel">Older Post</div><div class="pagination-nav__label">Building a Better RegisterEventHotKey</div></a></nav></main><div class="col col--2"><div class="tableOfContents_bqdL thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#principles-of-modern-views" class="table-of-contents__link toc-highlight">Principles of Modern Views</a><ul><li><a href="#subclassing-a-view-or-a-viewcontroller" class="table-of-contents__link toc-highlight">Subclassing a <code>View</code> or a <code>ViewController</code></a></li><li><a href="#layers" class="table-of-contents__link toc-highlight">Layers</a></li><li><a href="#nscontrol" class="table-of-contents__link toc-highlight"><code>NSControl</code>?</a></li></ul></li><li><a href="#working-with-cgskeyboardshortcut" class="table-of-contents__link toc-highlight">Working With <code>CGSKeyboardShortcut</code></a><ul><li><a href="#human-readable-string-representation" class="table-of-contents__link toc-highlight">Human-Readable String Representation</a></li><li><a href="#a-simpler-shortcut-representation" class="table-of-contents__link toc-highlight">A Simpler Shortcut Representation</a></li></ul></li><li><a href="#being-a-good-citizen" class="table-of-contents__link toc-highlight">Being A Good Citizen</a><ul><li><a href="#accepting-key-view" class="table-of-contents__link toc-highlight">Accepting Key View</a></li><li><a href="#responding-to-user-input" class="table-of-contents__link toc-highlight">Responding to User Input</a></li><li><a href="#updatelayer" class="table-of-contents__link toc-highlight"><code>updateLayer</code></a></li><li><a href="#drawing-a-button-without-being-one" class="table-of-contents__link toc-highlight">Drawing a Button Without Being One</a></li><li><a href="#focus-rings" class="table-of-contents__link toc-highlight">Focus Rings</a></li><li><a href="#layout-updateconstraints--intrinsiccontentsize" class="table-of-contents__link toc-highlight"><code>layout</code>, <code>updateConstraints</code>, &amp; <code>intrinsicContentSize</code></a></li><li><a href="#hover--cursors" class="table-of-contents__link toc-highlight">Hover &amp; Cursors</a></li><li><a href="#haptic--audio-feedback" class="table-of-contents__link toc-highlight">Haptic &amp; Audio Feedback</a></li><li><a href="#window-keyedness" class="table-of-contents__link toc-highlight">Window Keyedness</a></li><li><a href="#global-hotkey-interference" class="table-of-contents__link toc-highlight">Global HotKey Interference</a></li><li><a href="#string-localization" class="table-of-contents__link toc-highlight">String Localization</a></li><li><a href="#accessibility" class="table-of-contents__link toc-highlight">Accessibility</a></li><li><a href="#nscoding--state-restoration" class="table-of-contents__link toc-highlight"><code>NSCoding</code> &amp; State Restoration</a></li><li><a href="#context-nsmenu-popups" class="table-of-contents__link toc-highlight">Context <code>NSMenu</code> Popups</a></li><li><a href="#undo-management" class="table-of-contents__link toc-highlight">Undo Management</a></li></ul></li><li><a href="#conclusion" class="table-of-contents__link toc-highlight">Conclusion</a></li></ul></div></div></div></div></div></div>
<script src="/assets/js/runtime~main.93e70d6f.js"></script>
<script src="/assets/js/main.2cfa5855.js"></script>
</body>
</html>