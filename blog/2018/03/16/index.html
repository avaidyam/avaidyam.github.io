<!doctype html>
<html lang="en" dir="ltr" class="blog-wrapper blog-post-page plugin-blog plugin-id-default">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.4.1">
<title data-rh="true">Building a Better RegisterEventHotKey | Aditya Vaidyam</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://aditya.vaidyam.me/logo.png"><meta data-rh="true" name="twitter:image" content="https://aditya.vaidyam.me/logo.png"><meta data-rh="true" property="og:url" content="https://aditya.vaidyam.me/blog/2018/03/16/"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><meta data-rh="true" property="og:title" content="Building a Better RegisterEventHotKey | Aditya Vaidyam"><meta data-rh="true" name="description" content="Okay, well, maybe not better, but at least, not under imminent threat of deprecation - and even that is questionable, because we&#x27;ll be using [Private SPI] (I mean, would you really be here reading this if it didn&#x27;t? At least I&#x27;ve marked it all so you can cut it out for MAS apps.)"><meta data-rh="true" property="og:description" content="Okay, well, maybe not better, but at least, not under imminent threat of deprecation - and even that is questionable, because we&#x27;ll be using [Private SPI] (I mean, would you really be here reading this if it didn&#x27;t? At least I&#x27;ve marked it all so you can cut it out for MAS apps.)"><meta data-rh="true" property="og:type" content="article"><meta data-rh="true" property="article:published_time" content="2018-03-16T00:00:00.000Z"><link data-rh="true" rel="icon" href="/photo.png"><link data-rh="true" rel="canonical" href="https://aditya.vaidyam.me/blog/2018/03/16/"><link data-rh="true" rel="alternate" href="https://aditya.vaidyam.me/blog/2018/03/16/" hreflang="en"><link data-rh="true" rel="alternate" href="https://aditya.vaidyam.me/blog/2018/03/16/" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Aditya Vaidyam RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Aditya Vaidyam Atom Feed">
<link rel="alternate" type="application/json" href="/blog/feed.json" title="Aditya Vaidyam JSON Feed"><link rel="stylesheet" href="/assets/css/styles.cce51416.css">
<link rel="preload" href="/assets/js/runtime~main.4118853a.js" as="script">
<link rel="preload" href="/assets/js/main.2f45d6ae.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}return t}()||function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><b class="navbar__title text--truncate">Aditya Vaidyam</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a aria-current="page" class="navbar__link active" aria-haspopup="true" aria-expanded="false" role="button" href="/">Contact</a><ul class="dropdown__menu"><li><a href="mailto:aditya@vaidyam.me" target="_blank" rel="noopener noreferrer" class="dropdown__link">Send an Email</a></li><li><a href="https://calendly.com/avaidyam/meet" target="_blank" rel="noopener noreferrer" class="dropdown__link">Schedule a Meeting</a></li></ul></div><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="Blog recent posts navigation"><div class="sidebarItemTitle_pO2u margin-bottom--md">All posts</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2019/06/02/">On the debate of iOS vs. macOS</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2019/02/19/">DIY: Core Animation</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2018/03/22/">An Exercise in Modern Cocoa Views</a></li><li class="sidebarItem__DBe"><a aria-current="page" class="sidebarItemLink_mo7H sidebarItemLinkActive_I1ZP" href="/blog/2018/03/16/">Building a Better RegisterEventHotKey</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2018/02/22/">The Secret Life of Core Animation</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2018/02/19/">CAStateController &amp; Friends</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2018/02/18/">CAPortalLayer</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2018/02/17/">CAPluginLayer &amp; CABackdropLayer</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2017/10/01/">ViewBridge.framework: It works!</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2016/08/05/">Picture-in-Picture on macOS Sierra</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2016/07/12/">NSExtension  &amp; PlugInKit</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h1 class="title_f1Hy" itemprop="headline">Building a Better RegisterEventHotKey</h1><div class="container_mt6G margin-vert--md"><time datetime="2018-03-16T00:00:00.000Z" itemprop="datePublished">March 16, 2018</time> · <!-- -->17 min read</div></header><div id="__blog-post-container" class="markdown" itemprop="articleBody"><p>Okay, well, maybe not better, but at least, not under imminent threat of deprecation - and even that is questionable, because we&#x27;ll be using <code>[Private SPI]</code> (I mean, would you really be here reading this if it didn&#x27;t? At least I&#x27;ve marked it all so you can cut it out for MAS apps.)</p><p>Recently, I&#x27;ve wanted to get around to adding &quot;hot key&quot; support for Parrot, and realized I didn&#x27;t like any of the existing solutions:</p><ol><li>Use <code>MASShortcut</code> or <code>ShortcutRecorder</code> which are tried and proven to work in ObjC-land.</li><li>Use a new but not proven Swift hotkey recorder (there&#x27;s a few out there).</li><li>Roll my own using dangerous private SPI and not test it at all! </li></ol><p><em>Obviously I went with option #3.</em> </p><p>I ended up building a µFramework (everything these days is one, right?) that handles hotkeys, provides a user input and display for hotkeys, and a small high-level recognizer platform to handle them with ease. I&#x27;ll walk you, the reader, through each step! But first, I want to clarify something: the terms &quot;hot key&quot;, &quot;key equivalent&quot;, &quot;keyboard shortcut&quot;, and &quot;mnemonic&quot; are not the same things, on the same or different (i.e. macOS vs Windows) platforms, and so here, I&#x27;ve chosen &quot;keyboard shortcut&quot; as the most descriptive term. </p><p>Before we get into the nitty gritty hand-holding pair-programming stuff, if you&#x27;d like to jump straight to the comment-annotated final source code, <a href="https://gist.github.com/avaidyam/32975976c23dd3b38336f22d971f5eaa" target="_blank" rel="noopener noreferrer">I&#x27;ve included a snapshot here.</a> It&#x27;s the whole final product, exactly 1500 LOC, including the code from the next &quot;episode&quot; - a corresponding keyboard shortcut recording control! If you think this should be a formal repository and whatnot, contact me on Twitter or Github @avaidyam!</p><hr><h2 class="anchor anchorWithStickyNavbar_LWe7" id="how-does-registereventhotkey-work">How does <code>RegisterEventHotKey</code> work?<a href="#how-does-registereventhotkey-work" class="hash-link" aria-label="Direct link to how-does-registereventhotkey-work" title="Direct link to how-does-registereventhotkey-work">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="disassembly--reverse-engineering">Disassembly &amp; Reverse Engineering<a href="#disassembly--reverse-engineering" class="hash-link" aria-label="Direct link to Disassembly &amp; Reverse Engineering" title="Direct link to Disassembly &amp; Reverse Engineering">​</a></h3><p>The first step to designing a better <code>X</code> is to understand how <code>X</code> works. To do that, whip out <code>Hopper</code> (I&#x27;m not paid to say this but if you don&#x27;t have this app yet, you definitely need it!) and disassemble <code>/System/Library/Carbon.framework/Frameworks/HIToolbox.framework</code>. Locate the function and take a peek -- or, if you&#x27;d like, <a href="https://gist.github.com/avaidyam/18b7c3d0a15afade931d10a27ed53872" target="_blank" rel="noopener noreferrer">just take a look at my cleaned up version of the function here.</a> I also added a similar function from <code>ScreenReader.framework</code> to cross-reference with.</p><p>All the function basically does is wrap its parameters into an internal data type and call through to <code>SkyLight.framework</code> (you may know it as <code>CoreGraphicsServices</code>, from <code>CoreGraphics.framework</code> on pre-macOS 12) while keeping track of the hotkey registration in a static var dictionary. I&#x27;ll come back to the CoreGraphics call in a little bit, because this function does something very interesting... we&#x27;ll also ignore the <code>CGSSetHotButtonWithExclusion</code> call, which is actually an alias for the function <code>CGSSetHotKeyRepresentationWithOptions</code>, because that&#x27;s not what we want right now. We&#x27;ll instead be using <code>CGSSetHotKeyWithExclusion</code>. </p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="cgshotkey-symbols">CGSHotKey Symbols<a href="#cgshotkey-symbols" class="hash-link" aria-label="Direct link to CGSHotKey Symbols" title="Direct link to CGSHotKey Symbols">​</a></h3><p>Here&#x27;s a complete list of <code>CGSHot*</code> symbols:</p><ul><li><code>CGSGetHotButton</code></li><li><code>CGSGetHotKeyRepresentation</code></li><li><code>CGSGetHotKeyType</code></li><li><code>CGSGetHotModifier</code></li><li><code>CGSSetHotButtonWithExclusion</code></li><li><code>CGSSetHotKeyEnabled</code></li><li><code>CGSSetHotKeyRepresentation</code></li><li><code>CGSSetHotKeyRepresentationWithOptions</code></li><li><code>CGSSetHotKeyType</code></li><li><code>CGSSetHotKeyWithExclusion</code></li><li><code>CGSSetHotKeyWithOptions</code></li><li><code>CGSSetHotModifierWithExclusion</code></li><li><code>CGSSetHotModifierWithOptions</code></li><li><code>CGSGetSymbolicHotKeyButtonValue</code></li><li><code>CGSGetSymbolicHotKeyRepresentation</code></li><li><code>CGSGetSymbolicHotKeyRepresentationList</code></li><li><code>CGSGetSymbolicHotKeyValuesAndStates</code></li><li><code>CGSGetSymbolicHotModifierValue</code></li><li><code>CGSSetSymbolicHotKey</code></li><li><code>CGSSetSymbolicHotKeyButtonValue</code></li><li><code>CGSSetSymbolicHotKeyEnabledForConnection</code></li><li><code>CGSSetSymbolicHotKeyRepresentation</code></li><li><code>CGSSetSymbolicHotKeyValue</code></li><li><code>CGSSetSymbolicHotKeyWithExclusion</code></li><li><code>CGSSetSymbolicHotKeyWithOptions</code></li><li><code>CGSSetSymbolicHotModifierValue</code></li><li><code>CGSIsSymbolicHotKeyEnabledForConnection</code></li></ul><p>I&#x27;ll demystify some of these symbols: there are two types of &quot;hot&quot; events: <strong>regular</strong>, and <strong>symbolic</strong>. Symbolic hot events are those that the <code>WindowServer</code> has designated and named. <a href="https://github.com/NUIKit/CGSInternal/blob/master/CGSHotKeys.h#L38" target="_blank" rel="noopener noreferrer">You can find a near-full list of symbolic identifiers here.</a> These include things like Exposé or Screenshot keys, basically those that are defined in the &quot;System Preferences &gt; Keyboard &gt; Shortcut&quot; pane. </p><p>Now, within these types, there are subtypes: <code>HotKey</code>, <code>HotButton</code>, <code>HotModifier</code>, and <code>HotKeyRepresentation</code>. <code>HotButton</code> is actually just an alias for <code>HotKeyRepresentation</code>, which I&#x27;ll admit, I&#x27;m not savvy to the reason behind its specific distinction. <code>HotModifier</code> is just that -- a modifier press that activates an event, like Siri or Dictation shortcuts. Finally, what we want, is the <code>HotKey</code> facility, which is a plain old keyboard shortcut, with a virtual key code, and a modifier list. </p><p>There is a special <code>WithExclusion</code> function, which calls through to <code>WithOptions</code> (presumably, there are more options, but I doubt any are used right now): setting a hot key with exclusion implies that no other application (including the calling one) may register this same hot key again, and if it was already acquired by another application, the call fails. As far as I&#x27;m able to tell, this is the behavior, but I can&#x27;t be sure since I haven&#x27;t dug deeper into this option.</p><hr><h2 class="anchor anchorWithStickyNavbar_LWe7" id="building-a-replacement-cgskeyboardshortcut">Building a replacement: <code>CGSKeyboardShortcut</code>!<a href="#building-a-replacement-cgskeyboardshortcut" class="hash-link" aria-label="Direct link to building-a-replacement-cgskeyboardshortcut" title="Direct link to building-a-replacement-cgskeyboardshortcut">​</a></h2><p>Since we&#x27;ve got a cursory understanding of how the existing Carbon facility works, and what hot events facilities Window Server offers, we can architect our own version. </p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">public final class CGSKeyboardShortcut: Hashable {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="properties--acquisition-policy">Properties &amp; Acquisition Policy<a href="#properties--acquisition-policy" class="hash-link" aria-label="Direct link to Properties &amp; Acquisition Policy" title="Direct link to Properties &amp; Acquisition Policy">​</a></h3><p>A keyboard shortcut needs a virtual key code (<code>CGKeyCode</code>), modifier flags (<code>CGEventFlags</code>, instead of <code>NSEvent.ModifierFlags</code>), and an identifier (we&#x27;ll create a intly-typed wrapper, for better developer&amp;user-side management), at the very least.</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">public struct Identifier: RawRepresentable, Hashable, Codable {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public typealias RawValue = Int</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public let rawValue: Identifier.RawValue</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public init(rawValue: Identifier.RawValue) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.rawValue = rawValue</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public init(_ rawValue: Identifier.RawValue) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.rawValue = rawValue</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public let identifier: CGSKeyboardShortcut.Identifier</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public let keyCode: CGKeyCode</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public let modifierFlags: CGEventFlags</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Now, returning to the issue of <code>WithExclusion</code>, we&#x27;ll also add an <code>AcquisitionPolicy</code> to handle that:</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">public enum AcquisitionPolicy: Int, Codable {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    case none</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    case exclusively</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    case exclusivelyIfPossible</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public let acquisitionPolicy: AcquisitionPolicy</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public init(identifier: CGSKeyboardShortcut.Identifier, keyCode: CGKeyCode,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">       modifierFlags: CGEventFlags, acquisitionPolicy: AcquisitionPolicy = .none) throws</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">{</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.identifier = identifier</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.keyCode = keyCode</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.modifierFlags = modifierFlags</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.acquisitionPolicy = acquisitionPolicy</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Essentially, this will be the policy to use when initializing a new <code>CGSKeyboardShortcut</code> - do we want to do so <code>exclusively</code>, not (<code>none</code>) at all, or maybe <code>exclusivelyIfPossible</code>? The final option is a special case where we&#x27;ll attempt to be exclusive, but if someone else got to the shortcut first, we still do want a shortcut event delivered to our handler. (Note that we shouldn&#x27;t be considering this value in equality between two <code>CGSKeyboardShortcut</code>s.)</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="resource-management">Resource Management<a href="#resource-management" class="hash-link" aria-label="Direct link to Resource Management" title="Direct link to Resource Management">​</a></h3><p>Since keyboard shortcuts are something of a finite resource (there are only so many key combinations viable for user input) and application or component acquisition matters, we&#x27;ll keep a <code>Set</code> of registered keyboard shortcuts at all times, but note that we can only keep track of the shortcuts tracked through our new facility, and not those by <code>CGS</code> or <code>HIToolbox</code> facilities, unfortunately.</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">public private(set) static var all: Set&lt;CGSKeyboardShortcut&gt; = []</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public init(...) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    guard CGSKeyboardShortcut.all.filter({ $0.identifier == identifier }).count == 0 else {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        throw CGError.cannotComplete</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    CGSKeyboardShortcut.all.insert(self)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">deinit {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    CGSKeyboardShortcut.all.remove(self)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>There is an issue with this mechanism as it stands, though. If we&#x27;d like to invalidate a keyboard shortcut, we have no way of <code>deinit</code>ing it without removing it from the <code>Set</code>, which only happens upon <code>deinit</code>! That&#x27;s a problem, so we&#x27;ll add an explicit <code>invalidate</code> method (or two).</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">deinit {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.invalidate()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public func invalidate() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    CGSKeyboardShortcut.all.remove(self)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public static func invalidateAll() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    CGSKeyboardShortcut.all = []</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>There, that&#x27;s a little better. Now, we don&#x27;t need to hold an explicit reference to a shortcut to keep it valid, and we&#x27;ll need this <code>Set</code> for actually handling shortcuts soon anyway. </p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="windowserver-acquisition--invalidation">WindowServer Acquisition &amp; Invalidation<a href="#windowserver-acquisition--invalidation" class="hash-link" aria-label="Direct link to WindowServer Acquisition &amp; Invalidation" title="Direct link to WindowServer Acquisition &amp; Invalidation">​</a></h3><p>Now that we&#x27;ve defined our shortcut class and its containment/usage policies, how do we actually... you know, make it do stuff? For that, we&#x27;ll need to add a suffix to our file here:</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">// Here lie dragons!</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">fileprivate typealias CGSConnectionID = UInt</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">@_silgen_name(&quot;CGSMainConnectionID&quot;)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">fileprivate func CGSMainConnectionID() -&gt; CGSConnectionID</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">@_silgen_name(&quot;CGSSetHotKeyWithExclusion&quot;)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">fileprivate func CGSSetHotKeyWithExclusion(_ connection: CGSConnectionID,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                                           _ hotKeyID: Int,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                                           _ hotKeyMask: UInt16, // always 0xffff</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                                           _ keyCode: UInt16,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                                           _ modifierFlags: UInt64,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                                           _ options: Int8) -&gt; CGError</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">@_silgen_name(&quot;CGSSetHotKeyType&quot;)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">fileprivate func CGSSetHotKeyType(_ connection: CGSConnectionID,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                                  _ hotKeyID: Int,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                                  _ options: Int8) -&gt; CGError</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">@_silgen_name(&quot;CGSSetHotKeyEnabled&quot;)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">fileprivate func CGSSetHotKeyEnabled(_ connection: CGSConnectionID,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                                     _ hotKeyID: Int,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                                     _ enabled: Bool) -&gt; CGError</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">@_silgen_name(&quot;CGSIsHotKeyEnabled&quot;)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">fileprivate func CGSIsHotKeyEnabled(_ connection: CGSConnectionID,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                                    _ hotKeyID: Int) -&gt; Bool</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">@_silgen_name(&quot;CGSRemoveHotKey&quot;)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">fileprivate func CGSRemoveHotKey(_ connection: CGSConnectionID,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                                 _ hotKeyID: Int) -&gt; CGError</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This is a horrible terrible idea. But then again, you&#x27;ve read this much already, so you&#x27;re probably okay with this sick twisted kind of stuff. :)  After elucidating the function arguments, we&#x27;re using <code>@_silgen_name</code> to tell the Swift compiler that &quot;hey, these functions exist somewhere, so just go along with my devious plans&quot;. Obviously, if anything goes wrong, you&#x27;re on your own. Be careful with this block of code. </p><p>Now we&#x27;ll register and unregister the shortcut where necessary, and add a way to enable or disable the shortcut (since <code>WindowServer</code> allows us this functionality).</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public var isEnabled: Bool {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    get { return CGSIsHotKeyEnabled(CGSMainConnectionID(), self.identifier.rawValue) }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    set { _ = CGSSetHotKeyEnabled(CGSMainConnectionID(), self.identifier.rawValue, newValue) }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public init(...) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    var error: CGError = .success</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    error = CGSSetHotKeyWithExclusion(CGSMainConnectionID(), self.identifier.rawValue,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                                      0xffff, self.keyCode, self.modifierFlags.rawValue,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                                      self.acquisitionPolicy == .none ? 0x0 : 0x1)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // If our acquisition policy can fallback, register non-exclusively.</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    if error == .noneAvailable &amp;&amp; self.acquisitionPolicy == .exclusivelyIfPossible {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        error = CGSSetHotKeyWithExclusion(CGSMainConnectionID(), self.identifier.rawValue,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                                          0xffff, self.keyCode, self.modifierFlags.rawValue, 0x0)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    guard error == .success else { throw error }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    error = CGSSetHotKeyType(CGSMainConnectionID(), self.identifier.rawValue, 0x1)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    guard error == .success else { throw error }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public func invalidate() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    _ = CGSRemoveHotKey(CGSMainConnectionID(), self.identifier.rawValue)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="local-event-handling">Local Event Handling<a href="#local-event-handling" class="hash-link" aria-label="Direct link to Local Event Handling" title="Direct link to Local Event Handling">​</a></h3><p>Alright, now we&#x27;ve got a functioning shortcut right? Not yet! We actually need to get <code>WindowServer</code> to send <strong>us</strong> specifically the event for the shortcut! However, (it turns out, in macOS 6+) <code>NSApplication</code> actually handles these kinds of events in <code>-sendEvent:</code>, but we need to register an event monitor to be notified of them. Let&#x27;s use a local <code>NSEvent</code> monitor to trampoline notifications into <code>NotificationCenter</code>.</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">public static let pressedNotification = Notification.Name(&quot;CGSKeyboardShortcut.pressedNotification&quot;)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public static let releasedNotification = Notification.Name(&quot;CGSKeyboardShortcut.releasedNotification&quot;)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">private static var monitor = NSEvent.addLocalMonitorForEvents(matching: .systemDefined) { event in</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    if [6, 9].contains(event.subtype.rawValue) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        CGSKeyboardShortcut.all.filter { $0.identifier.rawValue == event.data1 }.forEach { obj in</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            let name: Notification.Name = event.subtype.rawValue == 6</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                ? CGSKeyboardShortcut.pressedNotification /* 6 */</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                : CGSKeyboardShortcut.releasedNotification /* 9 */</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            NotificationCenter.default.post(name: name, object: obj)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        return nil // consumed</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return event</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public init(...) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    _ = CGSKeyboardShortcut.monitor // bootstrap!</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>All we&#x27;ve done here is grab the shortcut identifier from the <code>data1</code> field of the <code>.systemDefined</code> event if it&#x27;s of <code>subtype</code> <code>6</code> or <code>9</code>, which are the <code>-keyDown:</code> and <code>-keyUp:</code> event subtypes, respectively. Once we&#x27;ve done so, and our facility registered the shortcut (that is, not Carbon or another CGS client), bounce the event into a notification. Be sure to &quot;bootstrap&quot; the event monitor in your <code>init</code>, otherwise it&#x27;ll never be initialized and trampoline shortcut events.</p><p>Here, I&#x27;ve explicitly chosen to use <code>NotificationCenter</code> over a delegation or target-action/handler pattern, because it turns a single-producer (the user input) single-consumer (portions of our app) model into a single-producer multiple-consumer pattern. With a single shortcut registration, multiple components can share event information. If we wanted a shortcut to be exclusive to the app, but multiple components acted on it, we would either end up in a hairy mess or end up using <code>NotificationCenter</code> anyway. </p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="the-magic-within-registereventhotkey">The Magic Within <code>RegisterEventHotKey</code><a href="#the-magic-within-registereventhotkey" class="hash-link" aria-label="Direct link to the-magic-within-registereventhotkey" title="Direct link to the-magic-within-registereventhotkey">​</a></h3><p>Remember how earlier, I said <code>RegisterEventHotKey</code> was doing something interesting? It <code>malloc</code>&#x27;s what I&#x27;m dubbing a <code>HotButtonData</code> to hold hot key parameters (presumably) and uses its pointer as the hot key identifier! Holy carp, that&#x27;s insanely bad practice! It is, however, an extremely intelligent alternative to our global <code>Set</code>. That was really it. I found it pretty interesting, and I&#x27;m not even really sure if that was developer-intended or a compiler optimization/mangling of some sort. :)</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="frozen-representations">Frozen Representations<a href="#frozen-representations" class="hash-link" aria-label="Direct link to Frozen Representations" title="Direct link to Frozen Representations">​</a></h3><p>While we&#x27;ve now built a complete and functional shortcut facility, we have no way of storing a shortcut in a non-live, or frozen, way. We could make our class <code>Codable</code>, our initializer is where shortcut registration occurs, and invoking a <code>Codable</code> initializer should not have any side effects. Instead, I&#x27;ve opted for a design that mirrors only the internal properties of the shortcut class but with no activity of its own, called <code>CGSKeyboardShortcut.Definition</code>. It&#x27;s effectively a frozen version of a <code>CGSKeyboardShortcut</code>, and we can use this type to inform the client of our class that explicit initialization is required. While there may be better approaches to this problem, I feel that this solution separates the notion of a live shortcut and a frozen one pretty cleanly.</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">public struct Definition: Hashable, Codable {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public let identifier: CGSKeyboardShortcut.Identifier</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public let keyCode: CGKeyCode</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public let modifierFlags: CGEventFlags</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public let acquisitionPolicy: AcquisitionPolicy</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public init(identifier: CGSKeyboardShortcut.Identifier, keyCode: CGKeyCode, modifierFlags: CGEventFlags, acquisitionPolicy: AcquisitionPolicy) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.identifier = identifier</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.keyCode = keyCode</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.modifierFlags = modifierFlags</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.acquisitionPolicy = acquisitionPolicy</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public convenience init(definition: Definition) throws {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    try self.init(identifier: definition.identifier, keyCode: definition.keyCode,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                  modifierFlags: definition.modifierFlags,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                  acquisitionPolicy: definition.acquisitionPolicy)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public var definition: Definition {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return Definition(identifier: self.identifier, keyCode: self.keyCode,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                      modifierFlags: self.modifierFlags,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                      acquisitionPolicy: self.acquisitionPolicy)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="cgkeycode--cgeventflags-supplements">CGKeyCode &amp; CGEventFlags Supplements<a href="#cgkeycode--cgeventflags-supplements" class="hash-link" aria-label="Direct link to CGKeyCode &amp; CGEventFlags Supplements" title="Direct link to CGKeyCode &amp; CGEventFlags Supplements">​</a></h3><p>Finally, we&#x27;re not out of the woods yet. There&#x27;s a slight issue with registering a shortcut with any old <code>NSEvent</code>-provided modifier flags - only a few flag bits are allowed (the physical key modifer ones)! Modify the line in <code>init(...) { ... }</code> that reads <code>self.modifierFlags = modifierFlags</code> to <code>self.modifierFlags = modifierFlags.intersection(.maskShortcutFlags)</code>. We&#x27;ll define a few extensions to <code>CGEventFlags</code> to support this, and to allow conversion between <code>NSEvent.ModifierFlags</code>. In addition, we&#x27;ll conform <code>CGError</code> to <code>Error</code> since it&#x27;s not already for some reason...</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">extension CGError: Error {}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">extension CGEventFlags: Hashable, Codable {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public var hashValue: Int { return self.rawValue.hashValue }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public extension CGEventFlags {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public init(_ flags: NSEvent.ModifierFlags) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.init(rawValue: UInt64(flags.rawValue))</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public static let maskDeviceIndependentFlags = CGEventFlags(rawValue: 0x00000000ffff0000)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public static let maskShortcutFlags = CGEventFlags(rawValue: 0x0000000000ff0000)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public static let maskUserFlags: CGEventFlags = [.maskCommand, .maskControl, .maskShift, .maskAlternate]</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public extension NSEvent.ModifierFlags {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public init(_ flags: CGEventFlags) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.init(rawValue: UInt(flags.rawValue))</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><hr><h2 class="anchor anchorWithStickyNavbar_LWe7" id="building-higher-order-recognizers">Building Higher-Order Recognizers<a href="#building-higher-order-recognizers" class="hash-link" aria-label="Direct link to Building Higher-Order Recognizers" title="Direct link to Building Higher-Order Recognizers">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="why">Why?<a href="#why" class="hash-link" aria-label="Direct link to Why?" title="Direct link to Why?">​</a></h3><p>Realistically, a developer could use the <code>CGSKeyboardShortcut</code> class as is and be perfectly fine! It does everything, after all, from maintaining the shortcut list, to trampolining events into notifications, and more. However, building &quot;higher-order&quot; facilities to handle complex interactions is well worth it, even if it means a little more code to accomplish the simple use-case (because remember, we&#x27;re not removing the original facility, only building atop it). Let&#x27;s define a <code>ShortcutRecognizer</code> protocol that takes two inputs: <code>keyDown</code> and <code>keyUp</code>, but does not provide a standard output. It&#x27;ll be up to our implementing classes to do that.</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">public protocol ShortcutRecognizer: class {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    func keyDown()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    func keyUp()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>So what would handling a shortcut, the normal way, look like with this protocol?</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">public final class PressShortcutRecognizer: ShortcutRecognizer {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public let handler: () -&gt; ()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public init(_ handler: @escaping () -&gt; ()) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.handler = handler</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public func keyDown() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        /// ignored!</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public func keyUp() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.handler()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Ugh, that&#x27;s like, 10 extra lines of code and another class to deal with! But that&#x27;s not the point! We&#x27;ve written something that doesn&#x27;t actually rely on <code>CGS</code> facilities or even our <code>CGSKeyboardShortcut</code> facility! We don&#x27;t even need to use this for shortcuts! It can do anything! (Maybe limiting its scope is a good thing to do though...) </p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="how">How?<a href="#how" class="hash-link" aria-label="Direct link to How?" title="Direct link to How?">​</a></h3><p>Okay, but the whole point of a recognizer type was to be able to simplify complex interactions, so how about this, an action in my app requires the user to do this exact sequence:  <code>keyDown</code> -&gt; <code>keyUp</code> -&gt; <code>keyDown</code> within 1sec -&gt; <code>keyUp</code> after 2sec. </p><p>It&#x27;ll be a <code>TapHoldShortcutRecognizer</code> with a variable hold duration:</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">public final class TapHoldShortcutRecognizer: ShortcutRecognizer {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    private var timeInterval = DispatchTimeInterval.seconds(0)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public let handler: () -&gt; ()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public init(for t: DispatchTimeInterval = .seconds(2), _ handler: @escaping () -&gt; ()) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.timeInterval = t</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.handler = handler</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public func keyDown() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public func keyUp() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Since we actually never need to handle the first <code>keyUp</code>, let&#x27;s handle the double <code>keyDown</code> first, using a bool as well as a time marker, to maintain the inter-<code>keyDown</code> and hold durations. </p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">private var timeReference: CFAbsoluteTime = 0.0</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">private var inDoubleTap = false</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public func keyDown() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    defer { self.timeReference = CFAbsoluteTimeGetCurrent() }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    guard CFAbsoluteTimeGetCurrent() - self.timeReference &lt; 1.0 else { return } // double-tapped</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.inDoubleTap = true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    DispatchQueue.main.asyncAfter(deadline: .now() + self.timeInterval) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        // ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>We&#x27;ve put the time tracking in a <code>defer { ... }</code> statement because we want it execute only after the method has finished processing; it&#x27;s just a marker of when we noticed the <code>keyDown</code>, after all. This way, our <code>guard</code> statement isn&#x27;t affected either, and we can ignore the inter-<code>keyDown</code> interval. Notice that we&#x27;re only using <code>DispatchTimeInterval</code> for the hold duration, to play nice with <code>DispatchQueue.asyncAfter(...)</code>. Once we enter the hold phase (that is, <code>keyDown</code> -&gt; <code>keyUp</code> -&gt; <code>keyDown</code> within 1sec -&gt; ...), we can defer to the <code>keyUp()</code> function.</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">// ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    DispatchQueue.main.asyncAfter(deadline: .now() + self.timeInterval) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        guard self.inDoubleTap else { return }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.inDoubleTap = false</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        DispatchQueue.main.async(execute: self.handler)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public func keyUp() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    guard self.inDoubleTap else { return }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    self.inDoubleTap = false</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    print(&quot;shortcut recognizer failed because hold duration was \(CFAbsoluteTimeGetCurrent() - self.timeReference)s&quot;)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>For the hold phase, we essentially race the user input to our designated hold duration: if the user gets there first (pressing the shortcut before the hold duration is up), we unset the double tap flag and bail our handler execution. Our inter-<code>keyDown</code> phase waited on the user to fail to <code>keyUp</code> so it could invoke the handler when we reached our hold duration. Clever, but there&#x27;s probably a design pattern or something for this.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="binding-to-a-cgskeyboardshortcut">Binding to a <code>CGSKeyboardShortcut</code><a href="#binding-to-a-cgskeyboardshortcut" class="hash-link" aria-label="Direct link to binding-to-a-cgskeyboardshortcut" title="Direct link to binding-to-a-cgskeyboardshortcut">​</a></h3><p>It&#x27;s now pretty simple to create a binder between a recognizer and a <code>CGSKeyboardShortcut</code>, by just adding the recognizer as an observer of... two... notifications... that&#x27;s a little bit unwieldy. Instead, we can add a convenience function to add observers for both notifications and then return a single disposable value. If that value is <code>deinit</code>&#x27;ed, both observers are invalidated and the recognizer is effectively unbound! It&#x27;s pretty straightforward.</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">public extension ShortcutRecognizer {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public func bind(to shortcut: CGSKeyboardShortcut) -&gt; Any {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        let x = NotificationCenter.default.addObserver(forName: CGSKeyboardShortcut.pressedNotification, object: shortcut, queue: nil) { _ in</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            self.keyDown()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        let y = NotificationCenter.default.addObserver(forName: CGSKeyboardShortcut.releasedNotification, object: shortcut, queue: nil) { _ in</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            self.keyUp()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        return _Holder([x, y])</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">// Implementation Detail:</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">class _Holder {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    private let observers: [Any]</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public init(_ observers: [Any]) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.observers = observers</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="sample-usage">Sample Usage<a href="#sample-usage" class="hash-link" aria-label="Direct link to Sample Usage" title="Direct link to Sample Usage">​</a></h3><p>Complex user shortcut interaction becomes much cleaner now! Here&#x27;s how we can use all of this together:</p><div class="language-swift codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-swift codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">let hotkey = try CGSKeyboardShortcut(identifier: .myShortcut,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                                     keyCode: 0x7E,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                                     modifierFlags: [.maskCommand, .maskControl],</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                                     acquisitionPolicy: .exclusivelyIfPossible)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">let tracker = TapHoldShortcutRecognizer {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    _ = NSAlert(style: .informational, text: &quot;Double tap and hold succeeded!&quot;).runModal()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">self.observer = tracker.bind(to: hotkey)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">// ... elsewhere ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public extension CGSKeyboardShortcut.Identifier {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public static let myShortcut = CGSKeyboardShortcut.Identifier(0xBAAAAAAD)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><em>(That <code>NSAlert</code> initializer is pretty easy to implement and is left as an exercise for the reader.)</em></p><p><img loading="lazy" alt="Sample Alert" src="/assets/images/shortcut-recognizer-action-f45fcc8970120ce12943725d24f79007.png" width="1064" height="526" class="img_ev3q"></p><hr><h2 class="anchor anchorWithStickyNavbar_LWe7" id="conclusion">Conclusion<a href="#conclusion" class="hash-link" aria-label="Direct link to Conclusion" title="Direct link to Conclusion">​</a></h2><p>In short, there are better ways to do keyboard shortcuts than to resign to Carbon. Unfortunately, for those targeting the Mac App Store, this has just been an exercise in futility. An alternate implementation of <code>CGSKeyboardShortcut</code> could probably just wrap <code>RegisterEventHotKey</code> but that&#x27;s no fun is it? Might as well just use <code>MASShortcut</code> or something else and not deal with writing it yourself. </p><p>In the next episode, I&#x27;ll be designing and developing a corresponding view to display and record keyboard shortcuts! If you have any questions, comments, or concerns, contact me on Twitter or Github @avaidyam!</p></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Blog post page navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/blog/2018/03/22/"><div class="pagination-nav__sublabel">Newer Post</div><div class="pagination-nav__label">An Exercise in Modern Cocoa Views</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/blog/2018/02/22/"><div class="pagination-nav__sublabel">Older Post</div><div class="pagination-nav__label">The Secret Life of Core Animation</div></a></nav></main><div class="col col--2"><div class="tableOfContents_bqdL thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#how-does-registereventhotkey-work" class="table-of-contents__link toc-highlight">How does <code>RegisterEventHotKey</code> work?</a><ul><li><a href="#disassembly--reverse-engineering" class="table-of-contents__link toc-highlight">Disassembly &amp; Reverse Engineering</a></li><li><a href="#cgshotkey-symbols" class="table-of-contents__link toc-highlight">CGSHotKey Symbols</a></li></ul></li><li><a href="#building-a-replacement-cgskeyboardshortcut" class="table-of-contents__link toc-highlight">Building a replacement: <code>CGSKeyboardShortcut</code>!</a><ul><li><a href="#properties--acquisition-policy" class="table-of-contents__link toc-highlight">Properties &amp; Acquisition Policy</a></li><li><a href="#resource-management" class="table-of-contents__link toc-highlight">Resource Management</a></li><li><a href="#windowserver-acquisition--invalidation" class="table-of-contents__link toc-highlight">WindowServer Acquisition &amp; Invalidation</a></li><li><a href="#local-event-handling" class="table-of-contents__link toc-highlight">Local Event Handling</a></li><li><a href="#the-magic-within-registereventhotkey" class="table-of-contents__link toc-highlight">The Magic Within <code>RegisterEventHotKey</code></a></li><li><a href="#frozen-representations" class="table-of-contents__link toc-highlight">Frozen Representations</a></li><li><a href="#cgkeycode--cgeventflags-supplements" class="table-of-contents__link toc-highlight">CGKeyCode &amp; CGEventFlags Supplements</a></li></ul></li><li><a href="#building-higher-order-recognizers" class="table-of-contents__link toc-highlight">Building Higher-Order Recognizers</a><ul><li><a href="#why" class="table-of-contents__link toc-highlight">Why?</a></li><li><a href="#how" class="table-of-contents__link toc-highlight">How?</a></li><li><a href="#binding-to-a-cgskeyboardshortcut" class="table-of-contents__link toc-highlight">Binding to a <code>CGSKeyboardShortcut</code></a></li><li><a href="#sample-usage" class="table-of-contents__link toc-highlight">Sample Usage</a></li></ul></li><li><a href="#conclusion" class="table-of-contents__link toc-highlight">Conclusion</a></li></ul></div></div></div></div></div></div>
<script src="/assets/js/runtime~main.4118853a.js"></script>
<script src="/assets/js/main.2f45d6ae.js"></script>
</body>
</html>